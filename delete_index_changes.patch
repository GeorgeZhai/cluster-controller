From 74a4acc0b53e6b5502a94bd33f2b501a308a8ac8 Mon Sep 17 00:00:00 2001
From: Darby Clement <darbyclement@gmail.com>
Date: Mon, 15 Sep 2025 10:05:29 -0700
Subject: [PATCH 01/12] discovery - prune nodes based on actual state ts

---
 .../clustercontroller/config/Constants.java   |  3 +
 .../discovery/Discovery.java                  | 80 ++++++++++++++++++-
 .../discovery/DiscoveryTest.java              |  4 +-
 3 files changed, 81 insertions(+), 6 deletions(-)

diff --git a/src/main/java/io/clustercontroller/config/Constants.java b/src/main/java/io/clustercontroller/config/Constants.java
index 399b18f..11113a9 100644
--- a/src/main/java/io/clustercontroller/config/Constants.java
+++ b/src/main/java/io/clustercontroller/config/Constants.java
@@ -55,6 +55,9 @@ public final class Constants {
     public static final int HEALTH_CHECK_MEMORY_THRESHOLD_PERCENT = 90;
     public static final long HEALTH_CHECK_DISK_THRESHOLD_MB = 1024;
     
+    // Discovery cleanup thresholds
+    public static final long STALE_SEARCH_UNIT_TIMEOUT_MINUTES = 10L;
+    
     // Admin state values
     public static final String ADMIN_STATE_NORMAL = "NORMAL";
     public static final String ADMIN_STATE_DRAIN = "DRAIN";
diff --git a/src/main/java/io/clustercontroller/discovery/Discovery.java b/src/main/java/io/clustercontroller/discovery/Discovery.java
index 92646a6..8a67909 100644
--- a/src/main/java/io/clustercontroller/discovery/Discovery.java
+++ b/src/main/java/io/clustercontroller/discovery/Discovery.java
@@ -1,5 +1,6 @@
 package io.clustercontroller.discovery;
 
+import io.clustercontroller.config.Constants;
 import io.clustercontroller.enums.HealthState;
 import io.clustercontroller.models.NodeAttributes;
 import io.clustercontroller.models.SearchUnit;
@@ -32,14 +33,17 @@ public class Discovery {
         // Discover and update search units from Etcd actual-states
         discoverSearchUnitsFromEtcd();
         
-        // Process all search units to ensure they're up-to-date and handle any stale ones
+        // Clean up stale search units before processing
+        cleanupStaleSearchUnits();
+        
+        // Process all search units to ensure they're up-to-date
         processAllSearchUnits();
         
         log.info("Discovery - Completed search unit discovery process");
     }
     
     /**
-     * Process all search units to ensure they're current and handle stale ones
+     * Process all search units to ensure they're current
      */
     private void processAllSearchUnits() {
         try {
@@ -163,10 +167,78 @@ public class Discovery {
         return searchUnit;
     }
     
+    /**
+     * Clean up search units with missing or stale actual state timestamp (older than configured timeout)
+     */
+    private void cleanupStaleSearchUnits() {
+        try {
+            log.info("Discovery - Starting cleanup of stale search units...");
+            
+            // Get all existing search units from metadata store
+            List<SearchUnit> allSearchUnits = metadataStore.getAllSearchUnits();
+            int deletedCount = 0;
+            
+            for (SearchUnit searchUnit : allSearchUnits) {
+                String unitName = searchUnit.getName();
+                
+                try {
+                    // Check if actual state exists
+                    java.util.Optional<SearchUnitActualState> actualStateOpt = 
+                            metadataStore.getSearchUnitActualState(unitName);
+                    
+                    boolean shouldDelete = false;
+                    String reason = "";
+                    
+                    if (!actualStateOpt.isPresent()) {
+                        // Case 1: Missing actual state
+                        shouldDelete = true;
+                        reason = "missing actual state";
+                    } else {
+                        // Case 2: Check if timestamp is older than configured timeout
+                        SearchUnitActualState actualState = actualStateOpt.get();
+                        if (isActualStateStale(actualState)) {
+                            shouldDelete = true;
+                            reason = "stale timestamp (older than " + Constants.STALE_SEARCH_UNIT_TIMEOUT_MINUTES + " minutes)";
+                        }
+                    }
+                    
+                    if (shouldDelete) {
+                        log.info("Discovery - Deleting search unit '{}' due to: {}", unitName, reason);
+                        metadataStore.deleteSearchUnit(unitName);
+                        deletedCount++;
+                    }
+                    
+                } catch (Exception e) {
+                    log.error("Discovery - Failed to check/delete search unit '{}': {}", unitName, e.getMessage());
+                }
+            }
+            
+            log.info("Discovery - Cleanup completed. Deleted {} stale search units", deletedCount);
+            
+        } catch (Exception e) {
+            log.error("Discovery - Failed to cleanup stale search units: {}", e.getMessage(), e);
+        }
+    }
     
+    /**
+     * Check if actual state timestamp is older than the configured timeout
+     */
+    private boolean isActualStateStale(SearchUnitActualState actualState) {
+        long currentTime = System.currentTimeMillis();
+        long nodeTimestamp = actualState.getTimestamp();
+        long timeDiff = currentTime - nodeTimestamp;
+        long timeoutInMs = Constants.STALE_SEARCH_UNIT_TIMEOUT_MINUTES * 60 * 1000; // Convert minutes to milliseconds
+        
+        boolean isStale = timeDiff > timeoutInMs;
+        
+        if (isStale) {
+            log.debug("Discovery - Actual state is stale: timestamp={}, age={}ms ({}min), threshold={}ms ({}min)", 
+                nodeTimestamp, timeDiff, timeDiff / (60 * 1000), timeoutInMs, Constants.STALE_SEARCH_UNIT_TIMEOUT_MINUTES);
+        }
+        
+        return isStale;
+    }
 
-    
-    
     public void monitorClusterHealth() {
         log.info("Monitoring cluster health");
         // TODO: Implement cluster health monitoring logic
diff --git a/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java b/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
index 2139ecf..52af4d2 100644
--- a/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
+++ b/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
@@ -51,7 +51,7 @@ class DiscoveryTest {
         
         // Then
         verify(metadataStore).getAllSearchUnitActualStates();
-        verify(metadataStore).getAllSearchUnits();
+        verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
         verify(metadataStore, times(3)).getSearchUnit(anyString()); // 3 units
         verify(metadataStore, times(3)).upsertSearchUnit(anyString(), any(SearchUnit.class));
     }
@@ -89,7 +89,7 @@ class DiscoveryTest {
         assertThatCode(() -> discovery.discoverSearchUnits()).doesNotThrowAnyException();
         
         verify(metadataStore).getAllSearchUnitActualStates();
-        verify(metadataStore).getAllSearchUnits();
+        verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
     }
     
     // =================================================================
-- 
2.50.1


From f54364b84b1fa4bab468139b0e00feddd7498fd2 Mon Sep 17 00:00:00 2001
From: Darby Clement <darbyclement@gmail.com>
Date: Mon, 15 Sep 2025 14:22:54 -0700
Subject: [PATCH 02/12] add UT for deletion

---
 .../discovery/DiscoveryTest.java              | 60 +++++++++++++++++++
 1 file changed, 60 insertions(+)

diff --git a/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java b/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
index 52af4d2..d4eb7d7 100644
--- a/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
+++ b/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
@@ -1,5 +1,6 @@
 package io.clustercontroller.discovery;
 
+import io.clustercontroller.config.Constants;
 import io.clustercontroller.enums.HealthState;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.models.SearchUnitActualState;
@@ -92,6 +93,65 @@ class DiscoveryTest {
         verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
     }
     
+    @Test
+    void testDiscoverSearchUnits_CleanupStaleSearchUnits() throws Exception {
+        // Given - Set up scenario with one fresh unit and one stale unit
+        long currentTime = System.currentTimeMillis();
+        long staleTimeoutMs = Constants.STALE_SEARCH_UNIT_TIMEOUT_MINUTES * 60 * 1000;
+        long staleTimestamp = currentTime - staleTimeoutMs - 60000; // 1 minute older than threshold
+        long freshTimestamp = currentTime - 60000; // 1 minute old (fresh)
+        
+        // Mock actual states - both units discovered from Etcd
+        Map<String, SearchUnitActualState> actualStates = new HashMap<>();
+        SearchUnitActualState freshState = createHealthyActualState("fresh-node", "10.0.1.100", 9200);
+        freshState.setRole("primary");
+        freshState.setShardId("shard-1");
+        freshState.setClusterName("test-cluster");
+        freshState.setTimestamp(freshTimestamp);
+        actualStates.put("fresh-node", freshState);
+        
+        SearchUnitActualState staleState = createHealthyActualState("stale-node", "10.0.1.101", 9200);
+        staleState.setRole("replica");
+        staleState.setShardId("shard-2");
+        staleState.setClusterName("test-cluster");
+        staleState.setTimestamp(staleTimestamp);
+        actualStates.put("stale-node", staleState);
+        
+        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(actualStates);
+        
+        // Mock existing search units - both units exist in metadata store initially
+        SearchUnit freshUnit = createMockSearchUnit("fresh-node", "primary");
+        SearchUnit staleUnit = createMockSearchUnit("stale-node", "replica");
+        List<SearchUnit> initialUnits = Arrays.asList(freshUnit, staleUnit);
+        List<SearchUnit> unitsAfterCleanup = Arrays.asList(freshUnit); // Only fresh unit remains
+        when(metadataStore.getAllSearchUnits())
+                .thenReturn(initialUnits)  // First call for cleanup
+                .thenReturn(unitsAfterCleanup); // Second call for processing
+        
+        // Mock actual state lookups for cleanup
+        when(metadataStore.getSearchUnitActualState("fresh-node"))
+                .thenReturn(Optional.of(freshState));
+        when(metadataStore.getSearchUnitActualState("stale-node"))
+                .thenReturn(Optional.of(staleState));
+        
+        // Mock unit lookups for discovery phase
+        when(metadataStore.getSearchUnit("fresh-node")).thenReturn(Optional.of(freshUnit));
+        when(metadataStore.getSearchUnit("stale-node")).thenReturn(Optional.of(staleUnit));
+        
+        // When
+        discovery.discoverSearchUnits();
+        
+        // Then - Verify the stale unit was deleted but fresh unit was not
+        verify(metadataStore).deleteSearchUnit("stale-node"); // Stale unit should be deleted
+        verify(metadataStore, never()).deleteSearchUnit("fresh-node"); // Fresh unit should NOT be deleted
+        
+        // Verify units were updated: 2 during discovery phase + 1 during processing phase (fresh unit only)
+        verify(metadataStore, times(3)).updateSearchUnit(any(SearchUnit.class));
+        
+        // Verify the cleanup and processing phases both called getAllSearchUnits
+        verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
+    }
+    
     // =================================================================
     // FETCH SEARCH UNITS FROM ETCD TESTS
     // =================================================================
-- 
2.50.1


From 58183234db47639df25ac4dea50246b1a48a7278 Mon Sep 17 00:00:00 2001
From: tjnaik <tjnaik@uber.com>
Date: Wed, 17 Sep 2025 18:52:47 -0700
Subject: [PATCH 03/12] Implement AllocationDecider framework for modular node
 selection

- Decision-based decider chain pattern for shard allocation
- Configurable deciders: Health, Role, ShardPool, AllNodes
- Enable/disable deciders at runtime for flexible allocation policies
---
 .../allocation/AllocationDecisionEngine.java  | 102 ++++++++++++++
 .../allocation/deciders/AllNodesDecider.java  |  28 ++++
 .../deciders/AllocationDecider.java           |  42 ++++++
 .../allocation/deciders/HealthDecider.java    |  40 ++++++
 .../allocation/deciders/RoleDecider.java      |  45 ++++++
 .../allocation/deciders/ShardPoolDecider.java |  29 ++++
 .../io/clustercontroller/enums/Decision.java  |  16 +++
 .../io/clustercontroller/enums/NodeRole.java  |  34 +++++
 .../AllocationDecisionEngineTest.java         | 133 ++++++++++++++++++
 .../deciders/AllNodesDeciderTest.java         |  59 ++++++++
 .../deciders/HealthDeciderTest.java           |  61 ++++++++
 .../allocation/deciders/RoleDeciderTest.java  |  81 +++++++++++
 .../deciders/ShardPoolDeciderTest.java        |  60 ++++++++
 .../clustercontroller/enums/DecisionTest.java |  22 +++
 .../clustercontroller/enums/NodeRoleTest.java |  40 ++++++
 15 files changed, 792 insertions(+)
 create mode 100644 src/main/java/io/clustercontroller/allocation/AllocationDecisionEngine.java
 create mode 100644 src/main/java/io/clustercontroller/allocation/deciders/AllNodesDecider.java
 create mode 100644 src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java
 create mode 100644 src/main/java/io/clustercontroller/allocation/deciders/HealthDecider.java
 create mode 100644 src/main/java/io/clustercontroller/allocation/deciders/RoleDecider.java
 create mode 100644 src/main/java/io/clustercontroller/allocation/deciders/ShardPoolDecider.java
 create mode 100644 src/main/java/io/clustercontroller/enums/Decision.java
 create mode 100644 src/main/java/io/clustercontroller/enums/NodeRole.java
 create mode 100644 src/test/java/io/clustercontroller/allocation/AllocationDecisionEngineTest.java
 create mode 100644 src/test/java/io/clustercontroller/allocation/deciders/AllNodesDeciderTest.java
 create mode 100644 src/test/java/io/clustercontroller/allocation/deciders/HealthDeciderTest.java
 create mode 100644 src/test/java/io/clustercontroller/allocation/deciders/RoleDeciderTest.java
 create mode 100644 src/test/java/io/clustercontroller/allocation/deciders/ShardPoolDeciderTest.java
 create mode 100644 src/test/java/io/clustercontroller/enums/DecisionTest.java
 create mode 100644 src/test/java/io/clustercontroller/enums/NodeRoleTest.java

diff --git a/src/main/java/io/clustercontroller/allocation/AllocationDecisionEngine.java b/src/main/java/io/clustercontroller/allocation/AllocationDecisionEngine.java
new file mode 100644
index 0000000..c329eb5
--- /dev/null
+++ b/src/main/java/io/clustercontroller/allocation/AllocationDecisionEngine.java
@@ -0,0 +1,102 @@
+package io.clustercontroller.allocation;
+
+import io.clustercontroller.allocation.deciders.*;
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+import lombok.extern.slf4j.Slf4j;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * Allocation decision engine that chains multiple AllocationDeciders.
+ * 
+ * Evaluates all enabled deciders and returns nodes that pass all checks.
+ * Callers must explicitly enable the deciders they want to use.
+ */
+@Slf4j
+public class AllocationDecisionEngine {
+    
+    private final Map<Class<? extends AllocationDecider>, AllocationDecider> availableDeciders;
+    
+    /**
+     * List of currently enabled deciders - populated by calling enableDecider().
+     * Callers must explicitly enable the deciders they want to use.
+     * 
+     * TODO: Make decider configuration externally configurable via properties
+     */
+    private final List<AllocationDecider> enabledDeciders;
+    
+    public AllocationDecisionEngine() {
+        this.availableDeciders = new HashMap<>();
+        this.enabledDeciders = new ArrayList<>();
+        
+        // Register all available deciders
+        registerDecider(AllNodesDecider.class, new AllNodesDecider());
+        registerDecider(HealthDecider.class, new HealthDecider());
+        registerDecider(RoleDecider.class, new RoleDecider());
+        registerDecider(ShardPoolDecider.class, new ShardPoolDecider());
+    }
+    
+    /**
+     * Get available nodes for allocation by applying all enabled deciders.
+     */
+    public List<SearchUnit> getAvailableNodesForAllocation(String shardId, String indexName, 
+                                                          List<SearchUnit> candidateNodes, NodeRole targetRole) {
+        List<SearchUnit> selectedNodes = new ArrayList<>();
+        
+        // If no deciders enabled, return empty list
+        if (enabledDeciders.isEmpty()) {
+            return selectedNodes; // Empty list
+        }
+        
+        for (SearchUnit node : candidateNodes) {
+            Decision finalDecision = Decision.YES;
+            
+            for (AllocationDecider decider : enabledDeciders) {
+                if (!decider.isEnabled()) continue;
+                
+                Decision deciderResult = decider.canAllocate(shardId, node, indexName, targetRole);
+                finalDecision = finalDecision.merge(deciderResult);
+                
+                if (finalDecision == Decision.NO) break;
+            }
+            
+            if (finalDecision == Decision.YES) {
+                selectedNodes.add(node);
+            }
+        }
+        
+        return selectedNodes;
+    }
+    
+    /**
+     * Enable a decider.
+     */
+    public void enableDecider(Class<? extends AllocationDecider> deciderClass) {
+        AllocationDecider decider = availableDeciders.get(deciderClass);
+        if (decider != null && !enabledDeciders.contains(decider)) {
+            decider.setEnabled(true);
+            enabledDeciders.add(decider);
+        }
+    }
+    
+    /**
+     * Disable a decider.
+     */
+    public void disableDecider(Class<? extends AllocationDecider> deciderClass) {
+        AllocationDecider decider = availableDeciders.get(deciderClass);
+        if (decider != null) {
+            decider.setEnabled(false);
+            enabledDeciders.remove(decider);
+        }
+    }
+    
+    /**
+     * Register a decider.
+     */
+    public void registerDecider(Class<? extends AllocationDecider> deciderClass, AllocationDecider decider) {
+        availableDeciders.put(deciderClass, decider);
+    }
+}
diff --git a/src/main/java/io/clustercontroller/allocation/deciders/AllNodesDecider.java b/src/main/java/io/clustercontroller/allocation/deciders/AllNodesDecider.java
new file mode 100644
index 0000000..20fdb7e
--- /dev/null
+++ b/src/main/java/io/clustercontroller/allocation/deciders/AllNodesDecider.java
@@ -0,0 +1,28 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+
+/**
+ * Simple decider that accepts all nodes.
+ * 
+ * Used as fallback when no specific filtering is needed.
+ */
+public class AllNodesDecider implements AllocationDecider {
+    private boolean enabled = true;
+    
+    @Override
+    public Decision canAllocate(String shardId, SearchUnit node, String indexName, NodeRole targetRole) {
+        return Decision.YES;
+    }
+    
+    @Override
+    public String getName() { return "AllNodesDecider"; }
+    
+    @Override
+    public boolean isEnabled() { return enabled; }
+    
+    @Override
+    public void setEnabled(boolean enabled) { this.enabled = enabled; }
+}
diff --git a/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java b/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java
new file mode 100644
index 0000000..8feb2cf
--- /dev/null
+++ b/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java
@@ -0,0 +1,42 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+
+/**
+ * Interface for allocation decision making.
+ * 
+ * Each AllocationDecider implements a specific rule for determining
+ * whether a shard can be allocated to a particular node.
+ * 
+ * Inspired by OpenSearch's AllocationDecider pattern.
+ */
+public interface AllocationDecider {
+    
+    /**
+     * Determine if a shard can be allocated to a node.
+     * 
+     * @param shardId the shard ID to allocate
+     * @param node the target node
+     * @param indexName the index name
+     * @param targetRole the role we're selecting for
+     * @return allocation decision
+     */
+    Decision canAllocate(String shardId, SearchUnit node, String indexName, NodeRole targetRole);
+    
+    /**
+     * Get the name of this decider.
+     */
+    String getName();
+    
+    /**
+     * Check if this decider is enabled.
+     */
+    boolean isEnabled();
+    
+    /**
+     * Enable or disable this decider.
+     */
+    void setEnabled(boolean enabled);
+}
diff --git a/src/main/java/io/clustercontroller/allocation/deciders/HealthDecider.java b/src/main/java/io/clustercontroller/allocation/deciders/HealthDecider.java
new file mode 100644
index 0000000..a63c255
--- /dev/null
+++ b/src/main/java/io/clustercontroller/allocation/deciders/HealthDecider.java
@@ -0,0 +1,40 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+
+/**
+ * Decider that filters nodes based on health status.
+ * 
+ * Rejects nodes with stateAdmin != "NORMAL" or statePulled == RED.
+ */
+public class HealthDecider implements AllocationDecider {
+    private boolean enabled = true;
+    
+    @Override
+    public Decision canAllocate(String shardId, SearchUnit node, String indexName, NodeRole targetRole) {
+        String stateAdmin = node.getStateAdmin();
+        HealthState statePulled = node.getStatePulled();
+        
+        if (stateAdmin == null || !"NORMAL".equalsIgnoreCase(stateAdmin)) {
+            return Decision.NO;
+        }
+        
+        if (statePulled == HealthState.RED) {
+            return Decision.NO;
+        }
+        
+        return Decision.YES;
+    }
+    
+    @Override
+    public String getName() { return "HealthDecider"; }
+    
+    @Override
+    public boolean isEnabled() { return enabled; }
+    
+    @Override
+    public void setEnabled(boolean enabled) { this.enabled = enabled; }
+}
diff --git a/src/main/java/io/clustercontroller/allocation/deciders/RoleDecider.java b/src/main/java/io/clustercontroller/allocation/deciders/RoleDecider.java
new file mode 100644
index 0000000..b7dce35
--- /dev/null
+++ b/src/main/java/io/clustercontroller/allocation/deciders/RoleDecider.java
@@ -0,0 +1,45 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+
+/**
+ * Decider that filters nodes based on strict role matching.
+ * 
+ * PRIMARY target: only PRIMARY nodes. REPLICA target: only REPLICA nodes.
+ * Always rejects COORDINATOR nodes.
+ */
+public class RoleDecider implements AllocationDecider {
+    private boolean enabled = true;
+    
+    @Override
+    public Decision canAllocate(String shardId, SearchUnit node, String indexName, NodeRole targetRole) {
+        String nodeRoleString = node.getRole();
+        if (nodeRoleString == null) return Decision.NO;
+        
+        NodeRole nodeRole = NodeRole.fromString(nodeRoleString);
+        if (nodeRole == null) return Decision.NO;
+        
+        if (nodeRole == NodeRole.COORDINATOR) return Decision.NO;
+        
+        if (targetRole == NodeRole.PRIMARY) {
+            return nodeRole == NodeRole.PRIMARY ? Decision.YES : Decision.NO;
+        }
+        
+        if (targetRole == NodeRole.REPLICA) {
+            return nodeRole == NodeRole.REPLICA ? Decision.YES : Decision.NO;
+        }
+        
+        return Decision.NO;
+    }
+    
+    @Override
+    public String getName() { return "RoleDecider"; }
+    
+    @Override
+    public boolean isEnabled() { return enabled; }
+    
+    @Override
+    public void setEnabled(boolean enabled) { this.enabled = enabled; }
+}
diff --git a/src/main/java/io/clustercontroller/allocation/deciders/ShardPoolDecider.java b/src/main/java/io/clustercontroller/allocation/deciders/ShardPoolDecider.java
new file mode 100644
index 0000000..641f5d8
--- /dev/null
+++ b/src/main/java/io/clustercontroller/allocation/deciders/ShardPoolDecider.java
@@ -0,0 +1,29 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+
+/**
+ * Decider that filters nodes based on shard pool assignment.
+ * 
+ * Only allows allocation to nodes where node.getShardId() matches the target shardId.
+ */
+public class ShardPoolDecider implements AllocationDecider {
+    private boolean enabled = true;
+    
+    @Override
+    public Decision canAllocate(String shardId, SearchUnit node, String indexName, NodeRole targetRole) {
+        String nodeShardId = node.getShardId();
+        return (nodeShardId != null && nodeShardId.equals(shardId)) ? Decision.YES : Decision.NO;
+    }
+    
+    @Override
+    public String getName() { return "ShardPoolDecider"; }
+    
+    @Override
+    public boolean isEnabled() { return enabled; }
+    
+    @Override
+    public void setEnabled(boolean enabled) { this.enabled = enabled; }
+}
diff --git a/src/main/java/io/clustercontroller/enums/Decision.java b/src/main/java/io/clustercontroller/enums/Decision.java
new file mode 100644
index 0000000..8a030c1
--- /dev/null
+++ b/src/main/java/io/clustercontroller/enums/Decision.java
@@ -0,0 +1,16 @@
+package io.clustercontroller.enums;
+
+/**
+ * Allocation decision result.
+ * 
+ * Merge precedence: NO > THROTTLE > YES
+ */
+public enum Decision {
+    YES, NO, THROTTLE;
+    
+    public Decision merge(Decision other) {
+        if (this == NO || other == NO) return NO;
+        if (this == THROTTLE || other == THROTTLE) return THROTTLE;
+        return YES;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/enums/NodeRole.java b/src/main/java/io/clustercontroller/enums/NodeRole.java
new file mode 100644
index 0000000..e2bd0d1
--- /dev/null
+++ b/src/main/java/io/clustercontroller/enums/NodeRole.java
@@ -0,0 +1,34 @@
+package io.clustercontroller.enums;
+
+/**
+ * Node roles used by AllocationDeciders.
+ * 
+ * PRIMARY: ingest + search, REPLICA: search only, COORDINATOR: routing only
+ */
+public enum NodeRole {
+    PRIMARY("primary"),
+    REPLICA("replica"), 
+    COORDINATOR("coordinator");
+    
+    private final String value;
+    
+    NodeRole(String value) {
+        this.value = value;
+    }
+    
+    public String getValue() {
+        return value;
+    }
+    
+    public static NodeRole fromString(String value) {
+        if (value == null) return null;
+        
+        String normalized = value.toLowerCase().trim();
+        for (NodeRole role : NodeRole.values()) {
+            if (role.value.equals(normalized)) {
+                return role;
+            }
+        }
+        return null; // Return null for unknown roles instead of throwing exception
+    }
+}
diff --git a/src/test/java/io/clustercontroller/allocation/AllocationDecisionEngineTest.java b/src/test/java/io/clustercontroller/allocation/AllocationDecisionEngineTest.java
new file mode 100644
index 0000000..53911d4
--- /dev/null
+++ b/src/test/java/io/clustercontroller/allocation/AllocationDecisionEngineTest.java
@@ -0,0 +1,133 @@
+package io.clustercontroller.allocation;
+
+import io.clustercontroller.allocation.deciders.*;
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class AllocationDecisionEngineTest {
+    
+    private AllocationDecisionEngine engine;
+    private SearchUnit healthyPrimary;
+    private SearchUnit unhealthyNode;
+    private SearchUnit coordinatorNode;
+    
+    @BeforeEach
+    void setUp() {
+        engine = new AllocationDecisionEngine();
+        
+        // Register deciders
+        engine.registerDecider(AllNodesDecider.class, new AllNodesDecider());
+        engine.registerDecider(HealthDecider.class, new HealthDecider());
+        engine.registerDecider(RoleDecider.class, new RoleDecider());
+        engine.registerDecider(ShardPoolDecider.class, new ShardPoolDecider());
+        
+        // Create test nodes
+        healthyPrimary = createSearchUnit("node1", "primary", "NORMAL", HealthState.GREEN, "0");
+        unhealthyNode = createSearchUnit("node2", "primary", "NORMAL", HealthState.RED, "0");
+        coordinatorNode = createSearchUnit("coord1", "coordinator", "NORMAL", HealthState.GREEN, "0");
+    }
+    
+    
+    @Test
+    void testDeciderChain() {
+        engine.enableDecider(HealthDecider.class);
+        engine.enableDecider(RoleDecider.class);
+        
+        List<SearchUnit> candidates = Arrays.asList(healthyPrimary, unhealthyNode, coordinatorNode);
+        List<SearchUnit> selected = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        
+        // Only healthy primary should pass
+        assertThat(selected).hasSize(1);
+        assertThat(selected).containsExactly(healthyPrimary);
+    }
+    
+    @Test
+    void testNoDecidersEnabled() {
+        // With no deciders enabled, should return empty list
+        List<SearchUnit> candidates = Arrays.asList(healthyPrimary);
+        List<SearchUnit> selected = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        
+        assertThat(selected).isEmpty();
+    }
+    
+    @Test
+    void testEnableDisableDeciders() {
+        engine.enableDecider(HealthDecider.class);
+        
+        List<SearchUnit> candidates = Arrays.asList(unhealthyNode);
+        
+        // With HealthDecider enabled, unhealthy node rejected
+        List<SearchUnit> selected1 = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        assertThat(selected1).isEmpty();
+        
+        // Disable HealthDecider
+        engine.disableDecider(HealthDecider.class);
+        
+        // Still empty because no deciders enabled
+        List<SearchUnit> selected2 = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        assertThat(selected2).isEmpty();
+        
+        // Enable AllNodesDecider
+        engine.enableDecider(AllNodesDecider.class);
+        List<SearchUnit> selected3 = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        assertThat(selected3).hasSize(1);
+        assertThat(selected3).containsExactly(unhealthyNode);
+    }
+    
+    @Test
+    void testShardPoolFiltering() {
+        SearchUnit wrongShardNode = createSearchUnit("wrong1", "primary", "NORMAL", HealthState.GREEN, "1");
+        
+        engine.enableDecider(ShardPoolDecider.class);
+        
+        List<SearchUnit> candidates = Arrays.asList(healthyPrimary, wrongShardNode);
+        List<SearchUnit> selected = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        
+        // Should only include nodes from shard 0
+        assertThat(selected).hasSize(1);
+        assertThat(selected).containsExactly(healthyPrimary);
+    }
+    
+    @Test
+    void testComplexDeciderChain() {
+        // Enable all deciders
+        engine.enableDecider(HealthDecider.class);
+        engine.enableDecider(RoleDecider.class);
+        engine.enableDecider(ShardPoolDecider.class);
+        
+        SearchUnit perfectNode = createSearchUnit("perfect", "primary", "NORMAL", HealthState.GREEN, "0");
+        SearchUnit wrongShardNode = createSearchUnit("wrong-shard", "primary", "NORMAL", HealthState.GREEN, "1");
+        SearchUnit wrongRoleNode = createSearchUnit("wrong-role", "replica", "NORMAL", HealthState.GREEN, "0");
+        SearchUnit unhealthyNode = createSearchUnit("unhealthy", "primary", "NORMAL", HealthState.RED, "0");
+        SearchUnit drainedNode = createSearchUnit("drained", "primary", "DRAIN", HealthState.GREEN, "0");
+        
+        List<SearchUnit> candidates = Arrays.asList(
+            perfectNode, wrongShardNode, wrongRoleNode, unhealthyNode, drainedNode
+        );
+        
+        List<SearchUnit> selected = engine.getAvailableNodesForAllocation("0", "test-index", candidates, NodeRole.PRIMARY);
+        
+        // Only perfect node should pass all deciders
+        assertThat(selected).hasSize(1);
+        assertThat(selected).containsExactly(perfectNode);
+    }
+    
+    private SearchUnit createSearchUnit(String name, String role, String stateAdmin, HealthState statePulled, String shardId) {
+        SearchUnit unit = new SearchUnit();
+        unit.setName(name);
+        unit.setRole(role);
+        unit.setStateAdmin(stateAdmin);
+        unit.setStatePulled(statePulled);
+        unit.setShardId(shardId);
+        return unit;
+    }
+}
diff --git a/src/test/java/io/clustercontroller/allocation/deciders/AllNodesDeciderTest.java b/src/test/java/io/clustercontroller/allocation/deciders/AllNodesDeciderTest.java
new file mode 100644
index 0000000..da658ba
--- /dev/null
+++ b/src/test/java/io/clustercontroller/allocation/deciders/AllNodesDeciderTest.java
@@ -0,0 +1,59 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class AllNodesDeciderTest {
+    
+    private AllNodesDecider decider;
+    
+    @BeforeEach
+    void setUp() {
+        decider = new AllNodesDecider();
+    }
+    
+    @Test
+    void testAcceptsAllNodes() {
+        SearchUnit primaryNode = createSearchUnit("node1", "primary", HealthState.GREEN);
+        SearchUnit replicaNode = createSearchUnit("node2", "replica", HealthState.YELLOW);
+        SearchUnit coordinatorNode = createSearchUnit("coord1", "coordinator", HealthState.GREEN);
+        SearchUnit unhealthyNode = createSearchUnit("node3", "primary", HealthState.RED);
+        
+        assertThat(decider.canAllocate("0", primaryNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("0", replicaNode, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("0", coordinatorNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("0", unhealthyNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.YES);
+    }
+    
+    @Test
+    void testDeciderProperties() {
+        assertThat(decider.getName()).isEqualTo("AllNodesDecider");
+        assertThat(decider.isEnabled()).isTrue();
+        
+        decider.setEnabled(false);
+        assertThat(decider.isEnabled()).isFalse();
+        
+        decider.setEnabled(true);
+        assertThat(decider.isEnabled()).isTrue();
+    }
+    
+    private SearchUnit createSearchUnit(String name, String role, HealthState healthState) {
+        SearchUnit unit = new SearchUnit();
+        unit.setName(name);
+        unit.setRole(role);
+        unit.setStateAdmin("NORMAL");
+        unit.setStatePulled(healthState);
+        unit.setShardId("0");
+        return unit;
+    }
+}
diff --git a/src/test/java/io/clustercontroller/allocation/deciders/HealthDeciderTest.java b/src/test/java/io/clustercontroller/allocation/deciders/HealthDeciderTest.java
new file mode 100644
index 0000000..dc05794
--- /dev/null
+++ b/src/test/java/io/clustercontroller/allocation/deciders/HealthDeciderTest.java
@@ -0,0 +1,61 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class HealthDeciderTest {
+    
+    private HealthDecider decider;
+    
+    @BeforeEach
+    void setUp() {
+        decider = new HealthDecider();
+    }
+    
+    @Test
+    void testHealthyNodesAccepted() {
+        SearchUnit greenNode = createSearchUnit("node1", "primary", "NORMAL", HealthState.GREEN);
+        SearchUnit yellowNode = createSearchUnit("node2", "replica", "NORMAL", HealthState.YELLOW);
+        
+        assertThat(decider.canAllocate("0", greenNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("0", yellowNode, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.YES);
+    }
+    
+    @Test
+    void testUnhealthyNodesRejected() {
+        SearchUnit redNode = createSearchUnit("node1", "primary", "NORMAL", HealthState.RED);
+        SearchUnit drainedNode = createSearchUnit("node2", "primary", "DRAIN", HealthState.GREEN);
+        SearchUnit nullAdminNode = createSearchUnit("node3", "primary", null, HealthState.GREEN);
+        
+        assertThat(decider.canAllocate("0", redNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", drainedNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", nullAdminNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+    }
+    
+    @Test
+    void testDeciderProperties() {
+        assertThat(decider.getName()).isEqualTo("HealthDecider");
+        assertThat(decider.isEnabled()).isTrue();
+    }
+    
+    private SearchUnit createSearchUnit(String name, String role, String stateAdmin, HealthState statePulled) {
+        SearchUnit unit = new SearchUnit();
+        unit.setName(name);
+        unit.setRole(role);
+        unit.setStateAdmin(stateAdmin);
+        unit.setStatePulled(statePulled);
+        unit.setShardId("0");
+        return unit;
+    }
+}
diff --git a/src/test/java/io/clustercontroller/allocation/deciders/RoleDeciderTest.java b/src/test/java/io/clustercontroller/allocation/deciders/RoleDeciderTest.java
new file mode 100644
index 0000000..be9c87f
--- /dev/null
+++ b/src/test/java/io/clustercontroller/allocation/deciders/RoleDeciderTest.java
@@ -0,0 +1,81 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class RoleDeciderTest {
+    
+    private RoleDecider decider;
+    
+    @BeforeEach
+    void setUp() {
+        decider = new RoleDecider();
+    }
+    
+    @Test
+    void testPrimaryTargetRole() {
+        SearchUnit primaryNode = createSearchUnit("node1", "primary");
+        SearchUnit replicaNode = createSearchUnit("node2", "replica");
+        SearchUnit coordinatorNode = createSearchUnit("coord1", "coordinator");
+        
+        // For PRIMARY target, only PRIMARY nodes allowed
+        assertThat(decider.canAllocate("0", primaryNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("0", replicaNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", coordinatorNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+    }
+    
+    @Test
+    void testReplicaTargetRole() {
+        SearchUnit primaryNode = createSearchUnit("node1", "primary");
+        SearchUnit replicaNode = createSearchUnit("node2", "replica");
+        SearchUnit coordinatorNode = createSearchUnit("coord1", "coordinator");
+        
+        // For REPLICA target, only REPLICA nodes allowed
+        assertThat(decider.canAllocate("0", primaryNode, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", replicaNode, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("0", coordinatorNode, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.NO);
+    }
+    
+    @Test
+    void testCoordinatorAlwaysRejected() {
+        SearchUnit coordinatorNode = createSearchUnit("coord1", "coordinator");
+        
+        assertThat(decider.canAllocate("0", coordinatorNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", coordinatorNode, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.NO);
+    }
+    
+    @Test
+    void testNullRoleHandling() {
+        SearchUnit nullRoleNode = createSearchUnit("node1", null);
+        SearchUnit unknownRoleNode = createSearchUnit("node2", "unknown");
+        
+        assertThat(decider.canAllocate("0", nullRoleNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", unknownRoleNode, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+    }
+    
+    private SearchUnit createSearchUnit(String name, String role) {
+        SearchUnit unit = new SearchUnit();
+        unit.setName(name);
+        unit.setRole(role);
+        unit.setStateAdmin("NORMAL");
+        unit.setStatePulled(HealthState.GREEN);
+        unit.setShardId("0");
+        return unit;
+    }
+}
diff --git a/src/test/java/io/clustercontroller/allocation/deciders/ShardPoolDeciderTest.java b/src/test/java/io/clustercontroller/allocation/deciders/ShardPoolDeciderTest.java
new file mode 100644
index 0000000..0f5bbff
--- /dev/null
+++ b/src/test/java/io/clustercontroller/allocation/deciders/ShardPoolDeciderTest.java
@@ -0,0 +1,60 @@
+package io.clustercontroller.allocation.deciders;
+
+import io.clustercontroller.enums.Decision;
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
+import io.clustercontroller.models.SearchUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class ShardPoolDeciderTest {
+    
+    private ShardPoolDecider decider;
+    
+    @BeforeEach
+    void setUp() {
+        decider = new ShardPoolDecider();
+    }
+    
+    @Test
+    void testMatchingShardPool() {
+        SearchUnit nodeInShard0 = createSearchUnit("node1", "0");
+        SearchUnit nodeInShard1 = createSearchUnit("node2", "1");
+        
+        assertThat(decider.canAllocate("0", nodeInShard0, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.YES);
+        assertThat(decider.canAllocate("1", nodeInShard1, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.YES);
+    }
+    
+    @Test
+    void testMismatchedShardPool() {
+        SearchUnit nodeInShard0 = createSearchUnit("node1", "0");
+        SearchUnit nodeInShard1 = createSearchUnit("node2", "1");
+        
+        assertThat(decider.canAllocate("1", nodeInShard0, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+        assertThat(decider.canAllocate("0", nodeInShard1, "test-index", NodeRole.REPLICA))
+            .isEqualTo(Decision.NO);
+    }
+    
+    @Test
+    void testNullShardId() {
+        SearchUnit nodeWithNullShard = createSearchUnit("node1", null);
+        
+        assertThat(decider.canAllocate("0", nodeWithNullShard, "test-index", NodeRole.PRIMARY))
+            .isEqualTo(Decision.NO);
+    }
+    
+    private SearchUnit createSearchUnit(String name, String shardId) {
+        SearchUnit unit = new SearchUnit();
+        unit.setName(name);
+        unit.setRole("primary");
+        unit.setStateAdmin("NORMAL");
+        unit.setStatePulled(HealthState.GREEN);
+        unit.setShardId(shardId);
+        return unit;
+    }
+}
diff --git a/src/test/java/io/clustercontroller/enums/DecisionTest.java b/src/test/java/io/clustercontroller/enums/DecisionTest.java
new file mode 100644
index 0000000..dc2875c
--- /dev/null
+++ b/src/test/java/io/clustercontroller/enums/DecisionTest.java
@@ -0,0 +1,22 @@
+package io.clustercontroller.enums;
+
+import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+
+class DecisionTest {
+    
+    @Test
+    void testMergeLogic() {
+        // NO overrides everything
+        assertThat(Decision.YES.merge(Decision.NO)).isEqualTo(Decision.NO);
+        assertThat(Decision.NO.merge(Decision.YES)).isEqualTo(Decision.NO);
+        assertThat(Decision.THROTTLE.merge(Decision.NO)).isEqualTo(Decision.NO);
+        
+        // THROTTLE overrides YES
+        assertThat(Decision.YES.merge(Decision.THROTTLE)).isEqualTo(Decision.THROTTLE);
+        assertThat(Decision.THROTTLE.merge(Decision.YES)).isEqualTo(Decision.THROTTLE);
+        
+        // YES with YES stays YES
+        assertThat(Decision.YES.merge(Decision.YES)).isEqualTo(Decision.YES);
+    }
+}
diff --git a/src/test/java/io/clustercontroller/enums/NodeRoleTest.java b/src/test/java/io/clustercontroller/enums/NodeRoleTest.java
new file mode 100644
index 0000000..b8a5b59
--- /dev/null
+++ b/src/test/java/io/clustercontroller/enums/NodeRoleTest.java
@@ -0,0 +1,40 @@
+package io.clustercontroller.enums;
+
+import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for NodeRole enum.
+ */
+class NodeRoleTest {
+    
+    @Test
+    void testFromStringValidValues() {
+        assertThat(NodeRole.fromString("primary")).isEqualTo(NodeRole.PRIMARY);
+        assertThat(NodeRole.fromString("replica")).isEqualTo(NodeRole.REPLICA);
+        assertThat(NodeRole.fromString("coordinator")).isEqualTo(NodeRole.COORDINATOR);
+        
+        // Test case insensitive
+        assertThat(NodeRole.fromString("PRIMARY")).isEqualTo(NodeRole.PRIMARY);
+        assertThat(NodeRole.fromString("REPLICA")).isEqualTo(NodeRole.REPLICA);
+        
+        // Test with whitespace
+        assertThat(NodeRole.fromString(" primary ")).isEqualTo(NodeRole.PRIMARY);
+        assertThat(NodeRole.fromString("\treplica\n")).isEqualTo(NodeRole.REPLICA);
+    }
+    
+    @Test
+    void testFromStringInvalidValues() {
+        assertThat(NodeRole.fromString("invalid")).isNull();
+        assertThat(NodeRole.fromString("")).isNull();
+        assertThat(NodeRole.fromString("   ")).isNull();
+        assertThat(NodeRole.fromString(null)).isNull();
+    }
+    
+    @Test
+    void testGetValue() {
+        assertThat(NodeRole.PRIMARY.getValue()).isEqualTo("primary");
+        assertThat(NodeRole.REPLICA.getValue()).isEqualTo("replica");
+        assertThat(NodeRole.COORDINATOR.getValue()).isEqualTo("coordinator");
+    }
+}
-- 
2.50.1


From 5733e9540089cbba7ed32220e5ec053cd60d8cfe Mon Sep 17 00:00:00 2001
From: tjnaik <tjnaik@uber.com>
Date: Thu, 18 Sep 2025 01:09:09 -0700
Subject: [PATCH 04/12] Remove external references from documentation

---
 .../allocation/deciders/AllocationDecider.java                  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java b/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java
index 8feb2cf..5e73e08 100644
--- a/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java
+++ b/src/main/java/io/clustercontroller/allocation/deciders/AllocationDecider.java
@@ -10,7 +10,7 @@ import io.clustercontroller.models.SearchUnit;
  * Each AllocationDecider implements a specific rule for determining
  * whether a shard can be allocated to a particular node.
  * 
- * Inspired by OpenSearch's AllocationDecider pattern.
+ * Enables modular, configurable allocation policies.
  */
 public interface AllocationDecider {
     
-- 
2.50.1


From 51050b7d05b25d3c3571725dcd064ca8907e0e73 Mon Sep 17 00:00:00 2001
From: tjnaik <tjnaik@uber.com>
Date: Fri, 19 Sep 2025 16:05:33 -0700
Subject: [PATCH 05/12] Create API Framework and components for user facing
 interactions. Compatible with OS APIs

---
 pom.xml                                       |  21 +++
 .../ClusterControllerApplication.java         | 165 ++++++++++++------
 .../api/handlers/HealthHandler.java           |  79 +++++++++
 .../api/handlers/IndexHandler.java            |  86 +++++++++
 .../api/models/requests/AliasRequest.java     |  29 +++
 .../api/models/requests/IndexRequest.java     |  41 +++++
 .../api/models/responses/ErrorResponse.java   |  51 ++++++
 .../api/models/responses/HealthResponse.java  |  34 ++++
 .../api/models/responses/IndexResponse.java   |  43 +++++
 .../clustercontroller/config/Constants.java   |   2 +-
 .../health/ClusterHealthManager.java          |  48 +++++
 .../indices/AliasManager.java                 |  41 +++++
 .../indices/IndexManager.java                 |  54 ++++++
 .../tasks/impl/PlanShardAllocationTask.java   |   2 +-
 .../templates/TemplateManager.java            |  47 +++++
 .../api/handlers/HealthHandlerTest.java       | 128 ++++++++++++++
 .../api/handlers/IndexHandlerTest.java        | 161 +++++++++++++++++
 .../api/models/requests/IndexRequestTest.java | 105 +++++++++++
 .../models/responses/ErrorResponseTest.java   | 110 ++++++++++++
 .../models/responses/IndexResponseTest.java   | 110 ++++++++++++
 .../config/ConstantsTest.java                 |   2 +-
 .../health/ClusterHealthManagerTest.java      |  80 +++++++++
 .../indices/AliasManagerTest.java             |  83 +++++++++
 .../impl/PlanShardAllocationTaskTest.java     |  89 ++++++----
 24 files changed, 1517 insertions(+), 94 deletions(-)
 create mode 100644 src/main/java/io/clustercontroller/api/handlers/HealthHandler.java
 create mode 100644 src/main/java/io/clustercontroller/api/handlers/IndexHandler.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/requests/AliasRequest.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/requests/IndexRequest.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/responses/ErrorResponse.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/responses/HealthResponse.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java
 create mode 100644 src/main/java/io/clustercontroller/health/ClusterHealthManager.java
 create mode 100644 src/main/java/io/clustercontroller/indices/AliasManager.java
 create mode 100644 src/main/java/io/clustercontroller/templates/TemplateManager.java
 create mode 100644 src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java
 create mode 100644 src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
 create mode 100644 src/test/java/io/clustercontroller/api/models/requests/IndexRequestTest.java
 create mode 100644 src/test/java/io/clustercontroller/api/models/responses/ErrorResponseTest.java
 create mode 100644 src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java
 create mode 100644 src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java
 create mode 100644 src/test/java/io/clustercontroller/indices/AliasManagerTest.java

diff --git a/pom.xml b/pom.xml
index 3e9ac5a..b9b317e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,6 +20,13 @@
     </properties>
     
     <dependencies>
+        <!-- Spring Boot Web Starter -->
+        <dependency>
+            <groupId>org.springframework.boot</groupId>
+            <artifactId>spring-boot-starter-web</artifactId>
+            <version>3.1.5</version>
+        </dependency>
+        
         <!-- JSON Processing -->
         <dependency>
             <groupId>com.fasterxml.jackson.core</groupId>
@@ -96,6 +103,20 @@
     <build>
         <plugins>
             
+            <plugin>
+                <groupId>org.springframework.boot</groupId>
+                <artifactId>spring-boot-maven-plugin</artifactId>
+                <version>3.1.5</version>
+                <configuration>
+                    <excludes>
+                        <exclude>
+                            <groupId>org.projectlombok</groupId>
+                            <artifactId>lombok</artifactId>
+                        </exclude>
+                    </excludes>
+                </configuration>
+            </plugin>
+            
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
diff --git a/src/main/java/io/clustercontroller/ClusterControllerApplication.java b/src/main/java/io/clustercontroller/ClusterControllerApplication.java
index e5abcc1..a41d219 100644
--- a/src/main/java/io/clustercontroller/ClusterControllerApplication.java
+++ b/src/main/java/io/clustercontroller/ClusterControllerApplication.java
@@ -4,87 +4,140 @@ import io.clustercontroller.allocation.ActualAllocationUpdater;
 import io.clustercontroller.allocation.ShardAllocator;
 import io.clustercontroller.config.ClusterControllerConfig;
 import io.clustercontroller.discovery.Discovery;
-import io.clustercontroller.election.LeaderElection;
+import io.clustercontroller.health.ClusterHealthManager;
+import io.clustercontroller.indices.AliasManager;
 import io.clustercontroller.indices.IndexManager;
+import io.clustercontroller.templates.TemplateManager;
 import io.clustercontroller.store.MetadataStore;
 import io.clustercontroller.store.EtcdMetadataStore;
 import io.clustercontroller.tasks.TaskContext;
 
 import lombok.extern.slf4j.Slf4j;
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.ComponentScan;
+import org.springframework.context.annotation.Primary;
 
 import static io.clustercontroller.config.Constants.*;
 
 /**
- * Main application class for the Cluster Controller.
+ * Main Spring Boot application class for the Cluster Controller.
  * 
  * This application provides production-ready controller functionality for managing
  * distributed clusters at scale, including shard allocation, cluster coordination,
- * and automated operations backed by pluggable metadata stores.
- * 
- * Required Environment Variables:
- * - NODE_NAME: Unique identifier for this controller instance (required for leader election)
+ * automated operations, and REST APIs backed by pluggable metadata stores.
  */
 @Slf4j
+@SpringBootApplication
+@ComponentScan(basePackages = "io.clustercontroller")
 public class ClusterControllerApplication {
 
     public static void main(String[] args) {
-        log.info("Starting Cluster Controller Application");
+        log.info("Starting Cluster Controller Application with REST APIs");
         
         try {
-            // Create configuration
-            // TODO: Pull configuration from environment variables or injected config file
-            ClusterControllerConfig config = new ClusterControllerConfig(
-                DEFAULT_CLUSTER_NAME, 
-                new String[]{DEFAULT_ETCD_ENDPOINT}, 
-                DEFAULT_TASK_INTERVAL_SECONDS
-            );
-            log.info("Loaded configuration for cluster: {}", config.getClusterName());
+            SpringApplication.run(ClusterControllerApplication.class, args);
+            log.info("Cluster Controller with REST APIs started successfully");
             
-            // Initialize metadata store (singleton)
-            MetadataStore metadataStore = EtcdMetadataStore.getInstance(
+        } catch (Exception e) {
+            log.error("Failed to start Cluster Controller: {}", e.getMessage(), e);
+            System.exit(1);
+        }
+    }
+    
+    @Bean
+    @Primary
+    public ClusterControllerConfig config() {
+        ClusterControllerConfig config = new ClusterControllerConfig(
+            DEFAULT_CLUSTER_NAME, 
+            new String[]{DEFAULT_ETCD_ENDPOINT}, 
+            DEFAULT_TASK_INTERVAL_SECONDS
+        );
+        log.info("Loaded configuration for cluster: {}", config.getClusterName());
+        return config;
+    }
+    
+    @Bean
+    public MetadataStore metadataStore(ClusterControllerConfig config) {
+        log.info("Initializing MetadataStore connection to etcd");
+        try {
+            MetadataStore store = EtcdMetadataStore.getInstance(
                 config.getClusterName(), 
                 config.getEtcdEndpoints()
             );
-            metadataStore.initialize();
-            
-            // Wait until this node becomes leader
-            EtcdMetadataStore etcdStore = (EtcdMetadataStore) metadataStore;
-            LeaderElection leaderElection = new LeaderElection(etcdStore);
-            leaderElection.waitUntilLeader();  // blocks until leader
-            
-            // Initialize components
-            IndexManager indexManager = new IndexManager(metadataStore);
-            Discovery discovery = new Discovery(metadataStore);
-            ShardAllocator shardAllocator = new ShardAllocator(metadataStore);
-            ActualAllocationUpdater actualAllocationUpdater = new ActualAllocationUpdater(metadataStore);
-            
-            // Create task context for component access
-            TaskContext taskContext = new TaskContext(indexManager, discovery, shardAllocator, actualAllocationUpdater);
-            
-            // Initialize generic task manager
-            TaskManager taskManager = new TaskManager(
-                metadataStore,
-                taskContext,
-                config.getTaskIntervalSeconds()
-            );
-            
-            // Add shutdown hook for graceful cleanup
-            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
-                log.info("Shutting down Cluster Controller");
-                taskManager.stop();
-            }));
-            
-            // Start the controller
-            taskManager.start();
-            log.info("Cluster Controller started successfully");
-            
-            // Keep the application running
-            Thread.currentThread().join();
-            
+            store.initialize();
+            log.info("MetadataStore initialized successfully");
+            return store;
         } catch (Exception e) {
-            log.error("Failed to start Cluster Controller: {}", e.getMessage(), e);
-            System.exit(1);
+            log.error("Failed to initialize MetadataStore: {}", e.getMessage(), e);
+            throw new RuntimeException("MetadataStore initialization failed", e);
         }
     }
     
-}
+    @Bean
+    public IndexManager indexManager(MetadataStore metadataStore) {
+        log.info("Initializing IndexManager");
+        return new IndexManager(metadataStore);
+    }
+    
+    @Bean
+    public Discovery discovery(MetadataStore metadataStore) {
+        log.info("Initializing Discovery");
+        return new Discovery(metadataStore);
+    }
+    
+    @Bean
+    public ClusterHealthManager clusterHealthManager(Discovery discovery, MetadataStore metadataStore) {
+        log.info("Initializing ClusterHealthManager");
+        return new ClusterHealthManager(discovery, metadataStore);
+    }
+    
+    @Bean
+    public AliasManager aliasManager(MetadataStore metadataStore) {
+        log.info("Initializing AliasManager");
+        return new AliasManager(metadataStore);
+    }
+    
+    @Bean
+    public TemplateManager templateManager(MetadataStore metadataStore) {
+        log.info("Initializing TemplateManager");
+        return new TemplateManager(metadataStore);
+    }
+    
+    @Bean
+    public ShardAllocator shardAllocator(MetadataStore metadataStore) {
+        log.info("Initializing ShardAllocator");
+        return new ShardAllocator(metadataStore);
+    }
+    
+    @Bean
+    public ActualAllocationUpdater actualAllocationUpdater(MetadataStore metadataStore) {
+        log.info("Initializing ActualAllocationUpdater");
+        return new ActualAllocationUpdater(metadataStore);
+    }
+    
+    @Bean
+    public TaskManager taskManager(MetadataStore metadataStore, 
+                                   IndexManager indexManager,
+                                   Discovery discovery,
+                                   ShardAllocator shardAllocator,
+                                   ActualAllocationUpdater actualAllocationUpdater,
+                                   ClusterControllerConfig config) {
+        
+        log.info("Initializing TaskManager with background processing");
+        
+        TaskContext taskContext = new TaskContext(indexManager, discovery, shardAllocator, actualAllocationUpdater);
+        
+        TaskManager taskManager = new TaskManager(
+            metadataStore,
+            taskContext,
+            config.getTaskIntervalSeconds()
+        );
+        
+        taskManager.start();
+        log.info("TaskManager started with background processing");
+        
+        return taskManager;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java b/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java
new file mode 100644
index 0000000..fbf1aff
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java
@@ -0,0 +1,79 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.health.ClusterHealthManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.*;
+
+/**
+ * REST API handler for cluster health and statistics operations.
+ * 
+ * Provides endpoints for monitoring cluster health, node status, and
+ * performance statistics. Health information can be retrieved at different
+ * levels of granularity (cluster, indices, or shards).
+ * 
+ * Supported operations:
+ * - GET /_cluster/health - Overall cluster health status
+ * - GET /_cluster/health/{index} - Health status for specific index
+ * - GET /_cluster/stats - Cluster performance statistics
+ * 
+ * Health status values: GREEN (healthy), YELLOW (degraded), RED (critical)
+ */
+@Slf4j
+@RestController
+@RequestMapping("/_cluster")
+public class HealthHandler {
+    
+    private final ClusterHealthManager healthManager;
+    private final ObjectMapper objectMapper;
+    
+    public HealthHandler(ClusterHealthManager healthManager, ObjectMapper objectMapper) {
+        this.healthManager = healthManager;
+        this.objectMapper = objectMapper;
+    }
+    
+    @GetMapping("/health")
+    public ResponseEntity<Object> getClusterHealth(
+            @RequestParam(value = "level", defaultValue = "cluster") String level) {
+        try {
+            log.info("Getting cluster health with level: {}", level);
+            String healthJson = healthManager.getClusterHealth(level);
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster health"));
+        } catch (UnsupportedOperationException e) {
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster health"));
+        } catch (Exception e) {
+            log.error("Error getting cluster health: {}", e.getMessage());
+            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+    
+    @GetMapping("/health/{index}")
+    public ResponseEntity<Object> getIndexHealth(@PathVariable String index) {
+        try {
+            log.info("Getting health for index: {}", index);
+            String healthJson = healthManager.getIndexHealth(index, "indices");
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index health"));
+        } catch (UnsupportedOperationException e) {
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index health"));
+        } catch (Exception e) {
+            log.error("Error getting health for index {}: {}", index, e.getMessage());
+            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+    
+    @GetMapping("/stats")
+    public ResponseEntity<Object> getClusterStats() {
+        try {
+            log.info("Getting cluster statistics");
+            String statsJson = healthManager.getClusterStats();
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster stats"));
+        } catch (UnsupportedOperationException e) {
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster stats"));
+        } catch (Exception e) {
+            log.error("Error getting cluster stats: {}", e.getMessage());
+            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+}
diff --git a/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java b/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java
new file mode 100644
index 0000000..3c5a2e9
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java
@@ -0,0 +1,86 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.requests.IndexRequest;
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.api.models.responses.IndexResponse;
+import io.clustercontroller.indices.IndexManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.*;
+
+/**
+ * REST API handler for index lifecycle operations.
+ * 
+ * Provides endpoints for creating, reading, updating, and deleting indices,
+ * as well as managing index settings and mappings. All endpoints follow
+ * standard REST conventions and return JSON responses.
+ * 
+ * Supported operations:
+ * - PUT /{index} - Create a new index
+ * - GET /{index} - Retrieve index information
+ * - DELETE /{index} - Delete an index
+ * - GET /{index}/_settings - Get index settings
+ * - PUT /{index}/_settings - Update index settings
+ * - GET /{index}/_mapping - Get index mappings
+ * - PUT /{index}/_mapping - Update index mappings
+ */
+@Slf4j
+@RestController
+@RequestMapping("/")
+public class IndexHandler {
+    
+    private final IndexManager indexManager;
+    private final ObjectMapper objectMapper;
+    
+    public IndexHandler(IndexManager indexManager, ObjectMapper objectMapper) {
+        this.indexManager = indexManager;
+        this.objectMapper = objectMapper;
+    }
+    
+    @PutMapping("/{index}")
+    public ResponseEntity<Object> createIndex(
+            @PathVariable String index,
+            @RequestBody(required = false) IndexRequest request) {
+        try {
+            log.info("Creating index: {}", index);
+            if (request == null) {
+                request = IndexRequest.builder().build();
+            }
+            String jsonConfig = objectMapper.writeValueAsString(request);
+            indexManager.createIndex(jsonConfig);
+            return ResponseEntity.status(201).body(IndexResponse.createSuccess(index));
+        } catch (UnsupportedOperationException e) {
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index creation"));
+        } catch (Exception e) {
+            log.error("Error creating index {}: {}", index, e.getMessage());
+            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+    
+    @GetMapping("/{index}")
+    public ResponseEntity<Object> getIndex(@PathVariable String index) {
+        try {
+            log.info("Getting index: {}", index);
+            String indexInfo = indexManager.getIndex(index);
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Get index"));
+        } catch (Exception e) {
+            log.error("Error getting index {}: {}", index, e.getMessage());
+            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+    
+    @DeleteMapping("/{index}")
+    public ResponseEntity<Object> deleteIndex(@PathVariable String index) {
+        try {
+            log.info("Deleting index: {}", index);
+            indexManager.deleteIndex(index);
+            return ResponseEntity.ok(IndexResponse.deleteSuccess(index));
+        } catch (UnsupportedOperationException e) {
+            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index deletion"));
+        } catch (Exception e) {
+            log.error("Error deleting index {}: {}", index, e.getMessage());
+            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/models/requests/AliasRequest.java b/src/main/java/io/clustercontroller/api/models/requests/AliasRequest.java
new file mode 100644
index 0000000..e15a14a
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/requests/AliasRequest.java
@@ -0,0 +1,29 @@
+package io.clustercontroller.api.models.requests;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.Map;
+
+/**
+ * Request model for all alias operations.
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonIgnoreProperties(ignoreUnknown = true)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class AliasRequest {
+    private Map<String, Object> filter;
+    private String routing;
+    private String indexRouting;
+    private String searchRouting;
+}
diff --git a/src/main/java/io/clustercontroller/api/models/requests/IndexRequest.java b/src/main/java/io/clustercontroller/api/models/requests/IndexRequest.java
new file mode 100644
index 0000000..9723e67
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/requests/IndexRequest.java
@@ -0,0 +1,41 @@
+package io.clustercontroller.api.models.requests;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.Map;
+
+/**
+ * Request model for index creation and configuration operations.
+ * 
+ * Supports index creation with custom settings, field mappings, and aliases.
+ * Uses Jackson annotations for automatic JSON serialization/deserialization
+ * with snake_case property naming for compatibility.
+ * 
+ * Example usage:
+ * <pre>
+ * {
+ *   "settings": {"number_of_replicas": 1, "refresh_interval": "30s"},
+ *   "mappings": {"properties": {"title": {"type": "text"}}},
+ *   "aliases": {"my_alias": {}}
+ * }
+ * </pre>
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonIgnoreProperties(ignoreUnknown = true)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class IndexRequest {
+    private Map<String, Object> settings;
+    private Map<String, Object> mappings;
+    private Map<String, Object> aliases;
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/models/responses/ErrorResponse.java b/src/main/java/io/clustercontroller/api/models/responses/ErrorResponse.java
new file mode 100644
index 0000000..a9f23fe
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/responses/ErrorResponse.java
@@ -0,0 +1,51 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * Standard error response model for all API operations.
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonIgnoreProperties(ignoreUnknown = true)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class ErrorResponse {
+    private String error;
+    private String type;
+    private String reason;
+    private Integer status;
+    
+    public static ErrorResponse notFound(String resource) {
+        return ErrorResponse.builder()
+            .error("resource_not_found_exception")
+            .reason(resource + " not found")
+            .status(404)
+            .build();
+    }
+    
+    public static ErrorResponse notImplemented(String operation) {
+        return ErrorResponse.builder()
+            .error("not_implemented")
+            .reason(operation + " is not yet implemented")
+            .status(501)
+            .build();
+    }
+    
+    public static ErrorResponse internalError(String message) {
+        return ErrorResponse.builder()
+            .error("internal_server_error")
+            .reason(message)
+            .status(500)
+            .build();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/models/responses/HealthResponse.java b/src/main/java/io/clustercontroller/api/models/responses/HealthResponse.java
new file mode 100644
index 0000000..0c21ccb
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/responses/HealthResponse.java
@@ -0,0 +1,34 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.Map;
+
+/**
+ * Response model for cluster health operations.
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class HealthResponse {
+    private String clusterName;
+    private String status;
+    private Boolean timedOut;
+    private Integer numberOfNodes;
+    private Integer numberOfDataNodes;
+    private Integer activePrimaryShards;
+    private Integer activeShards;
+    private Integer relocatingShards;
+    private Integer initializingShards;
+    private Integer unassignedShards;
+    private Map<String, Object> indices;
+}
diff --git a/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java b/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java
new file mode 100644
index 0000000..b742ad3
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java
@@ -0,0 +1,43 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.Map;
+
+/**
+ * Response model for all index operations.
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class IndexResponse {
+    private Boolean acknowledged;
+    private Boolean shardsAcknowledged;
+    private String index;
+    private Map<String, Object> settings;
+    private Map<String, Object> mappings;
+    
+    public static IndexResponse createSuccess(String indexName) {
+        return IndexResponse.builder()
+            .acknowledged(true)
+            .shardsAcknowledged(true)
+            .index(indexName)
+            .build();
+    }
+    
+    public static IndexResponse deleteSuccess(String indexName) {
+        return IndexResponse.builder()
+            .acknowledged(true)
+            .index(indexName)
+            .build();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/config/Constants.java b/src/main/java/io/clustercontroller/config/Constants.java
index 11113a9..74e0354 100644
--- a/src/main/java/io/clustercontroller/config/Constants.java
+++ b/src/main/java/io/clustercontroller/config/Constants.java
@@ -11,7 +11,7 @@ public final class Constants {
     
     // Default configuration values
     public static final String DEFAULT_CLUSTER_NAME = "default-cluster";
-    public static final String DEFAULT_ETCD_ENDPOINT = "localhost:2379";
+    public static final String DEFAULT_ETCD_ENDPOINT = "http://localhost:2379";
     public static final long DEFAULT_TASK_INTERVAL_SECONDS = 30L;
     
     // Task statuses
diff --git a/src/main/java/io/clustercontroller/health/ClusterHealthManager.java b/src/main/java/io/clustercontroller/health/ClusterHealthManager.java
new file mode 100644
index 0000000..173057a
--- /dev/null
+++ b/src/main/java/io/clustercontroller/health/ClusterHealthManager.java
@@ -0,0 +1,48 @@
+package io.clustercontroller.health;
+
+import io.clustercontroller.discovery.Discovery;
+import io.clustercontroller.store.MetadataStore;
+import lombok.extern.slf4j.Slf4j;
+
+/**
+ * Manages cluster health monitoring and statistics collection.
+ * 
+ * Provides comprehensive health assessment of the cluster by aggregating
+ * information from individual nodes, indices, and shards. Calculates overall
+ * cluster status and detailed health metrics for monitoring and alerting.
+ * 
+ * Health calculation considers:
+ * - Node availability and resource utilization
+ * - Shard allocation status (active, relocating, unassigned)
+ * - Index-level health and performance metrics
+ * - Cluster-wide statistics and capacity planning data
+ */
+@Slf4j
+public class ClusterHealthManager {
+    
+    private final Discovery discovery;
+    private final MetadataStore metadataStore;
+    
+    public ClusterHealthManager(Discovery discovery, MetadataStore metadataStore) {
+        this.discovery = discovery;
+        this.metadataStore = metadataStore;
+    }
+    
+    public String getClusterHealth(String level) {
+        log.info("Getting cluster health with level: {}", level);
+        // TODO: Implement cluster health calculation
+        throw new UnsupportedOperationException("Cluster health not yet implemented");
+    }
+    
+    public String getIndexHealth(String indexName, String level) {
+        log.info("Getting health for index '{}' with level: {}", indexName, level);
+        // TODO: Implement index-specific health calculation
+        throw new UnsupportedOperationException("Index health not yet implemented");
+    }
+    
+    public String getClusterStats() {
+        log.info("Getting cluster statistics");
+        // TODO: Implement cluster statistics aggregation
+        throw new UnsupportedOperationException("Cluster stats not yet implemented");
+    }
+}
diff --git a/src/main/java/io/clustercontroller/indices/AliasManager.java b/src/main/java/io/clustercontroller/indices/AliasManager.java
new file mode 100644
index 0000000..6ceb33d
--- /dev/null
+++ b/src/main/java/io/clustercontroller/indices/AliasManager.java
@@ -0,0 +1,41 @@
+package io.clustercontroller.indices;
+
+import io.clustercontroller.store.MetadataStore;
+import lombok.extern.slf4j.Slf4j;
+
+/**
+ * Manages alias operations.
+ */
+@Slf4j
+public class AliasManager {
+    
+    private final MetadataStore metadataStore;
+    
+    public AliasManager(MetadataStore metadataStore) {
+        this.metadataStore = metadataStore;
+    }
+    
+    public void createAlias(String indexName, String aliasName, String aliasConfig) {
+        log.info("Creating alias '{}' for index '{}' with config: {}", aliasName, indexName, aliasConfig);
+        // TODO: Implement alias creation logic
+        throw new UnsupportedOperationException("Alias creation not yet implemented");
+    }
+    
+    public void deleteAlias(String indexName, String aliasName) {
+        log.info("Deleting alias '{}' from index '{}'", aliasName, indexName);
+        // TODO: Implement alias deletion logic
+        throw new UnsupportedOperationException("Alias deletion not yet implemented");
+    }
+    
+    public String getAlias(String aliasName) {
+        log.info("Getting alias information for '{}'", aliasName);
+        // TODO: Implement get alias logic
+        throw new UnsupportedOperationException("Get alias not yet implemented");
+    }
+    
+    public boolean aliasExists(String aliasName) {
+        log.info("Checking if alias '{}' exists", aliasName);
+        // TODO: Implement alias existence check
+        return false;
+    }
+}
diff --git a/src/main/java/io/clustercontroller/indices/IndexManager.java b/src/main/java/io/clustercontroller/indices/IndexManager.java
index 17cf710..018cac0 100644
--- a/src/main/java/io/clustercontroller/indices/IndexManager.java
+++ b/src/main/java/io/clustercontroller/indices/IndexManager.java
@@ -26,6 +26,60 @@ public class IndexManager {
         // TODO: Implement index deletion logic
     }
     
+    /**
+     * Get index information.
+     */
+    public String getIndex(String indexName) {
+        log.info("Getting index information for: {}", indexName);
+        // TODO: Implement get index logic
+        throw new UnsupportedOperationException("Get index not yet implemented");
+    }
+    
+    /**
+     * Check if index exists.
+     */
+    public boolean indexExists(String indexName) {
+        log.info("Checking if index exists: {}", indexName);
+        // TODO: Implement index existence check
+        return false;
+    }
+    
+    /**
+     * Get index settings.
+     */
+    public String getSettings(String indexName) {
+        log.info("Getting settings for index: {}", indexName);
+        // TODO: Implement get settings logic
+        throw new UnsupportedOperationException("Get settings not yet implemented");
+    }
+    
+    /**
+     * Update index settings.
+     */
+    public void updateSettings(String indexName, String settingsJson) {
+        log.info("Updating settings for index '{}' with: {}", indexName, settingsJson);
+        // TODO: Implement update settings logic
+        throw new UnsupportedOperationException("Update settings not yet implemented");
+    }
+    
+    /**
+     * Get index mappings.
+     */
+    public String getMapping(String indexName) {
+        log.info("Getting mapping for index: {}", indexName);
+        // TODO: Implement get mapping logic
+        throw new UnsupportedOperationException("Get mapping not yet implemented");
+    }
+    
+    /**
+     * Update index mappings.
+     */
+    public void updateMapping(String indexName, String mappingsJson) {
+        log.info("Updating mapping for index '{}' with: {}", indexName, mappingsJson);
+        // TODO: Implement update mapping logic
+        throw new UnsupportedOperationException("Update mapping not yet implemented");
+    }
+    
     public void planShardAllocation() {
         log.info("Planning shard allocation");
         // TODO: Implement shard allocation planning logic
diff --git a/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java b/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java
index 03b43e8..28f91f6 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java
@@ -26,7 +26,7 @@ public class PlanShardAllocationTask implements Task {
         log.info("Executing plan shard allocation task: {}", name);
         
         try {
-            context.getIndexManager().planShardAllocation();
+            // TODO: Call ShardAllocationPlanner.plan() method when implemented
             return TASK_STATUS_COMPLETED;
         } catch (Exception e) {
             log.error("Failed to execute plan shard allocation task: {}", e.getMessage(), e);
diff --git a/src/main/java/io/clustercontroller/templates/TemplateManager.java b/src/main/java/io/clustercontroller/templates/TemplateManager.java
new file mode 100644
index 0000000..1580dbf
--- /dev/null
+++ b/src/main/java/io/clustercontroller/templates/TemplateManager.java
@@ -0,0 +1,47 @@
+package io.clustercontroller.templates;
+
+import io.clustercontroller.store.MetadataStore;
+import lombok.extern.slf4j.Slf4j;
+
+/**
+ * Manages index template operations.
+ */
+@Slf4j
+public class TemplateManager {
+    
+    private final MetadataStore metadataStore;
+    
+    public TemplateManager(MetadataStore metadataStore) {
+        this.metadataStore = metadataStore;
+    }
+    
+    public void putTemplate(String templateName, String templateConfig) {
+        log.info("Creating/updating template '{}' with config: {}", templateName, templateConfig);
+        // TODO: Implement template creation/update logic
+        throw new UnsupportedOperationException("Template creation not yet implemented");
+    }
+    
+    public void deleteTemplate(String templateName) {
+        log.info("Deleting template '{}'", templateName);
+        // TODO: Implement template deletion logic
+        throw new UnsupportedOperationException("Template deletion not yet implemented");
+    }
+    
+    public String getTemplate(String templateName) {
+        log.info("Getting template '{}'", templateName);
+        // TODO: Implement get template logic
+        throw new UnsupportedOperationException("Get template not yet implemented");
+    }
+    
+    public String getAllTemplates() {
+        log.info("Getting all templates");
+        // TODO: Implement get all templates logic
+        throw new UnsupportedOperationException("Get all templates not yet implemented");
+    }
+    
+    public boolean templateExists(String templateName) {
+        log.info("Checking if template '{}' exists", templateName);
+        // TODO: Implement template existence check
+        return false;
+    }
+}
diff --git a/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java
new file mode 100644
index 0000000..d022ca6
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java
@@ -0,0 +1,128 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.health.ClusterHealthManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.*;
+
+@ExtendWith(MockitoExtension.class)
+class HealthHandlerTest {
+
+    @Mock
+    private ClusterHealthManager healthManager;
+    
+    @Mock
+    private ObjectMapper objectMapper;
+    
+    private HealthHandler healthHandler;
+    
+    @BeforeEach
+    void setUp() {
+        healthHandler = new HealthHandler(healthManager, objectMapper);
+    }
+    
+    @Test
+    void testGetClusterHealth_NotImplemented() {
+        // Given
+        when(healthManager.getClusterHealth("cluster"))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+        
+        // When
+        ResponseEntity<Object> response = healthHandler.getClusterHealth("cluster");
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+        
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("not yet implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+        
+        verify(healthManager).getClusterHealth("cluster");
+    }
+    
+    @Test
+    void testGetClusterHealth_WithCustomLevel() {
+        // Given
+        when(healthManager.getClusterHealth("indices"))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+        
+        // When
+        ResponseEntity<Object> response = healthHandler.getClusterHealth("indices");
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        verify(healthManager).getClusterHealth("indices");
+    }
+    
+    @Test
+    void testGetIndexHealth_NotImplemented() {
+        // Given
+        String indexName = "test-index";
+        
+        when(healthManager.getIndexHealth(indexName, "indices"))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+        
+        // When
+        ResponseEntity<Object> response = healthHandler.getIndexHealth(indexName);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+        
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("not yet implemented");
+        
+        verify(healthManager).getIndexHealth(indexName, "indices");
+    }
+    
+    @Test
+    void testGetClusterStats_NotImplemented() {
+        // Given
+        when(healthManager.getClusterStats())
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+        
+        // When
+        ResponseEntity<Object> response = healthHandler.getClusterStats();
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+        
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("not yet implemented");
+        
+        verify(healthManager).getClusterStats();
+    }
+    
+    @Test
+    void testGetClusterHealth_InternalError() {
+        // Given
+        when(healthManager.getClusterHealth(anyString()))
+            .thenThrow(new RuntimeException("Database connection failed"));
+        
+        // When
+        ResponseEntity<Object> response = healthHandler.getClusterHealth("cluster");
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+        
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
+        assertThat(errorResponse.getReason()).contains("Database connection failed");
+    }
+}
diff --git a/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
new file mode 100644
index 0000000..e5a8945
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
@@ -0,0 +1,161 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.requests.IndexRequest;
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.api.models.responses.IndexResponse;
+import io.clustercontroller.indices.IndexManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+
+import java.util.Map;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.*;
+
+@ExtendWith(MockitoExtension.class)
+class IndexHandlerTest {
+
+    @Mock
+    private IndexManager indexManager;
+    
+    @Mock
+    private ObjectMapper objectMapper;
+    
+    private IndexHandler indexHandler;
+    
+    @BeforeEach
+    void setUp() {
+        indexHandler = new IndexHandler(indexManager, objectMapper);
+    }
+    
+    @Test
+    void testCreateIndex_Success() throws Exception {
+        // Given
+        String indexName = "test-index";
+        IndexRequest request = IndexRequest.builder()
+            .settings(Map.of("replicas", 1))
+            .build();
+        
+        when(objectMapper.writeValueAsString(any())).thenReturn("{\"settings\":{\"replicas\":1}}");
+        doNothing().when(indexManager).createIndex(anyString());
+        
+        // When
+        ResponseEntity<Object> response = indexHandler.createIndex(indexName, request);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
+        assertThat(response.getBody()).isInstanceOf(IndexResponse.class);
+        
+        IndexResponse indexResponse = (IndexResponse) response.getBody();
+        assertThat(indexResponse.getAcknowledged()).isTrue();
+        assertThat(indexResponse.getShardsAcknowledged()).isTrue();
+        assertThat(indexResponse.getIndex()).isEqualTo(indexName);
+        
+        verify(indexManager).createIndex("{\"settings\":{\"replicas\":1}}");
+    }
+    
+    @Test
+    void testCreateIndex_WithNullRequest() throws Exception {
+        // Given
+        String indexName = "test-index";
+        
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doNothing().when(indexManager).createIndex(anyString());
+        
+        // When
+        ResponseEntity<Object> response = indexHandler.createIndex(indexName, null);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
+        verify(indexManager).createIndex("{}");
+    }
+    
+    @Test
+    void testCreateIndex_UnsupportedOperation() throws Exception {
+        // Given
+        String indexName = "test-index";
+        IndexRequest request = IndexRequest.builder().build();
+        
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doThrow(new UnsupportedOperationException("Not implemented"))
+            .when(indexManager).createIndex(anyString());
+        
+        // When
+        ResponseEntity<Object> response = indexHandler.createIndex(indexName, request);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+        
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+    
+    @Test
+    void testCreateIndex_InternalError() throws Exception {
+        // Given
+        String indexName = "test-index";
+        IndexRequest request = IndexRequest.builder().build();
+        
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doThrow(new RuntimeException("Database error"))
+            .when(indexManager).createIndex(anyString());
+        
+        // When
+        ResponseEntity<Object> response = indexHandler.createIndex(indexName, request);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+        
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
+        assertThat(errorResponse.getStatus()).isEqualTo(500);
+    }
+    
+    @Test
+    void testGetIndex_NotImplemented() {
+        // Given
+        String indexName = "test-index";
+        
+        when(indexManager.getIndex(indexName))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+        
+        // When
+        ResponseEntity<Object> response = indexHandler.getIndex(indexName);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+    }
+    
+    @Test
+    void testDeleteIndex_Success() {
+        // Given
+        String indexName = "test-index";
+        
+        doNothing().when(indexManager).deleteIndex(indexName);
+        
+        // When
+        ResponseEntity<Object> response = indexHandler.deleteIndex(indexName);
+        
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(IndexResponse.class);
+        
+        IndexResponse indexResponse = (IndexResponse) response.getBody();
+        assertThat(indexResponse.getAcknowledged()).isTrue();
+        assertThat(indexResponse.getIndex()).isEqualTo(indexName);
+        
+        verify(indexManager).deleteIndex(indexName);
+    }
+}
diff --git a/src/test/java/io/clustercontroller/api/models/requests/IndexRequestTest.java b/src/test/java/io/clustercontroller/api/models/requests/IndexRequestTest.java
new file mode 100644
index 0000000..20dfa02
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/models/requests/IndexRequestTest.java
@@ -0,0 +1,105 @@
+package io.clustercontroller.api.models.requests;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.Map;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class IndexRequestTest {
+
+    private ObjectMapper objectMapper;
+    
+    @BeforeEach
+    void setUp() {
+        objectMapper = new ObjectMapper();
+    }
+    
+    @Test
+    void testSerialization_WithAllFields() throws Exception {
+        // Given
+        IndexRequest request = IndexRequest.builder()
+            .settings(Map.of("number_of_replicas", 1, "refresh_interval", "30s"))
+            .mappings(Map.of("properties", Map.of("title", Map.of("type", "text"))))
+            .aliases(Map.of("my_alias", Map.of()))
+            .build();
+        
+        // When
+        String json = objectMapper.writeValueAsString(request);
+        
+        // Then
+        assertThat(json).contains("\"settings\"");
+        assertThat(json).contains("\"mappings\"");
+        assertThat(json).contains("\"aliases\"");
+        assertThat(json).contains("\"number_of_replicas\"");
+        assertThat(json).contains("\"refresh_interval\"");
+    }
+    
+    @Test
+    void testSerialization_WithEmptyFields() throws Exception {
+        // Given
+        IndexRequest request = IndexRequest.builder()
+            .settings(Map.of("replicas", 1))
+            .build();
+        
+        // When
+        String json = objectMapper.writeValueAsString(request);
+        
+        // Then
+        assertThat(json).contains("\"settings\"");
+        assertThat(json).doesNotContain("\"mappings\""); // Empty maps excluded by @JsonInclude(NON_EMPTY)
+        assertThat(json).doesNotContain("\"aliases\"");
+    }
+    
+    @Test
+    void testDeserialization_FromJson() throws Exception {
+        // Given
+        String json = """
+            {
+                "settings": {"number_of_replicas": 2},
+                "mappings": {"properties": {"field1": {"type": "keyword"}}},
+                "unknown_field": "should_be_ignored"
+            }
+            """;
+        
+        // When
+        IndexRequest request = objectMapper.readValue(json, IndexRequest.class);
+        
+        // Then
+        assertThat(request.getSettings()).containsEntry("number_of_replicas", 2);
+        assertThat(request.getMappings()).containsKey("properties");
+        assertThat(request.getAliases()).isNull(); // Not provided in JSON
+        // unknown_field is ignored due to @JsonIgnoreProperties(ignoreUnknown = true)
+    }
+    
+    @Test
+    void testBuilder_DefaultValues() {
+        // When
+        IndexRequest request = IndexRequest.builder().build();
+        
+        // Then
+        assertThat(request.getSettings()).isNull();
+        assertThat(request.getMappings()).isNull();
+        assertThat(request.getAliases()).isNull();
+    }
+    
+    @Test
+    void testBuilder_WithValues() {
+        // Given
+        Map<String, Object> settings = Map.of("shards", 3);
+        Map<String, Object> mappings = Map.of("properties", Map.of());
+        
+        // When
+        IndexRequest request = IndexRequest.builder()
+            .settings(settings)
+            .mappings(mappings)
+            .build();
+        
+        // Then
+        assertThat(request.getSettings()).isEqualTo(settings);
+        assertThat(request.getMappings()).isEqualTo(mappings);
+        assertThat(request.getAliases()).isNull();
+    }
+}
diff --git a/src/test/java/io/clustercontroller/api/models/responses/ErrorResponseTest.java b/src/test/java/io/clustercontroller/api/models/responses/ErrorResponseTest.java
new file mode 100644
index 0000000..2c69892
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/models/responses/ErrorResponseTest.java
@@ -0,0 +1,110 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class ErrorResponseTest {
+
+    private ObjectMapper objectMapper;
+    
+    @BeforeEach
+    void setUp() {
+        objectMapper = new ObjectMapper();
+    }
+    
+    @Test
+    void testNotFound_StaticFactory() {
+        // When
+        ErrorResponse response = ErrorResponse.notFound("test-index");
+        
+        // Then
+        assertThat(response.getError()).isEqualTo("resource_not_found_exception");
+        assertThat(response.getReason()).isEqualTo("test-index not found");
+        assertThat(response.getStatus()).isEqualTo(404);
+        assertThat(response.getType()).isNull(); // Not set by factory method
+    }
+    
+    @Test
+    void testNotImplemented_StaticFactory() {
+        // When
+        ErrorResponse response = ErrorResponse.notImplemented("Index creation");
+        
+        // Then
+        assertThat(response.getError()).isEqualTo("not_implemented");
+        assertThat(response.getReason()).isEqualTo("Index creation is not yet implemented");
+        assertThat(response.getStatus()).isEqualTo(501);
+    }
+    
+    @Test
+    void testInternalError_StaticFactory() {
+        // When
+        ErrorResponse response = ErrorResponse.internalError("Database connection failed");
+        
+        // Then
+        assertThat(response.getError()).isEqualTo("internal_server_error");
+        assertThat(response.getReason()).isEqualTo("Database connection failed");
+        assertThat(response.getStatus()).isEqualTo(500);
+    }
+    
+    @Test
+    void testSerialization_SnakeCaseConversion() throws Exception {
+        // Given
+        ErrorResponse response = ErrorResponse.builder()
+            .error("test_error")
+            .reason("Test reason")
+            .status(400)
+            .build();
+        
+        // When
+        String json = objectMapper.writeValueAsString(response);
+        
+        // Then
+        assertThat(json).contains("\"error\":\"test_error\"");
+        assertThat(json).contains("\"reason\":\"Test reason\"");
+        assertThat(json).contains("\"status\":400");
+        assertThat(json).doesNotContain("\"type\""); // Null values excluded by @JsonInclude(NON_EMPTY)
+    }
+    
+    @Test
+    void testDeserialization_FromJson() throws Exception {
+        // Given
+        String json = """
+            {
+                "error": "validation_error",
+                "reason": "Invalid request format",
+                "status": 400,
+                "unknown_field": "ignored"
+            }
+            """;
+        
+        // When
+        ErrorResponse response = objectMapper.readValue(json, ErrorResponse.class);
+        
+        // Then
+        assertThat(response.getError()).isEqualTo("validation_error");
+        assertThat(response.getReason()).isEqualTo("Invalid request format");
+        assertThat(response.getStatus()).isEqualTo(400);
+        assertThat(response.getType()).isNull();
+        // unknown_field is ignored due to @JsonIgnoreProperties(ignoreUnknown = true)
+    }
+    
+    @Test
+    void testBuilder_AllFields() {
+        // When
+        ErrorResponse response = ErrorResponse.builder()
+            .error("custom_error")
+            .type("validation")
+            .reason("Custom validation failed")
+            .status(422)
+            .build();
+        
+        // Then
+        assertThat(response.getError()).isEqualTo("custom_error");
+        assertThat(response.getType()).isEqualTo("validation");
+        assertThat(response.getReason()).isEqualTo("Custom validation failed");
+        assertThat(response.getStatus()).isEqualTo(422);
+    }
+}
diff --git a/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java b/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java
new file mode 100644
index 0000000..b477ca5
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java
@@ -0,0 +1,110 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.Map;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class IndexResponseTest {
+
+    private ObjectMapper objectMapper;
+    
+    @BeforeEach
+    void setUp() {
+        objectMapper = new ObjectMapper();
+    }
+    
+    @Test
+    void testCreateSuccess_StaticFactory() {
+        // When
+        IndexResponse response = IndexResponse.createSuccess("test-index");
+        
+        // Then
+        assertThat(response.getAcknowledged()).isTrue();
+        assertThat(response.getShardsAcknowledged()).isTrue();
+        assertThat(response.getIndex()).isEqualTo("test-index");
+        assertThat(response.getSettings()).isNull();
+        assertThat(response.getMappings()).isNull();
+    }
+    
+    @Test
+    void testDeleteSuccess_StaticFactory() {
+        // When
+        IndexResponse response = IndexResponse.deleteSuccess("test-index");
+        
+        // Then
+        assertThat(response.getAcknowledged()).isTrue();
+        assertThat(response.getShardsAcknowledged()).isNull(); // Not set for delete
+        assertThat(response.getIndex()).isEqualTo("test-index");
+    }
+    
+    @Test
+    void testSerialization_SnakeCaseConversion() throws Exception {
+        // Given
+        IndexResponse response = IndexResponse.builder()
+            .acknowledged(true)
+            .shardsAcknowledged(true)
+            .index("my-index")
+            .settings(Map.of("replicas", 1))
+            .build();
+        
+        // When
+        String json = objectMapper.writeValueAsString(response);
+        
+        // Then
+        assertThat(json).contains("\"acknowledged\":true");
+        assertThat(json).contains("\"shards_acknowledged\":true"); // Snake case conversion
+        assertThat(json).contains("\"index\":\"my-index\"");
+        assertThat(json).contains("\"settings\"");
+        assertThat(json).doesNotContain("\"mappings\""); // Null excluded by @JsonInclude(NON_EMPTY)
+    }
+    
+    @Test
+    void testDeserialization_FromJson() throws Exception {
+        // Given
+        String json = """
+            {
+                "acknowledged": true,
+                "shards_acknowledged": false,
+                "index": "test-index",
+                "settings": {"number_of_shards": 2}
+            }
+            """;
+        
+        // When
+        IndexResponse response = objectMapper.readValue(json, IndexResponse.class);
+        
+        // Then
+        assertThat(response.getAcknowledged()).isTrue();
+        assertThat(response.getShardsAcknowledged()).isFalse();
+        assertThat(response.getIndex()).isEqualTo("test-index");
+        assertThat(response.getSettings()).containsEntry("number_of_shards", 2);
+        assertThat(response.getMappings()).isNull();
+    }
+    
+    @Test
+    void testBuilder_AllFields() {
+        // Given
+        Map<String, Object> settings = Map.of("shards", 3);
+        Map<String, Object> mappings = Map.of("properties", Map.of());
+        
+        // When
+        IndexResponse response = IndexResponse.builder()
+            .acknowledged(true)
+            .shardsAcknowledged(false)
+            .index("custom-index")
+            .settings(settings)
+            .mappings(mappings)
+            .build();
+        
+        // Then
+        assertThat(response.getAcknowledged()).isTrue();
+        assertThat(response.getShardsAcknowledged()).isFalse();
+        assertThat(response.getIndex()).isEqualTo("custom-index");
+        assertThat(response.getSettings()).isEqualTo(settings);
+        assertThat(response.getMappings()).isEqualTo(mappings);
+    }
+}
diff --git a/src/test/java/io/clustercontroller/config/ConstantsTest.java b/src/test/java/io/clustercontroller/config/ConstantsTest.java
index f2e1de5..62a9731 100644
--- a/src/test/java/io/clustercontroller/config/ConstantsTest.java
+++ b/src/test/java/io/clustercontroller/config/ConstantsTest.java
@@ -12,7 +12,7 @@ class ConstantsTest {
     @Test
     void testDefaultConfigurationConstants() {
         assertThat(DEFAULT_CLUSTER_NAME).isEqualTo("default-cluster");
-        assertThat(DEFAULT_ETCD_ENDPOINT).isEqualTo("localhost:2379");
+        assertThat(DEFAULT_ETCD_ENDPOINT).isEqualTo("http://localhost:2379");
         assertThat(DEFAULT_TASK_INTERVAL_SECONDS).isEqualTo(30L);
     }
     
diff --git a/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java b/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java
new file mode 100644
index 0000000..409d84d
--- /dev/null
+++ b/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java
@@ -0,0 +1,80 @@
+package io.clustercontroller.health;
+
+import io.clustercontroller.discovery.Discovery;
+import io.clustercontroller.store.MetadataStore;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+@ExtendWith(MockitoExtension.class)
+class ClusterHealthManagerTest {
+
+    @Mock
+    private Discovery discovery;
+    
+    @Mock
+    private MetadataStore metadataStore;
+    
+    private ClusterHealthManager healthManager;
+    
+    @BeforeEach
+    void setUp() {
+        healthManager = new ClusterHealthManager(discovery, metadataStore);
+    }
+    
+    @Test
+    void testGetClusterHealth_ThrowsUnsupportedOperation() {
+        // When & Then
+        assertThatThrownBy(() -> healthManager.getClusterHealth("cluster"))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Cluster health not yet implemented");
+    }
+    
+    @Test
+    void testGetClusterHealth_WithDifferentLevels() {
+        // Test different health levels
+        assertThatThrownBy(() -> healthManager.getClusterHealth("cluster"))
+            .isInstanceOf(UnsupportedOperationException.class);
+            
+        assertThatThrownBy(() -> healthManager.getClusterHealth("indices"))
+            .isInstanceOf(UnsupportedOperationException.class);
+            
+        assertThatThrownBy(() -> healthManager.getClusterHealth("shards"))
+            .isInstanceOf(UnsupportedOperationException.class);
+    }
+    
+    @Test
+    void testGetIndexHealth_ThrowsUnsupportedOperation() {
+        // Given
+        String indexName = "test-index";
+        String level = "indices";
+        
+        // When & Then
+        assertThatThrownBy(() -> healthManager.getIndexHealth(indexName, level))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Index health not yet implemented");
+    }
+    
+    @Test
+    void testGetClusterStats_ThrowsUnsupportedOperation() {
+        // When & Then
+        assertThatThrownBy(() -> healthManager.getClusterStats())
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Cluster stats not yet implemented");
+    }
+    
+    @Test
+    void testConstructor_InitializesCorrectly() {
+        // When
+        ClusterHealthManager manager = new ClusterHealthManager(discovery, metadataStore);
+        
+        // Then
+        assertThat(manager).isNotNull();
+        // Verify dependencies are stored (via successful construction)
+    }
+}
diff --git a/src/test/java/io/clustercontroller/indices/AliasManagerTest.java b/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
new file mode 100644
index 0000000..8758bab
--- /dev/null
+++ b/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
@@ -0,0 +1,83 @@
+package io.clustercontroller.indices;
+
+import io.clustercontroller.store.MetadataStore;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+@ExtendWith(MockitoExtension.class)
+class AliasManagerTest {
+
+    @Mock
+    private MetadataStore metadataStore;
+    
+    private AliasManager aliasManager;
+    
+    @BeforeEach
+    void setUp() {
+        aliasManager = new AliasManager(metadataStore);
+    }
+    
+    @Test
+    void testCreateAlias_ThrowsUnsupportedOperation() {
+        // Given
+        String indexName = "test-index";
+        String aliasName = "test-alias";
+        String aliasConfig = "{\"filter\":{\"term\":{\"status\":\"published\"}}}";
+        
+        // When & Then
+        assertThatThrownBy(() -> aliasManager.createAlias(indexName, aliasName, aliasConfig))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Alias creation not yet implemented");
+    }
+    
+    @Test
+    void testDeleteAlias_ThrowsUnsupportedOperation() {
+        // Given
+        String indexName = "test-index";
+        String aliasName = "test-alias";
+        
+        // When & Then
+        assertThatThrownBy(() -> aliasManager.deleteAlias(indexName, aliasName))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Alias deletion not yet implemented");
+    }
+    
+    @Test
+    void testGetAlias_ThrowsUnsupportedOperation() {
+        // Given
+        String aliasName = "test-alias";
+        
+        // When & Then
+        assertThatThrownBy(() -> aliasManager.getAlias(aliasName))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Get alias not yet implemented");
+    }
+    
+    @Test
+    void testAliasExists_ReturnsFalse() {
+        // Given
+        String aliasName = "test-alias";
+        
+        // When
+        boolean exists = aliasManager.aliasExists(aliasName);
+        
+        // Then
+        assertThat(exists).isFalse(); // Default implementation returns false
+    }
+    
+    @Test
+    void testConstructor_InitializesCorrectly() {
+        // When
+        AliasManager manager = new AliasManager(metadataStore);
+        
+        // Then
+        assertThat(manager).isNotNull();
+        // Verify dependencies are stored (via successful construction)
+    }
+}
diff --git a/src/test/java/io/clustercontroller/tasks/impl/PlanShardAllocationTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/PlanShardAllocationTaskTest.java
index 85a1415..978c04f 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/PlanShardAllocationTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/PlanShardAllocationTaskTest.java
@@ -1,71 +1,90 @@
 package io.clustercontroller.tasks.impl;
 
-import io.clustercontroller.indices.IndexManager;
 import io.clustercontroller.tasks.TaskContext;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
+import org.mockito.junit.jupiter.MockitoExtension;
 
 import static io.clustercontroller.config.Constants.*;
-import static org.assertj.core.api.Assertions.*;
-import static org.mockito.Mockito.*;
+import static org.assertj.core.api.Assertions.assertThat;
 
-/**
- * Tests for PlanShardAllocationTask.
- */
+@ExtendWith(MockitoExtension.class)
 class PlanShardAllocationTaskTest {
-    
+
     @Mock
     private TaskContext taskContext;
     
-    @Mock
-    private IndexManager indexManager;
-    
     @BeforeEach
     void setUp() {
-        MockitoAnnotations.openMocks(this);
-        when(taskContext.getIndexManager()).thenReturn(indexManager);
+        // No setup needed for this simplified test
     }
     
     @Test
-    void testPlanShardAllocationTaskExecution() {
+    void testPlanShardAllocationTaskExecution_ReturnsCompleted() {
+        // Given
         String taskName = "plan-shard-allocation-task";
         String input = "";
-        PlanShardAllocationTask task = new PlanShardAllocationTask(taskName, 1, input, TASK_SCHEDULE_ONCE);
+        PlanShardAllocationTask task = new PlanShardAllocationTask(taskName, 1, input, TASK_SCHEDULE_REPEAT);
         
+        // When
         String result = task.execute(taskContext);
         
+        // Then
         assertThat(result).isEqualTo(TASK_STATUS_COMPLETED);
-        verify(indexManager).planShardAllocation();
+        // Note: Task currently just logs and returns success (TODO implementation)
     }
     
     @Test
-    void testPlanShardAllocationTaskProperties() {
-        String taskName = "plan-shard-allocation-task";
-        String input = "";
-        int priority = 7;
-        String schedule = TASK_SCHEDULE_ONCE;
+    void testGetName() {
+        // Given
+        String taskName = "test-plan-shard-allocation";
+        PlanShardAllocationTask task = new PlanShardAllocationTask(taskName, 1, "", TASK_SCHEDULE_ONCE);
         
-        PlanShardAllocationTask task = new PlanShardAllocationTask(taskName, priority, input, schedule);
+        // When
+        String name = task.getName();
         
-        assertThat(task.getName()).isEqualTo(taskName);
-        assertThat(task.getPriority()).isEqualTo(priority);
-        assertThat(task.getInput()).isEqualTo(input);
-        assertThat(task.getSchedule()).isEqualTo(schedule);
+        // Then
+        assertThat(name).isEqualTo(taskName);
     }
     
     @Test
-    void testPlanShardAllocationTaskExecutionFailure() {
-        String taskName = "plan-shard-allocation-task";
-        String input = "";
-        PlanShardAllocationTask task = new PlanShardAllocationTask(taskName, 1, input, TASK_SCHEDULE_ONCE);
+    void testGetPriority() {
+        // Given
+        int priority = 5;
+        PlanShardAllocationTask task = new PlanShardAllocationTask("test", priority, "", TASK_SCHEDULE_ONCE);
         
-        doThrow(new RuntimeException("Planning failed")).when(indexManager).planShardAllocation();
+        // When
+        int actualPriority = task.getPriority();
         
-        String result = task.execute(taskContext);
+        // Then
+        assertThat(actualPriority).isEqualTo(priority);
+    }
+    
+    @Test
+    void testGetInput() {
+        // Given
+        String input = "test-input";
+        PlanShardAllocationTask task = new PlanShardAllocationTask("test", 1, input, TASK_SCHEDULE_ONCE);
+        
+        // When
+        String actualInput = task.getInput();
+        
+        // Then
+        assertThat(actualInput).isEqualTo(input);
+    }
+    
+    @Test
+    void testGetSchedule() {
+        // Given
+        String schedule = TASK_SCHEDULE_REPEAT;
+        PlanShardAllocationTask task = new PlanShardAllocationTask("test", 1, "", schedule);
+        
+        // When
+        String actualSchedule = task.getSchedule();
         
-        assertThat(result).isEqualTo(TASK_STATUS_FAILED);
-        verify(indexManager).planShardAllocation();
+        // Then
+        assertThat(actualSchedule).isEqualTo(schedule);
     }
-}
+}
\ No newline at end of file
-- 
2.50.1


From cb0b0bdf02f7d3a2aa9af5173f99920eef09517f Mon Sep 17 00:00:00 2001
From: tjnaik <tjnaik@uber.com>
Date: Fri, 19 Sep 2025 16:15:35 -0700
Subject: [PATCH 06/12] Add alias and template REST APIs with comprehensive
 tests

---
 .../api/handlers/AliasHandler.java            | 126 ++++++++++++
 .../api/handlers/TemplateHandler.java         | 122 +++++++++++
 .../api/models/requests/TemplateRequest.java  |  57 ++++++
 .../api/models/responses/AliasResponse.java   |  26 +++
 .../models/responses/TemplateResponse.java    |  25 +++
 .../indices/AliasManager.java                 |   2 +-
 .../templates/TemplateManager.java            |   2 +-
 .../api/handlers/AliasHandlerTest.java        | 190 ++++++++++++++++++
 .../api/handlers/TemplateHandlerTest.java     | 187 +++++++++++++++++
 .../indices/AliasManagerTest.java             |  11 +-
 .../templates/TemplateManagerTest.java        |  60 ++++++
 11 files changed, 800 insertions(+), 8 deletions(-)
 create mode 100644 src/main/java/io/clustercontroller/api/handlers/AliasHandler.java
 create mode 100644 src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/requests/TemplateRequest.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/responses/AliasResponse.java
 create mode 100644 src/main/java/io/clustercontroller/api/models/responses/TemplateResponse.java
 create mode 100644 src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java
 create mode 100644 src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java
 create mode 100644 src/test/java/io/clustercontroller/templates/TemplateManagerTest.java

diff --git a/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java b/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java
new file mode 100644
index 0000000..f4ce447
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java
@@ -0,0 +1,126 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.requests.AliasRequest;
+import io.clustercontroller.api.models.responses.AliasResponse;
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.indices.AliasManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.*;
+
+/**
+ * REST API handler for index alias operations.
+ *
+ * Provides endpoints for creating, reading, updating, and deleting index aliases.
+ * Aliases allow referring to one or more indices by alternative names, enabling
+ * zero-downtime reindexing and simplified index management.
+ *
+ * Supported operations:
+ * - PUT /{index}/_alias/{alias} - Create or update an alias
+ * - DELETE /{index}/_alias/{alias} - Remove an alias from an index
+ * - GET /{alias} - Get information about an alias
+ * - GET /_alias/{alias} - Get alias information (alternative endpoint)
+ * - GET /{index}/_alias - Get all aliases for an index
+ */
+@Slf4j
+@RestController
+@RequestMapping("/")
+public class AliasHandler {
+
+    private final AliasManager aliasManager;
+    private final ObjectMapper objectMapper;
+
+    public AliasHandler(AliasManager aliasManager, ObjectMapper objectMapper) {
+        this.aliasManager = aliasManager;
+        this.objectMapper = objectMapper;
+    }
+
+    /**
+     * Create or update an alias for an index.
+     * PUT /{index}/_alias/{alias}
+     */
+    @PutMapping("/{index}/_alias/{alias}")
+    public ResponseEntity<Object> createAlias(@PathVariable String index, @PathVariable String alias, 
+                                            @RequestBody(required = false) AliasRequest request) {
+        try {
+            log.info("Creating alias '{}' for index '{}'", alias, index);
+            String aliasConfig = (request != null) ? objectMapper.writeValueAsString(request) : "{}";
+            aliasManager.createAlias(alias, index, aliasConfig);
+            return ResponseEntity.ok(AliasResponse.builder()
+                .acknowledged(true)
+                .alias(alias)
+                .index(index)
+                .build());
+        } catch (UnsupportedOperationException e) {
+            log.error("Error creating alias '{}' for index '{}': {}", alias, index, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Alias creation"));
+        } catch (Exception e) {
+            log.error("Error creating alias '{}' for index '{}': {}", alias, index, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Remove an alias from an index.
+     * DELETE /{index}/_alias/{alias}
+     */
+    @DeleteMapping("/{index}/_alias/{alias}")
+    public ResponseEntity<Object> deleteAlias(@PathVariable String index, @PathVariable String alias) {
+        try {
+            log.info("Deleting alias '{}' from index '{}'", alias, index);
+            aliasManager.deleteAlias(alias, index);
+            return ResponseEntity.ok(AliasResponse.builder()
+                .acknowledged(true)
+                .alias(alias)
+                .index(index)
+                .build());
+        } catch (UnsupportedOperationException e) {
+            log.error("Error deleting alias '{}' from index '{}': {}", alias, index, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Alias deletion"));
+        } catch (Exception e) {
+            log.error("Error deleting alias '{}' from index '{}': {}", alias, index, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Get alias information.
+     * GET /_alias/{alias}
+     */
+    @GetMapping("/_alias/{alias}")
+    public ResponseEntity<Object> getAlias(@PathVariable String alias) {
+        try {
+            log.info("Getting alias information for '{}'", alias);
+            String aliasInfo = aliasManager.getAlias(alias);
+            return ResponseEntity.ok(aliasInfo);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting alias '{}': {}", alias, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get alias"));
+        } catch (Exception e) {
+            log.error("Error getting alias '{}': {}", alias, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Get all aliases for an index.
+     * GET /{index}/_alias
+     */
+    @GetMapping("/{index}/_alias")
+    public ResponseEntity<Object> getIndexAliases(@PathVariable String index) {
+        try {
+            log.info("Getting all aliases for index '{}'", index);
+            // This would typically return all aliases for the specific index
+            String aliasInfo = aliasManager.getAlias(index); // Simplified for now
+            return ResponseEntity.ok(aliasInfo);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting aliases for index '{}': {}", index, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get index aliases"));
+        } catch (Exception e) {
+            log.error("Error getting aliases for index '{}': {}", index, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+}
diff --git a/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java b/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java
new file mode 100644
index 0000000..1db61ff
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java
@@ -0,0 +1,122 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.requests.TemplateRequest;
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.api.models.responses.TemplateResponse;
+import io.clustercontroller.templates.TemplateManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.*;
+
+/**
+ * REST API handler for index template operations.
+ *
+ * Provides endpoints for creating, reading, updating, and deleting index templates.
+ * Templates define default settings, mappings, and aliases that are automatically
+ * applied to new indices matching specified patterns.
+ *
+ * Supported operations:
+ * - PUT /_index_template/{name} - Create or update an index template
+ * - GET /_index_template/{name} - Get a specific index template
+ * - DELETE /_index_template/{name} - Delete an index template
+ * - GET /_index_template - Get all index templates
+ */
+@Slf4j
+@RestController
+@RequestMapping("/_index_template")
+public class TemplateHandler {
+
+    private final TemplateManager templateManager;
+    private final ObjectMapper objectMapper;
+
+    public TemplateHandler(TemplateManager templateManager, ObjectMapper objectMapper) {
+        this.templateManager = templateManager;
+        this.objectMapper = objectMapper;
+    }
+
+    /**
+     * Create or update an index template.
+     * PUT /_index_template/{name}
+     */
+    @PutMapping("/{name}")
+    public ResponseEntity<Object> createTemplate(@PathVariable String name, @RequestBody TemplateRequest request) {
+        try {
+            log.info("Creating index template: {}", name);
+            String templateConfig = objectMapper.writeValueAsString(request);
+            templateManager.putTemplate(name, templateConfig);
+            return ResponseEntity.ok(TemplateResponse.builder()
+                .acknowledged(true)
+                .template(name)
+                .build());
+        } catch (UnsupportedOperationException e) {
+            log.error("Error creating template '{}': {}", name, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Template creation"));
+        } catch (Exception e) {
+            log.error("Error creating template '{}': {}", name, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Get a specific index template.
+     * GET /_index_template/{name}
+     */
+    @GetMapping("/{name}")
+    public ResponseEntity<Object> getTemplate(@PathVariable String name) {
+        try {
+            log.info("Getting index template: {}", name);
+            String templateInfo = templateManager.getTemplate(name);
+            return ResponseEntity.ok(templateInfo);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting template '{}': {}", name, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get template"));
+        } catch (Exception e) {
+            log.error("Error getting template '{}': {}", name, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Delete an index template.
+     * DELETE /_index_template/{name}
+     */
+    @DeleteMapping("/{name}")
+    public ResponseEntity<Object> deleteTemplate(@PathVariable String name) {
+        try {
+            log.info("Deleting index template: {}", name);
+            templateManager.deleteTemplate(name);
+            return ResponseEntity.ok(TemplateResponse.builder()
+                .acknowledged(true)
+                .template(name)
+                .build());
+        } catch (UnsupportedOperationException e) {
+            log.error("Error deleting template '{}': {}", name, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Template deletion"));
+        } catch (Exception e) {
+            log.error("Error deleting template '{}': {}", name, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Get all index templates.
+     * GET /_index_template
+     */
+    @GetMapping
+    public ResponseEntity<Object> getAllTemplates() {
+        try {
+            log.info("Getting all index templates");
+            // This would typically return all templates - simplified for now
+            String templatesInfo = templateManager.getTemplate("*"); // Wildcard pattern
+            return ResponseEntity.ok(templatesInfo);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting all templates: {}", e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get all templates"));
+        } catch (Exception e) {
+            log.error("Error getting all templates: {}", e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+}
diff --git a/src/main/java/io/clustercontroller/api/models/requests/TemplateRequest.java b/src/main/java/io/clustercontroller/api/models/requests/TemplateRequest.java
new file mode 100644
index 0000000..757d79d
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/requests/TemplateRequest.java
@@ -0,0 +1,57 @@
+package io.clustercontroller.api.models.requests;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Request model for index template creation and update operations.
+ *
+ * Allows specifying template patterns, settings, mappings, and aliases that will be
+ * automatically applied to new indices matching the specified patterns.
+ * Uses Jackson annotations for automatic JSON serialization/deserialization
+ * with snake_case property naming for compatibility.
+ *
+ * Example usage:
+ * <pre>
+ * {
+ *   "index_patterns": ["logs-*", "metrics-*"],
+ *   "priority": 100,
+ *   "template": {
+ *     "settings": {"number_of_shards": 1},
+ *     "mappings": {"properties": {"timestamp": {"type": "date"}}},
+ *     "aliases": {"current": {}}
+ *   }
+ * }
+ * </pre>
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class TemplateRequest {
+    private List<String> indexPatterns;
+    private Integer priority;
+    private TemplateDefinition template;
+
+    @Data
+    @Builder
+    @NoArgsConstructor
+    @AllArgsConstructor
+    @JsonInclude(JsonInclude.Include.NON_EMPTY)
+    @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+    public static class TemplateDefinition {
+        private Map<String, Object> settings;
+        private Map<String, Object> mappings;
+        private Map<String, Object> aliases;
+    }
+}
diff --git a/src/main/java/io/clustercontroller/api/models/responses/AliasResponse.java b/src/main/java/io/clustercontroller/api/models/responses/AliasResponse.java
new file mode 100644
index 0000000..d219b88
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/responses/AliasResponse.java
@@ -0,0 +1,26 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * Response model for alias creation and deletion operations.
+ * Indicates whether the alias operation was acknowledged by the cluster.
+ * Uses snake_case for JSON property names.
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class AliasResponse {
+    private boolean acknowledged;
+    private String alias;
+    private String index;
+}
diff --git a/src/main/java/io/clustercontroller/api/models/responses/TemplateResponse.java b/src/main/java/io/clustercontroller/api/models/responses/TemplateResponse.java
new file mode 100644
index 0000000..8117c12
--- /dev/null
+++ b/src/main/java/io/clustercontroller/api/models/responses/TemplateResponse.java
@@ -0,0 +1,25 @@
+package io.clustercontroller.api.models.responses;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.PropertyNamingStrategies;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * Response model for template creation and deletion operations.
+ * Indicates whether the template operation was acknowledged by the cluster.
+ * Uses snake_case for JSON property names.
+ */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+@JsonInclude(JsonInclude.Include.NON_EMPTY)
+@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
+public class TemplateResponse {
+    private boolean acknowledged;
+    private String template;
+}
diff --git a/src/main/java/io/clustercontroller/indices/AliasManager.java b/src/main/java/io/clustercontroller/indices/AliasManager.java
index 6ceb33d..6836f59 100644
--- a/src/main/java/io/clustercontroller/indices/AliasManager.java
+++ b/src/main/java/io/clustercontroller/indices/AliasManager.java
@@ -36,6 +36,6 @@ public class AliasManager {
     public boolean aliasExists(String aliasName) {
         log.info("Checking if alias '{}' exists", aliasName);
         // TODO: Implement alias existence check
-        return false;
+        throw new UnsupportedOperationException("Alias existence check not yet implemented");
     }
 }
diff --git a/src/main/java/io/clustercontroller/templates/TemplateManager.java b/src/main/java/io/clustercontroller/templates/TemplateManager.java
index 1580dbf..43513a7 100644
--- a/src/main/java/io/clustercontroller/templates/TemplateManager.java
+++ b/src/main/java/io/clustercontroller/templates/TemplateManager.java
@@ -42,6 +42,6 @@ public class TemplateManager {
     public boolean templateExists(String templateName) {
         log.info("Checking if template '{}' exists", templateName);
         // TODO: Implement template existence check
-        return false;
+        throw new UnsupportedOperationException("Template existence check not yet implemented");
     }
 }
diff --git a/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java
new file mode 100644
index 0000000..a9d2725
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java
@@ -0,0 +1,190 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.requests.AliasRequest;
+import io.clustercontroller.api.models.responses.AliasResponse;
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.indices.AliasManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.*;
+
+class AliasHandlerTest {
+
+    @Mock
+    private AliasManager aliasManager;
+
+    @Mock
+    private ObjectMapper objectMapper;
+
+    @InjectMocks
+    private AliasHandler aliasHandler;
+
+    @BeforeEach
+    void setUp() {
+        MockitoAnnotations.openMocks(this);
+    }
+
+    @Test
+    void testCreateAlias_Success() throws Exception {
+        // Given
+        String index = "test-index";
+        String alias = "test-alias";
+        AliasRequest request = AliasRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doNothing().when(aliasManager).createAlias(anyString(), anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.createAlias(index, alias, request);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(AliasResponse.class);
+
+        AliasResponse aliasResponse = (AliasResponse) response.getBody();
+        assertThat(aliasResponse.isAcknowledged()).isTrue();
+        assertThat(aliasResponse.getAlias()).isEqualTo(alias);
+        assertThat(aliasResponse.getIndex()).isEqualTo(index);
+
+        verify(aliasManager).createAlias(alias, index, "{}");
+    }
+
+    @Test
+    void testCreateAlias_UnsupportedOperation() throws Exception {
+        // Given
+        String index = "test-index";
+        String alias = "test-alias";
+        AliasRequest request = AliasRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doThrow(new UnsupportedOperationException("Not implemented"))
+            .when(aliasManager).createAlias(anyString(), anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.createAlias(index, alias, request);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testCreateAlias_InternalError() throws Exception {
+        // Given
+        String index = "test-index";
+        String alias = "test-alias";
+        AliasRequest request = AliasRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doThrow(new RuntimeException("Database error"))
+            .when(aliasManager).createAlias(anyString(), anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.createAlias(index, alias, request);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
+        assertThat(errorResponse.getReason()).contains("Database error");
+        assertThat(errorResponse.getStatus()).isEqualTo(500);
+    }
+
+    @Test
+    void testDeleteAlias_Success() {
+        // Given
+        String index = "test-index";
+        String alias = "test-alias";
+        doNothing().when(aliasManager).deleteAlias(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.deleteAlias(index, alias);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(AliasResponse.class);
+
+        AliasResponse aliasResponse = (AliasResponse) response.getBody();
+        assertThat(aliasResponse.isAcknowledged()).isTrue();
+        assertThat(aliasResponse.getAlias()).isEqualTo(alias);
+        assertThat(aliasResponse.getIndex()).isEqualTo(index);
+
+        verify(aliasManager).deleteAlias(alias, index);
+    }
+
+    @Test
+    void testDeleteAlias_UnsupportedOperation() {
+        // Given
+        String index = "test-index";
+        String alias = "test-alias";
+        doThrow(new UnsupportedOperationException("Not implemented"))
+            .when(aliasManager).deleteAlias(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.deleteAlias(index, alias);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testGetAlias_NotImplemented() {
+        // Given
+        String alias = "test-alias";
+        when(aliasManager.getAlias(anyString()))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.getAlias(alias);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("Get alias is not yet implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testGetIndexAliases_NotImplemented() {
+        // Given
+        String index = "test-index";
+        when(aliasManager.getAlias(anyString()))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+
+        // When
+        ResponseEntity<Object> response = aliasHandler.getIndexAliases(index);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("Get index aliases is not yet implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+}
diff --git a/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java
new file mode 100644
index 0000000..1140ab5
--- /dev/null
+++ b/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java
@@ -0,0 +1,187 @@
+package io.clustercontroller.api.handlers;
+
+import io.clustercontroller.api.models.requests.TemplateRequest;
+import io.clustercontroller.api.models.responses.ErrorResponse;
+import io.clustercontroller.api.models.responses.TemplateResponse;
+import io.clustercontroller.templates.TemplateManager;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.*;
+
+class TemplateHandlerTest {
+
+    @Mock
+    private TemplateManager templateManager;
+
+    @Mock
+    private ObjectMapper objectMapper;
+
+    @InjectMocks
+    private TemplateHandler templateHandler;
+
+    @BeforeEach
+    void setUp() {
+        MockitoAnnotations.openMocks(this);
+    }
+
+    @Test
+    void testCreateTemplate_Success() throws Exception {
+        // Given
+        String templateName = "test-template";
+        TemplateRequest request = TemplateRequest.builder()
+            .indexPatterns(List.of("logs-*"))
+            .priority(100)
+            .build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{\"index_patterns\":[\"logs-*\"],\"priority\":100}");
+        doNothing().when(templateManager).putTemplate(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = templateHandler.createTemplate(templateName, request);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(TemplateResponse.class);
+
+        TemplateResponse templateResponse = (TemplateResponse) response.getBody();
+        assertThat(templateResponse.isAcknowledged()).isTrue();
+        assertThat(templateResponse.getTemplate()).isEqualTo(templateName);
+
+        verify(templateManager).putTemplate(templateName, "{\"index_patterns\":[\"logs-*\"],\"priority\":100}");
+    }
+
+    @Test
+    void testCreateTemplate_UnsupportedOperation() throws Exception {
+        // Given
+        String templateName = "test-template";
+        TemplateRequest request = TemplateRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doThrow(new UnsupportedOperationException("Not implemented"))
+            .when(templateManager).putTemplate(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = templateHandler.createTemplate(templateName, request);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testCreateTemplate_InternalError() throws Exception {
+        // Given
+        String templateName = "test-template";
+        TemplateRequest request = TemplateRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doThrow(new RuntimeException("Template validation failed"))
+            .when(templateManager).putTemplate(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = templateHandler.createTemplate(templateName, request);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
+        assertThat(errorResponse.getReason()).contains("Template validation failed");
+        assertThat(errorResponse.getStatus()).isEqualTo(500);
+    }
+
+    @Test
+    void testGetTemplate_NotImplemented() {
+        // Given
+        String templateName = "test-template";
+        when(templateManager.getTemplate(anyString()))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+
+        // When
+        ResponseEntity<Object> response = templateHandler.getTemplate(templateName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("Get template is not yet implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testDeleteTemplate_Success() {
+        // Given
+        String templateName = "test-template";
+        doNothing().when(templateManager).deleteTemplate(anyString());
+
+        // When
+        ResponseEntity<Object> response = templateHandler.deleteTemplate(templateName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(TemplateResponse.class);
+
+        TemplateResponse templateResponse = (TemplateResponse) response.getBody();
+        assertThat(templateResponse.isAcknowledged()).isTrue();
+        assertThat(templateResponse.getTemplate()).isEqualTo(templateName);
+
+        verify(templateManager).deleteTemplate(templateName);
+    }
+
+    @Test
+    void testDeleteTemplate_UnsupportedOperation() {
+        // Given
+        String templateName = "test-template";
+        doThrow(new UnsupportedOperationException("Not implemented"))
+            .when(templateManager).deleteTemplate(anyString());
+
+        // When
+        ResponseEntity<Object> response = templateHandler.deleteTemplate(templateName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testGetAllTemplates_NotImplemented() {
+        // Given
+        when(templateManager.getTemplate(anyString()))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+
+        // When
+        ResponseEntity<Object> response = templateHandler.getAllTemplates();
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("Get all templates is not yet implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+}
diff --git a/src/test/java/io/clustercontroller/indices/AliasManagerTest.java b/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
index 8758bab..67449fc 100644
--- a/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
+++ b/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
@@ -60,15 +60,14 @@ class AliasManagerTest {
     }
     
     @Test
-    void testAliasExists_ReturnsFalse() {
+    void testAliasExists_ThrowsUnsupportedOperation() {
         // Given
         String aliasName = "test-alias";
         
-        // When
-        boolean exists = aliasManager.aliasExists(aliasName);
-        
-        // Then
-        assertThat(exists).isFalse(); // Default implementation returns false
+        // When & Then
+        assertThatThrownBy(() -> aliasManager.aliasExists(aliasName))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Alias existence check not yet implemented");
     }
     
     @Test
diff --git a/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java b/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java
new file mode 100644
index 0000000..b5b6f04
--- /dev/null
+++ b/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java
@@ -0,0 +1,60 @@
+package io.clustercontroller.templates;
+
+import io.clustercontroller.store.MetadataStore;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+class TemplateManagerTest {
+
+    @Mock
+    private MetadataStore metadataStore;
+
+    @InjectMocks
+    private TemplateManager templateManager;
+
+    @BeforeEach
+    void setUp() {
+        MockitoAnnotations.openMocks(this);
+    }
+
+    @Test
+    void testTemplateExists_NotImplemented() {
+        String templateName = "test-template";
+        assertThatThrownBy(() -> templateManager.templateExists(templateName))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Template existence check not yet implemented");
+    }
+
+    @Test
+    void testPutTemplate_NotImplemented() {
+        String templateName = "test-template";
+        String templateConfig = "{\"index_patterns\":[\"logs-*\"]}";
+
+        assertThatThrownBy(() -> templateManager.putTemplate(templateName, templateConfig))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Template creation not yet implemented");
+    }
+
+    @Test
+    void testDeleteTemplate_NotImplemented() {
+        String templateName = "test-template";
+
+        assertThatThrownBy(() -> templateManager.deleteTemplate(templateName))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Template deletion not yet implemented");
+    }
+
+    @Test
+    void testGetTemplate_NotImplemented() {
+        String templateName = "test-template";
+        assertThatThrownBy(() -> templateManager.getTemplate(templateName))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Get template not yet implemented");
+    }
+}
-- 
2.50.1


From 68943800ea61c1a9e133d8e91dfa5523a62c3478 Mon Sep 17 00:00:00 2001
From: tjnaik <tjnaik@uber.com>
Date: Tue, 23 Sep 2025 09:10:32 -0700
Subject: [PATCH 07/12] feat: implement multi-cluster support

- Add clusterId parameter to API handlers and managers
- Update MetadataStore and EtcdPathResolver for cluster-aware operations
- Modify Discovery and TaskManager constructors to accept clusterName
- Remove unused CreateIndexTask and DeleteIndexTask
- Ensure proper data isolation between clusters in etcd
---
 .../ClusterControllerApplication.java         |  90 +++---
 .../io/clustercontroller/TaskManager.java     |  14 +-
 .../api/handlers/AliasHandler.java            |  86 +++---
 .../api/handlers/HealthHandler.java           |  69 +++--
 .../api/handlers/IndexHandler.java            | 188 ++++++++++---
 .../api/handlers/TemplateHandler.java         |  80 +++---
 .../api/models/responses/IndexResponse.java   |   4 +-
 .../discovery/Discovery.java                  |  22 +-
 .../clustercontroller/enums/HealthState.java  |  31 ++-
 .../health/ClusterHealthManager.java          |   6 +-
 .../indices/AliasManager.java                 |  47 ++--
 .../indices/IndexManager.java                 |  20 +-
 .../clustercontroller/models/SearchUnit.java  |   2 +-
 .../models/TaskMetadata.java                  |   1 +
 .../store/EtcdMetadataStore.java              | 128 ++++-----
 .../store/EtcdPathResolver.java               |  80 +++---
 .../store/MetadataStore.java                  |  37 ++-
 .../java/io/clustercontroller/tasks/Task.java |   1 +
 .../clustercontroller/tasks/TaskContext.java  |   1 +
 .../clustercontroller/tasks/TaskFactory.java  |  12 -
 .../impl/ActualAllocationUpdaterTask.java     |   1 +
 .../tasks/impl/CreateIndexTask.java           |  36 ---
 .../tasks/impl/DeleteIndexTask.java           |  36 ---
 .../tasks/impl/DiscoverSearchUnitTask.java    |   1 +
 .../tasks/impl/PlanShardAllocationTask.java   |   2 +
 .../tasks/impl/ShardAllocatorTask.java        |   1 +
 .../tasks/impl/UnknownTask.java               |   1 +
 .../templates/TemplateManager.java            |  55 ++--
 .../ClusterControllerApplicationTest.java     |   8 +-
 .../io/clustercontroller/TaskManagerTest.java | 137 +++++-----
 .../api/handlers/AliasHandlerTest.java        |  88 +-----
 .../api/handlers/HealthHandlerTest.java       |  93 ++++---
 .../api/handlers/IndexHandlerTest.java        | 258 ++++++++++++------
 .../api/handlers/TemplateHandlerTest.java     |  70 +----
 .../models/responses/IndexResponseTest.java   |  16 +-
 .../discovery/DiscoveryTest.java              | 117 ++------
 .../health/ClusterHealthManagerTest.java      |  76 +++---
 .../indices/AliasManagerTest.java             |  16 +-
 .../models/SearchUnitTest.java                |   8 +
 .../store/EtcdMetadataStoreTest.java          |  55 ++--
 .../store/EtcdPathResolverTest.java           | 175 +++++-------
 .../store/LeaderElectionTest.java             |  10 +-
 .../tasks/TaskFactoryTest.java                |  24 +-
 .../impl/ActualAllocationUpdaterTaskTest.java |   1 +
 .../tasks/impl/CreateIndexTaskTest.java       |  71 -----
 .../tasks/impl/DeleteIndexTaskTest.java       |  71 -----
 .../tasks/impl/ShardAllocatorTaskTest.java    |   1 +
 .../tasks/impl/UnknownTaskTest.java           |   1 +
 .../templates/TemplateManagerTest.java        |  20 +-
 49 files changed, 1104 insertions(+), 1264 deletions(-)
 delete mode 100644 src/main/java/io/clustercontroller/tasks/impl/CreateIndexTask.java
 delete mode 100644 src/main/java/io/clustercontroller/tasks/impl/DeleteIndexTask.java
 delete mode 100644 src/test/java/io/clustercontroller/tasks/impl/CreateIndexTaskTest.java
 delete mode 100644 src/test/java/io/clustercontroller/tasks/impl/DeleteIndexTaskTest.java

diff --git a/src/main/java/io/clustercontroller/ClusterControllerApplication.java b/src/main/java/io/clustercontroller/ClusterControllerApplication.java
index a41d219..2160c73 100644
--- a/src/main/java/io/clustercontroller/ClusterControllerApplication.java
+++ b/src/main/java/io/clustercontroller/ClusterControllerApplication.java
@@ -11,6 +11,7 @@ import io.clustercontroller.templates.TemplateManager;
 import io.clustercontroller.store.MetadataStore;
 import io.clustercontroller.store.EtcdMetadataStore;
 import io.clustercontroller.tasks.TaskContext;
+import io.clustercontroller.TaskManager;
 
 import lombok.extern.slf4j.Slf4j;
 import org.springframework.boot.SpringApplication;
@@ -22,11 +23,13 @@ import org.springframework.context.annotation.Primary;
 import static io.clustercontroller.config.Constants.*;
 
 /**
- * Main Spring Boot application class for the Cluster Controller.
+ * Main Spring Boot application class for the Cluster Controller with multi-cluster support.
  * 
  * This application provides production-ready controller functionality for managing
  * distributed clusters at scale, including shard allocation, cluster coordination,
  * automated operations, and REST APIs backed by pluggable metadata stores.
+ * 
+ * The application is cluster-agnostic - cluster context is provided via API calls.
  */
 @Slf4j
 @SpringBootApplication
@@ -34,11 +37,11 @@ import static io.clustercontroller.config.Constants.*;
 public class ClusterControllerApplication {
 
     public static void main(String[] args) {
-        log.info("Starting Cluster Controller Application with REST APIs");
+        log.info("Starting Multi-Cluster Controller Application with REST APIs");
         
         try {
             SpringApplication.run(ClusterControllerApplication.class, args);
-            log.info("Cluster Controller with REST APIs started successfully");
+            log.info("Multi-Cluster Controller with REST APIs started successfully");
             
         } catch (Exception e) {
             log.error("Failed to start Cluster Controller: {}", e.getMessage(), e);
@@ -54,18 +57,18 @@ public class ClusterControllerApplication {
             new String[]{DEFAULT_ETCD_ENDPOINT}, 
             DEFAULT_TASK_INTERVAL_SECONDS
         );
-        log.info("Loaded configuration for cluster: {}", config.getClusterName());
+        log.info("Loaded configuration with default cluster: {}", config.getClusterName());
         return config;
     }
     
+    /**
+     * MetadataStore bean - cluster-agnostic, uses etcd endpoints only
+     */
     @Bean
     public MetadataStore metadataStore(ClusterControllerConfig config) {
-        log.info("Initializing MetadataStore connection to etcd");
+        log.info("Initializing cluster-agnostic MetadataStore connection to etcd");
         try {
-            MetadataStore store = EtcdMetadataStore.getInstance(
-                config.getClusterName(), 
-                config.getEtcdEndpoints()
-            );
+            EtcdMetadataStore store = EtcdMetadataStore.getInstance();
             store.initialize();
             log.info("MetadataStore initialized successfully");
             return store;
@@ -75,69 +78,72 @@ public class ClusterControllerApplication {
         }
     }
     
+    /**
+     * IndexManager bean for multi-cluster index lifecycle operations.
+     */
     @Bean
     public IndexManager indexManager(MetadataStore metadataStore) {
-        log.info("Initializing IndexManager");
+        log.info("Initializing IndexManager for multi-cluster support");
         return new IndexManager(metadataStore);
     }
-    
+
     @Bean
-    public Discovery discovery(MetadataStore metadataStore) {
-        log.info("Initializing Discovery");
-        return new Discovery(metadataStore);
+    public Discovery discovery(MetadataStore metadataStore, ClusterControllerConfig config) {
+        log.info("Initializing Discovery for cluster: {}", config.getClusterName());
+        return new Discovery(metadataStore, config.getClusterName());
     }
-    
+
     @Bean
     public ClusterHealthManager clusterHealthManager(Discovery discovery, MetadataStore metadataStore) {
-        log.info("Initializing ClusterHealthManager");
+        log.info("Initializing ClusterHealthManager for multi-cluster support");
         return new ClusterHealthManager(discovery, metadataStore);
     }
-    
+
     @Bean
     public AliasManager aliasManager(MetadataStore metadataStore) {
-        log.info("Initializing AliasManager");
+        log.info("Initializing AliasManager for multi-cluster support");
         return new AliasManager(metadataStore);
     }
-    
+
     @Bean
     public TemplateManager templateManager(MetadataStore metadataStore) {
-        log.info("Initializing TemplateManager");
+        log.info("Initializing TemplateManager for multi-cluster support");
         return new TemplateManager(metadataStore);
     }
-    
+
     @Bean
     public ShardAllocator shardAllocator(MetadataStore metadataStore) {
         log.info("Initializing ShardAllocator");
         return new ShardAllocator(metadataStore);
     }
-    
+
     @Bean
     public ActualAllocationUpdater actualAllocationUpdater(MetadataStore metadataStore) {
         log.info("Initializing ActualAllocationUpdater");
         return new ActualAllocationUpdater(metadataStore);
     }
-    
+
+    /**
+     * TaskManager bean for scheduling and executing background tasks.
+     */
     @Bean
-    public TaskManager taskManager(MetadataStore metadataStore, 
-                                   IndexManager indexManager,
-                                   Discovery discovery,
-                                   ShardAllocator shardAllocator,
-                                   ActualAllocationUpdater actualAllocationUpdater,
-                                   ClusterControllerConfig config) {
-        
-        log.info("Initializing TaskManager with background processing");
-        
-        TaskContext taskContext = new TaskContext(indexManager, discovery, shardAllocator, actualAllocationUpdater);
-        
-        TaskManager taskManager = new TaskManager(
-            metadataStore,
-            taskContext,
-            config.getTaskIntervalSeconds()
-        );
-        
+    public TaskManager taskManager(MetadataStore metadataStore, TaskContext taskContext, ClusterControllerConfig config) {
+        log.info("Initializing TaskManager for cluster: {}", config.getClusterName());
+        TaskManager taskManager = new TaskManager(metadataStore, taskContext, config.getClusterName(), config.getTaskIntervalSeconds());
         taskManager.start();
-        log.info("TaskManager started with background processing");
-        
+        log.info("TaskManager started with background processing for cluster: {}", config.getClusterName());
         return taskManager;
     }
+
+    /**
+     * TaskContext bean to provide dependencies to tasks.
+     */
+    @Bean
+    public TaskContext taskContext(
+            IndexManager indexManager,
+            Discovery discovery,
+            ShardAllocator shardAllocator,
+            ActualAllocationUpdater actualAllocationUpdater) {
+        return new TaskContext(indexManager, discovery, shardAllocator, actualAllocationUpdater);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/TaskManager.java b/src/main/java/io/clustercontroller/TaskManager.java
index 7125079..b0e0d90 100644
--- a/src/main/java/io/clustercontroller/TaskManager.java
+++ b/src/main/java/io/clustercontroller/TaskManager.java
@@ -24,14 +24,16 @@ public class TaskManager {
     
     private final MetadataStore metadataStore;
     private final TaskContext taskContext;
+    private final String clusterName;
     
     private final ScheduledExecutorService scheduler;
     private final long intervalSeconds;
     private boolean isRunning = false;
     
-    public TaskManager(MetadataStore metadataStore, TaskContext taskContext, long intervalSeconds) {
+    public TaskManager(MetadataStore metadataStore, TaskContext taskContext, String clusterName, long intervalSeconds) {
         this.metadataStore = metadataStore;
         this.taskContext = taskContext;
+        this.clusterName = clusterName;
         this.intervalSeconds = intervalSeconds;
         this.scheduler = Executors.newScheduledThreadPool(1);
     }
@@ -41,7 +43,7 @@ public class TaskManager {
         TaskMetadata taskMetadata = new TaskMetadata(taskName, priority);
         taskMetadata.setInput(input);
         try {
-            metadataStore.createTask(taskMetadata);
+            metadataStore.createTask(clusterName, taskMetadata);
         } catch (Exception e) {
             log.error("Failed to create task: {}", e.getMessage(), e);
             throw new RuntimeException("Failed to create task", e);
@@ -52,7 +54,7 @@ public class TaskManager {
     public List<TaskMetadata> getAllTasks() {
         log.debug("Getting all tasks");
         try {
-            return metadataStore.getAllTasks();
+            return metadataStore.getAllTasks(clusterName);
         } catch (Exception e) {
             log.error("Failed to get all tasks: {}", e.getMessage(), e);
             throw new RuntimeException("Failed to get tasks", e);
@@ -62,7 +64,7 @@ public class TaskManager {
     public Optional<TaskMetadata> getTask(String taskName) {
         log.debug("Getting task: {}", taskName);
         try {
-            return metadataStore.getTask(taskName);
+            return metadataStore.getTask(clusterName, taskName);
         } catch (Exception e) {
             log.error("Failed to get task {}: {}", taskName, e.getMessage(), e);
             throw new RuntimeException("Failed to get task", e);
@@ -72,7 +74,7 @@ public class TaskManager {
     public void updateTask(TaskMetadata taskMetadata) {
         log.debug("Updating task: {}", taskMetadata.getName());
         try {
-            metadataStore.updateTask(taskMetadata);
+            metadataStore.updateTask(clusterName, taskMetadata);
         } catch (Exception e) {
             log.error("Failed to update task {}: {}", taskMetadata.getName(), e.getMessage(), e);
             throw new RuntimeException("Failed to update task", e);
@@ -82,7 +84,7 @@ public class TaskManager {
     public void deleteTask(String taskName) {
         log.info("Deleting task: {}", taskName);
         try {
-            metadataStore.deleteTask(taskName);
+            metadataStore.deleteTask(clusterName, taskName);
         } catch (Exception e) {
             log.error("Failed to delete task {}: {}", taskName, e.getMessage(), e);
             throw new RuntimeException("Failed to delete task", e);
diff --git a/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java b/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java
index f4ce447..53e076a 100644
--- a/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java
+++ b/src/main/java/io/clustercontroller/api/handlers/AliasHandler.java
@@ -11,22 +11,21 @@ import org.springframework.http.ResponseEntity;
 import org.springframework.web.bind.annotation.*;
 
 /**
- * REST API handler for index alias operations.
+ * REST API handler for index alias operations with multi-cluster support.
  *
  * Provides endpoints for creating, reading, updating, and deleting index aliases.
  * Aliases allow referring to one or more indices by alternative names, enabling
  * zero-downtime reindexing and simplified index management.
  *
- * Supported operations:
- * - PUT /{index}/_alias/{alias} - Create or update an alias
- * - DELETE /{index}/_alias/{alias} - Remove an alias from an index
- * - GET /{alias} - Get information about an alias
- * - GET /_alias/{alias} - Get alias information (alternative endpoint)
- * - GET /{index}/_alias - Get all aliases for an index
+ * Multi-cluster supported operations:
+ * - PUT /{clusterId}/{index}/_alias/{alias} - Create or update an alias
+ * - DELETE /{clusterId}/{index}/_alias/{alias} - Remove an alias from an index
+ * - GET /{clusterId}/_alias/{alias} - Get information about an alias
+ * - GET /{clusterId}/{index}/_alias - Get all aliases for an index
  */
 @Slf4j
 @RestController
-@RequestMapping("/")
+@RequestMapping("/{clusterId}")
 public class AliasHandler {
 
     private final AliasManager aliasManager;
@@ -38,89 +37,98 @@ public class AliasHandler {
     }
 
     /**
-     * Create or update an alias for an index.
-     * PUT /{index}/_alias/{alias}
+     * Create or update an alias for an index in the specified cluster.
+     * PUT /{clusterId}/{index}/_alias/{alias}
      */
     @PutMapping("/{index}/_alias/{alias}")
-    public ResponseEntity<Object> createAlias(@PathVariable String index, @PathVariable String alias, 
-                                            @RequestBody(required = false) AliasRequest request) {
+    public ResponseEntity<Object> createAlias(
+            @PathVariable String clusterId,
+            @PathVariable String index, 
+            @PathVariable String alias, 
+            @RequestBody(required = false) AliasRequest request) {
         try {
-            log.info("Creating alias '{}' for index '{}'", alias, index);
+            log.info("Creating alias '{}' for index '{}' in cluster '{}'", alias, index, clusterId);
             String aliasConfig = (request != null) ? objectMapper.writeValueAsString(request) : "{}";
-            aliasManager.createAlias(alias, index, aliasConfig);
+            aliasManager.createAlias(clusterId, alias, index, aliasConfig);
             return ResponseEntity.ok(AliasResponse.builder()
                 .acknowledged(true)
                 .alias(alias)
                 .index(index)
                 .build());
         } catch (UnsupportedOperationException e) {
-            log.error("Error creating alias '{}' for index '{}': {}", alias, index, e.getMessage());
+            log.error("Error creating alias '{}' for index '{}' in cluster '{}': {}", alias, index, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Alias creation"));
         } catch (Exception e) {
-            log.error("Error creating alias '{}' for index '{}': {}", alias, index, e.getMessage());
+            log.error("Error creating alias '{}' for index '{}' in cluster '{}': {}", alias, index, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 
     /**
-     * Remove an alias from an index.
-     * DELETE /{index}/_alias/{alias}
+     * Remove an alias from an index in the specified cluster.
+     * DELETE /{clusterId}/{index}/_alias/{alias}
      */
     @DeleteMapping("/{index}/_alias/{alias}")
-    public ResponseEntity<Object> deleteAlias(@PathVariable String index, @PathVariable String alias) {
+    public ResponseEntity<Object> deleteAlias(
+            @PathVariable String clusterId,
+            @PathVariable String index, 
+            @PathVariable String alias) {
         try {
-            log.info("Deleting alias '{}' from index '{}'", alias, index);
-            aliasManager.deleteAlias(alias, index);
+            log.info("Deleting alias '{}' from index '{}' in cluster '{}'", alias, index, clusterId);
+            aliasManager.deleteAlias(clusterId, alias, index);
             return ResponseEntity.ok(AliasResponse.builder()
                 .acknowledged(true)
                 .alias(alias)
                 .index(index)
                 .build());
         } catch (UnsupportedOperationException e) {
-            log.error("Error deleting alias '{}' from index '{}': {}", alias, index, e.getMessage());
+            log.error("Error deleting alias '{}' from index '{}' in cluster '{}': {}", alias, index, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Alias deletion"));
         } catch (Exception e) {
-            log.error("Error deleting alias '{}' from index '{}': {}", alias, index, e.getMessage());
+            log.error("Error deleting alias '{}' from index '{}' in cluster '{}': {}", alias, index, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 
     /**
-     * Get alias information.
-     * GET /_alias/{alias}
+     * Get alias information from the specified cluster.
+     * GET /{clusterId}/_alias/{alias}
      */
     @GetMapping("/_alias/{alias}")
-    public ResponseEntity<Object> getAlias(@PathVariable String alias) {
+    public ResponseEntity<Object> getAlias(
+            @PathVariable String clusterId,
+            @PathVariable String alias) {
         try {
-            log.info("Getting alias information for '{}'", alias);
-            String aliasInfo = aliasManager.getAlias(alias);
+            log.info("Getting alias information for '{}' from cluster '{}'", alias, clusterId);
+            String aliasInfo = aliasManager.getAlias(clusterId, alias);
             return ResponseEntity.ok(aliasInfo);
         } catch (UnsupportedOperationException e) {
-            log.error("Error getting alias '{}': {}", alias, e.getMessage());
+            log.error("Error getting alias '{}' from cluster '{}': {}", alias, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get alias"));
         } catch (Exception e) {
-            log.error("Error getting alias '{}': {}", alias, e.getMessage());
+            log.error("Error getting alias '{}' from cluster '{}': {}", alias, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 
     /**
-     * Get all aliases for an index.
-     * GET /{index}/_alias
+     * Get all aliases for an index in the specified cluster.
+     * GET /{clusterId}/{index}/_alias
      */
     @GetMapping("/{index}/_alias")
-    public ResponseEntity<Object> getIndexAliases(@PathVariable String index) {
+    public ResponseEntity<Object> getIndexAliases(
+            @PathVariable String clusterId,
+            @PathVariable String index) {
         try {
-            log.info("Getting all aliases for index '{}'", index);
-            // This would typically return all aliases for the specific index
-            String aliasInfo = aliasManager.getAlias(index); // Simplified for now
+            log.info("Getting all aliases for index '{}' from cluster '{}'", index, clusterId);
+            String aliasInfo = aliasManager.getAlias(clusterId, index);
             return ResponseEntity.ok(aliasInfo);
         } catch (UnsupportedOperationException e) {
-            log.error("Error getting aliases for index '{}': {}", index, e.getMessage());
+            log.error("Error getting aliases for index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get index aliases"));
         } catch (Exception e) {
-            log.error("Error getting aliases for index '{}': {}", index, e.getMessage());
+            log.error("Error getting aliases for index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java b/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java
index fbf1aff..e92833a 100644
--- a/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java
+++ b/src/main/java/io/clustercontroller/api/handlers/HealthHandler.java
@@ -4,76 +4,93 @@ import io.clustercontroller.api.models.responses.ErrorResponse;
 import io.clustercontroller.health.ClusterHealthManager;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
 import org.springframework.web.bind.annotation.*;
 
 /**
- * REST API handler for cluster health and statistics operations.
- * 
+ * REST API handler for cluster health and statistics operations with multi-cluster support.
+ *
  * Provides endpoints for monitoring cluster health, node status, and
  * performance statistics. Health information can be retrieved at different
  * levels of granularity (cluster, indices, or shards).
- * 
- * Supported operations:
- * - GET /_cluster/health - Overall cluster health status
- * - GET /_cluster/health/{index} - Health status for specific index
- * - GET /_cluster/stats - Cluster performance statistics
- * 
+ *
+ * Multi-cluster supported operations:
+ * - GET /{clusterId}/_cluster/health - Overall cluster health status
+ * - GET /{clusterId}/_cluster/health/{index} - Health status for specific index
+ * - GET /{clusterId}/_cluster/stats - Cluster performance statistics
+ *
  * Health status values: GREEN (healthy), YELLOW (degraded), RED (critical)
  */
 @Slf4j
 @RestController
-@RequestMapping("/_cluster")
+@RequestMapping("/{clusterId}/_cluster")
 public class HealthHandler {
-    
+
     private final ClusterHealthManager healthManager;
     private final ObjectMapper objectMapper;
-    
+
     public HealthHandler(ClusterHealthManager healthManager, ObjectMapper objectMapper) {
         this.healthManager = healthManager;
         this.objectMapper = objectMapper;
     }
-    
+
+    /**
+     * Get overall cluster health status for the specified cluster.
+     * GET /{clusterId}/_cluster/health
+     * GET /{clusterId}/_cluster/health?level=cluster|indices|shards
+     */
     @GetMapping("/health")
     public ResponseEntity<Object> getClusterHealth(
+            @PathVariable String clusterId,
             @RequestParam(value = "level", defaultValue = "cluster") String level) {
         try {
-            log.info("Getting cluster health with level: {}", level);
-            String healthJson = healthManager.getClusterHealth(level);
+            log.info("Getting cluster health for cluster '{}' with level: {}", clusterId, level);
+            String healthJson = healthManager.getClusterHealth(clusterId, level);
             return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster health"));
         } catch (UnsupportedOperationException e) {
             return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster health"));
         } catch (Exception e) {
-            log.error("Error getting cluster health: {}", e.getMessage());
+            log.error("Error getting cluster health for cluster '{}': {}", clusterId, e.getMessage());
             return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
-    
+
+    /**
+     * Get health status for a specific index in the specified cluster.
+     * GET /{clusterId}/_cluster/health/{index}
+     */
     @GetMapping("/health/{index}")
-    public ResponseEntity<Object> getIndexHealth(@PathVariable String index) {
+    public ResponseEntity<Object> getIndexHealth(
+            @PathVariable String clusterId,
+            @PathVariable String index) {
         try {
-            log.info("Getting health for index: {}", index);
-            String healthJson = healthManager.getIndexHealth(index, "indices");
+            log.info("Getting health for index '{}' in cluster '{}'", index, clusterId);
+            String healthJson = healthManager.getIndexHealth(clusterId, index, "indices");
             return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index health"));
         } catch (UnsupportedOperationException e) {
             return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index health"));
         } catch (Exception e) {
-            log.error("Error getting health for index {}: {}", index, e.getMessage());
+            log.error("Error getting health for index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
             return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
-    
+
+    /**
+     * Get cluster performance statistics for the specified cluster.
+     * GET /{clusterId}/_cluster/stats
+     */
     @GetMapping("/stats")
-    public ResponseEntity<Object> getClusterStats() {
+    public ResponseEntity<Object> getClusterStats(@PathVariable String clusterId) {
         try {
-            log.info("Getting cluster statistics");
-            String statsJson = healthManager.getClusterStats();
+            log.info("Getting cluster statistics for cluster '{}'", clusterId);
+            String statsJson = healthManager.getClusterStats(clusterId);
             return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster stats"));
         } catch (UnsupportedOperationException e) {
             return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Cluster stats"));
         } catch (Exception e) {
-            log.error("Error getting cluster stats: {}", e.getMessage());
+            log.error("Error getting cluster stats for cluster '{}': {}", clusterId, e.getMessage());
             return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java b/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java
index 3c5a2e9..a9b95b9 100644
--- a/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java
+++ b/src/main/java/io/clustercontroller/api/handlers/IndexHandler.java
@@ -6,28 +6,29 @@ import io.clustercontroller.api.models.responses.IndexResponse;
 import io.clustercontroller.indices.IndexManager;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
 import org.springframework.web.bind.annotation.*;
 
 /**
- * REST API handler for index lifecycle operations.
+ * REST API handler for index lifecycle operations with multi-cluster support.
  * 
  * Provides endpoints for creating, reading, updating, and deleting indices,
  * as well as managing index settings and mappings. All endpoints follow
  * standard REST conventions and return JSON responses.
  * 
- * Supported operations:
- * - PUT /{index} - Create a new index
- * - GET /{index} - Retrieve index information
- * - DELETE /{index} - Delete an index
- * - GET /{index}/_settings - Get index settings
- * - PUT /{index}/_settings - Update index settings
- * - GET /{index}/_mapping - Get index mappings
- * - PUT /{index}/_mapping - Update index mappings
+ * Multi-cluster supported operations:
+ * - PUT /{clusterId}/{index} - Create a new index in specified cluster
+ * - GET /{clusterId}/{index} - Retrieve index information from cluster
+ * - DELETE /{clusterId}/{index} - Delete an index from cluster
+ * - GET /{clusterId}/{index}/_settings - Get index settings from cluster
+ * - PUT /{clusterId}/{index}/_settings - Update index settings in cluster
+ * - GET /{clusterId}/{index}/_mapping - Get index mappings from cluster
+ * - PUT /{clusterId}/{index}/_mapping - Update index mappings in cluster
  */
 @Slf4j
 @RestController
-@RequestMapping("/")
+@RequestMapping("/{clusterId}")
 public class IndexHandler {
     
     private final IndexManager indexManager;
@@ -38,49 +39,170 @@ public class IndexHandler {
         this.objectMapper = objectMapper;
     }
     
+    /**
+     * Create a new index in the specified cluster.
+     * PUT /{clusterId}/{index}
+     */
     @PutMapping("/{index}")
     public ResponseEntity<Object> createIndex(
+            @PathVariable String clusterId,
             @PathVariable String index,
             @RequestBody(required = false) IndexRequest request) {
         try {
-            log.info("Creating index: {}", index);
-            if (request == null) {
-                request = IndexRequest.builder().build();
-            }
-            String jsonConfig = objectMapper.writeValueAsString(request);
-            indexManager.createIndex(jsonConfig);
-            return ResponseEntity.status(201).body(IndexResponse.createSuccess(index));
+            log.info("Creating index '{}' in cluster '{}'", index, clusterId);
+            String indexConfig = (request != null) ? objectMapper.writeValueAsString(request) : "{}";
+            indexManager.createIndex(clusterId, index, indexConfig);
+            return ResponseEntity.status(HttpStatus.CREATED).body(IndexResponse.builder()
+                .acknowledged(true)
+                .shardsAcknowledged(true)
+                .index(index)
+                .build());
         } catch (UnsupportedOperationException e) {
-            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index creation"));
+            log.error("Error creating index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Index creation"));
         } catch (Exception e) {
-            log.error("Error creating index {}: {}", index, e.getMessage());
-            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+            log.error("Error creating index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
     
+    /**
+     * Get index information from the specified cluster.
+     * GET /{clusterId}/{index}
+     */
     @GetMapping("/{index}")
-    public ResponseEntity<Object> getIndex(@PathVariable String index) {
+    public ResponseEntity<Object> getIndex(
+            @PathVariable String clusterId,
+            @PathVariable String index) {
         try {
-            log.info("Getting index: {}", index);
-            String indexInfo = indexManager.getIndex(index);
-            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Get index"));
+            log.info("Getting index '{}' from cluster '{}'", index, clusterId);
+            String indexInfo = indexManager.getIndex(clusterId, index);
+            return ResponseEntity.ok(indexInfo);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get index"));
         } catch (Exception e) {
-            log.error("Error getting index {}: {}", index, e.getMessage());
-            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+            log.error("Error getting index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
     
+    /**
+     * Delete an index from the specified cluster.
+     * DELETE /{clusterId}/{index}
+     */
     @DeleteMapping("/{index}")
-    public ResponseEntity<Object> deleteIndex(@PathVariable String index) {
+    public ResponseEntity<Object> deleteIndex(
+            @PathVariable String clusterId,
+            @PathVariable String index) {
+        try {
+            log.info("Deleting index '{}' from cluster '{}'", index, clusterId);
+            indexManager.deleteIndex(clusterId, index);
+            return ResponseEntity.ok(IndexResponse.builder()
+                .acknowledged(true)
+                .shardsAcknowledged(true)
+                .index(index)
+                .build());
+        } catch (UnsupportedOperationException e) {
+            log.error("Error deleting index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Index deletion"));
+        } catch (Exception e) {
+            log.error("Error deleting index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Get index settings from the specified cluster.
+     * GET /{clusterId}/{index}/_settings
+     */
+    @GetMapping("/{index}/_settings")
+    public ResponseEntity<Object> getIndexSettings(
+            @PathVariable String clusterId,
+            @PathVariable String index) {
+        try {
+            log.info("Getting settings for index '{}' from cluster '{}'", index, clusterId);
+            String settings = indexManager.getSettings(clusterId, index);
+            return ResponseEntity.ok(settings);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting settings for index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get index settings"));
+        } catch (Exception e) {
+            log.error("Error getting settings for index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Update index settings in the specified cluster.
+     * PUT /{clusterId}/{index}/_settings
+     */
+    @PutMapping("/{index}/_settings")
+    public ResponseEntity<Object> updateIndexSettings(
+            @PathVariable String clusterId,
+            @PathVariable String index,
+            @RequestBody String settingsJson) {
+        try {
+            log.info("Updating settings for index '{}' in cluster '{}'", index, clusterId);
+            indexManager.updateSettings(clusterId, index, settingsJson);
+            return ResponseEntity.ok(IndexResponse.builder()
+                .acknowledged(true)
+                .shardsAcknowledged(true)
+                .index(index)
+                .build());
+        } catch (UnsupportedOperationException e) {
+            log.error("Error updating settings for index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Update index settings"));
+        } catch (Exception e) {
+            log.error("Error updating settings for index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Get index mappings from the specified cluster.
+     * GET /{clusterId}/{index}/_mapping
+     */
+    @GetMapping("/{index}/_mapping")
+    public ResponseEntity<Object> getIndexMapping(
+            @PathVariable String clusterId,
+            @PathVariable String index) {
+        try {
+            log.info("Getting mapping for index '{}' from cluster '{}'", index, clusterId);
+            String mapping = indexManager.getMapping(clusterId, index);
+            return ResponseEntity.ok(mapping);
+        } catch (UnsupportedOperationException e) {
+            log.error("Error getting mapping for index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get index mapping"));
+        } catch (Exception e) {
+            log.error("Error getting mapping for index '{}' from cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
+        }
+    }
+
+    /**
+     * Update index mappings in the specified cluster.
+     * PUT /{clusterId}/{index}/_mapping
+     */
+    @PutMapping("/{index}/_mapping")
+    public ResponseEntity<Object> updateIndexMapping(
+            @PathVariable String clusterId,
+            @PathVariable String index,
+            @RequestBody String mappingsJson) {
         try {
-            log.info("Deleting index: {}", index);
-            indexManager.deleteIndex(index);
-            return ResponseEntity.ok(IndexResponse.deleteSuccess(index));
+            log.info("Updating mapping for index '{}' in cluster '{}'", index, clusterId);
+            indexManager.updateMapping(clusterId, index, mappingsJson);
+            return ResponseEntity.ok(IndexResponse.builder()
+                .acknowledged(true)
+                .shardsAcknowledged(true)
+                .index(index)
+                .build());
         } catch (UnsupportedOperationException e) {
-            return ResponseEntity.status(501).body(ErrorResponse.notImplemented("Index deletion"));
+            log.error("Error updating mapping for index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Update index mapping"));
         } catch (Exception e) {
-            log.error("Error deleting index {}: {}", index, e.getMessage());
-            return ResponseEntity.status(500).body(ErrorResponse.internalError(e.getMessage()));
+            log.error("Error updating mapping for index '{}' in cluster '{}': {}", index, clusterId, e.getMessage());
+            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java b/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java
index 1db61ff..dc1818b 100644
--- a/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java
+++ b/src/main/java/io/clustercontroller/api/handlers/TemplateHandler.java
@@ -11,21 +11,21 @@ import org.springframework.http.ResponseEntity;
 import org.springframework.web.bind.annotation.*;
 
 /**
- * REST API handler for index template operations.
+ * REST API handler for index template operations with multi-cluster support.
  *
  * Provides endpoints for creating, reading, updating, and deleting index templates.
  * Templates define default settings, mappings, and aliases that are automatically
  * applied to new indices matching specified patterns.
  *
- * Supported operations:
- * - PUT /_index_template/{name} - Create or update an index template
- * - GET /_index_template/{name} - Get a specific index template
- * - DELETE /_index_template/{name} - Delete an index template
- * - GET /_index_template - Get all index templates
+ * Multi-cluster supported operations:
+ * - PUT /{clusterId}/_index_template/{name} - Create or update an index template
+ * - GET /{clusterId}/_index_template/{name} - Get a specific index template
+ * - DELETE /{clusterId}/_index_template/{name} - Delete an index template
+ * - GET /{clusterId}/_index_template - Get all index templates
  */
 @Slf4j
 @RestController
-@RequestMapping("/_index_template")
+@RequestMapping("/{clusterId}/_index_template")
 public class TemplateHandler {
 
     private final TemplateManager templateManager;
@@ -37,86 +37,92 @@ public class TemplateHandler {
     }
 
     /**
-     * Create or update an index template.
-     * PUT /_index_template/{name}
+     * Create or update an index template in the specified cluster.
+     * PUT /{clusterId}/_index_template/{name}
      */
     @PutMapping("/{name}")
-    public ResponseEntity<Object> createTemplate(@PathVariable String name, @RequestBody TemplateRequest request) {
+    public ResponseEntity<Object> createTemplate(
+            @PathVariable String clusterId,
+            @PathVariable String name, 
+            @RequestBody TemplateRequest request) {
         try {
-            log.info("Creating index template: {}", name);
+            log.info("Creating index template '{}' in cluster '{}'", name, clusterId);
             String templateConfig = objectMapper.writeValueAsString(request);
-            templateManager.putTemplate(name, templateConfig);
+            templateManager.putTemplate(clusterId, name, templateConfig);
             return ResponseEntity.ok(TemplateResponse.builder()
                 .acknowledged(true)
                 .template(name)
                 .build());
         } catch (UnsupportedOperationException e) {
-            log.error("Error creating template '{}': {}", name, e.getMessage());
+            log.error("Error creating template '{}' in cluster '{}': {}", name, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Template creation"));
         } catch (Exception e) {
-            log.error("Error creating template '{}': {}", name, e.getMessage());
+            log.error("Error creating template '{}' in cluster '{}': {}", name, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 
     /**
-     * Get a specific index template.
-     * GET /_index_template/{name}
+     * Get a specific index template from the specified cluster.
+     * GET /{clusterId}/_index_template/{name}
      */
     @GetMapping("/{name}")
-    public ResponseEntity<Object> getTemplate(@PathVariable String name) {
+    public ResponseEntity<Object> getTemplate(
+            @PathVariable String clusterId,
+            @PathVariable String name) {
         try {
-            log.info("Getting index template: {}", name);
-            String templateInfo = templateManager.getTemplate(name);
+            log.info("Getting index template '{}' from cluster '{}'", name, clusterId);
+            String templateInfo = templateManager.getTemplate(clusterId, name);
             return ResponseEntity.ok(templateInfo);
         } catch (UnsupportedOperationException e) {
-            log.error("Error getting template '{}': {}", name, e.getMessage());
+            log.error("Error getting template '{}' from cluster '{}': {}", name, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get template"));
         } catch (Exception e) {
-            log.error("Error getting template '{}': {}", name, e.getMessage());
+            log.error("Error getting template '{}' from cluster '{}': {}", name, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 
     /**
-     * Delete an index template.
-     * DELETE /_index_template/{name}
+     * Delete an index template from the specified cluster.
+     * DELETE /{clusterId}/_index_template/{name}
      */
     @DeleteMapping("/{name}")
-    public ResponseEntity<Object> deleteTemplate(@PathVariable String name) {
+    public ResponseEntity<Object> deleteTemplate(
+            @PathVariable String clusterId,
+            @PathVariable String name) {
         try {
-            log.info("Deleting index template: {}", name);
-            templateManager.deleteTemplate(name);
+            log.info("Deleting index template '{}' from cluster '{}'", name, clusterId);
+            templateManager.deleteTemplate(clusterId, name);
             return ResponseEntity.ok(TemplateResponse.builder()
                 .acknowledged(true)
                 .template(name)
                 .build());
         } catch (UnsupportedOperationException e) {
-            log.error("Error deleting template '{}': {}", name, e.getMessage());
+            log.error("Error deleting template '{}' from cluster '{}': {}", name, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Template deletion"));
         } catch (Exception e) {
-            log.error("Error deleting template '{}': {}", name, e.getMessage());
+            log.error("Error deleting template '{}' from cluster '{}': {}", name, clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
 
     /**
-     * Get all index templates.
-     * GET /_index_template
+     * Get all index templates from the specified cluster.
+     * GET /{clusterId}/_index_template
      */
     @GetMapping
-    public ResponseEntity<Object> getAllTemplates() {
+    public ResponseEntity<Object> getAllTemplates(@PathVariable String clusterId) {
         try {
-            log.info("Getting all index templates");
-            // This would typically return all templates - simplified for now
-            String templatesInfo = templateManager.getTemplate("*"); // Wildcard pattern
+            log.info("Getting all index templates from cluster '{}'", clusterId);
+            String templatesInfo = templateManager.getAllTemplates(clusterId);
             return ResponseEntity.ok(templatesInfo);
         } catch (UnsupportedOperationException e) {
-            log.error("Error getting all templates: {}", e.getMessage());
+            log.error("Error getting all templates from cluster '{}': {}", clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(ErrorResponse.notImplemented("Get all templates"));
         } catch (Exception e) {
-            log.error("Error getting all templates: {}", e.getMessage());
+            log.error("Error getting all templates from cluster '{}': {}", clusterId, e.getMessage());
             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResponse.internalError(e.getMessage()));
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java b/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java
index b742ad3..badde35 100644
--- a/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java
+++ b/src/main/java/io/clustercontroller/api/models/responses/IndexResponse.java
@@ -20,8 +20,8 @@ import java.util.Map;
 @JsonInclude(JsonInclude.Include.NON_EMPTY)
 @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
 public class IndexResponse {
-    private Boolean acknowledged;
-    private Boolean shardsAcknowledged;
+    private boolean acknowledged;
+    private boolean shardsAcknowledged;
     private String index;
     private Map<String, Object> settings;
     private Map<String, Object> mappings;
diff --git a/src/main/java/io/clustercontroller/discovery/Discovery.java b/src/main/java/io/clustercontroller/discovery/Discovery.java
index 8a67909..ee7f1f9 100644
--- a/src/main/java/io/clustercontroller/discovery/Discovery.java
+++ b/src/main/java/io/clustercontroller/discovery/Discovery.java
@@ -21,9 +21,11 @@ import java.util.Map;
 public class Discovery {
     
     private final MetadataStore metadataStore;
+    private final String clusterName;
     
-    public Discovery(MetadataStore metadataStore) {
+    public Discovery(MetadataStore metadataStore, String clusterName) {
         this.metadataStore = metadataStore;
+        this.clusterName = clusterName;
     }
     
     
@@ -47,7 +49,7 @@ public class Discovery {
      */
     private void processAllSearchUnits() {
         try {
-            List<SearchUnit> allSearchUnits = metadataStore.getAllSearchUnits();
+            List<SearchUnit> allSearchUnits = metadataStore.getAllSearchUnits(clusterName);
             log.info("Discovery - Processing {} total search units for updates", allSearchUnits.size());
             
             for (SearchUnit searchUnit : allSearchUnits) {
@@ -55,7 +57,7 @@ public class Discovery {
                     log.debug("Discovery - Processing search unit: {}", searchUnit.getName());
                     
                     // Update the search unit (this could include health checks, metrics, etc.)
-                    metadataStore.updateSearchUnit(searchUnit);
+                    metadataStore.updateSearchUnit(clusterName, searchUnit);
                     
                     log.debug("Discovery - Successfully updated search unit: {}", searchUnit.getName());
                 } catch (Exception e) {
@@ -80,12 +82,12 @@ public class Discovery {
             // Update/create search units in metadata store
             for (SearchUnit searchUnit : etcdSearchUnits) {
                 try {
-                    if (metadataStore.getSearchUnit(searchUnit.getName()).isPresent()) {
+                    if (metadataStore.getSearchUnit(clusterName, searchUnit.getName()).isPresent()) {
                         log.debug("Discovery - Updating existing search unit '{}' from Etcd", searchUnit.getName());
-                        metadataStore.updateSearchUnit(searchUnit);
+                        metadataStore.updateSearchUnit(clusterName, searchUnit);
                     } else {
                         log.info("Discovery - Creating new search unit '{}' from Etcd", searchUnit.getName());
-                        metadataStore.upsertSearchUnit(searchUnit.getName(), searchUnit);
+                        metadataStore.upsertSearchUnit(clusterName, searchUnit.getName(), searchUnit);
                     }
                 } catch (Exception e) {
                     log.warn("Discovery - Failed to update search unit '{}' from Etcd: {}", 
@@ -106,7 +108,7 @@ public class Discovery {
         
         try {
             Map<String, SearchUnitActualState> actualStates = 
-                    metadataStore.getAllSearchUnitActualStates();
+                    metadataStore.getAllSearchUnitActualStates(clusterName);
             
             List<SearchUnit> searchUnits = new ArrayList<>();
             
@@ -175,7 +177,7 @@ public class Discovery {
             log.info("Discovery - Starting cleanup of stale search units...");
             
             // Get all existing search units from metadata store
-            List<SearchUnit> allSearchUnits = metadataStore.getAllSearchUnits();
+            List<SearchUnit> allSearchUnits = metadataStore.getAllSearchUnits(clusterName);
             int deletedCount = 0;
             
             for (SearchUnit searchUnit : allSearchUnits) {
@@ -184,7 +186,7 @@ public class Discovery {
                 try {
                     // Check if actual state exists
                     java.util.Optional<SearchUnitActualState> actualStateOpt = 
-                            metadataStore.getSearchUnitActualState(unitName);
+                            metadataStore.getSearchUnitActualState(clusterName, unitName);
                     
                     boolean shouldDelete = false;
                     String reason = "";
@@ -204,7 +206,7 @@ public class Discovery {
                     
                     if (shouldDelete) {
                         log.info("Discovery - Deleting search unit '{}' due to: {}", unitName, reason);
-                        metadataStore.deleteSearchUnit(unitName);
+                        metadataStore.deleteSearchUnit(clusterName, unitName);
                         deletedCount++;
                     }
                     
diff --git a/src/main/java/io/clustercontroller/enums/HealthState.java b/src/main/java/io/clustercontroller/enums/HealthState.java
index 6cf3011..4ec7274 100644
--- a/src/main/java/io/clustercontroller/enums/HealthState.java
+++ b/src/main/java/io/clustercontroller/enums/HealthState.java
@@ -1,5 +1,8 @@
 package io.clustercontroller.enums;
 
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonValue;
+
 /**
  * Enum representing the health state of a search unit or node.
  * 
@@ -23,5 +26,31 @@ public enum HealthState {
     /**
      * Node is unhealthy due to resource constraints or failures.
      */
-    RED
+    RED;
+    
+    @JsonValue
+    public String getValue() {
+        return name().toLowerCase();
+    }
+    
+    @JsonCreator
+    public static HealthState fromString(String value) {
+        if (value == null) {
+            return null;
+        }
+        
+        String normalizedValue = value.toUpperCase().trim();
+        try {
+            return HealthState.valueOf(normalizedValue);
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException("Unknown health state: " + value);
+        }
+    }
+    
+    /**
+     * Check if this health state indicates the node is healthy enough for allocation.
+     */
+    public boolean isHealthy() {
+        return this == GREEN || this == YELLOW;
+    }
 }
diff --git a/src/main/java/io/clustercontroller/health/ClusterHealthManager.java b/src/main/java/io/clustercontroller/health/ClusterHealthManager.java
index 173057a..be832c7 100644
--- a/src/main/java/io/clustercontroller/health/ClusterHealthManager.java
+++ b/src/main/java/io/clustercontroller/health/ClusterHealthManager.java
@@ -28,19 +28,19 @@ public class ClusterHealthManager {
         this.metadataStore = metadataStore;
     }
     
-    public String getClusterHealth(String level) {
+    public String getClusterHealth(String clusterId, String level) {
         log.info("Getting cluster health with level: {}", level);
         // TODO: Implement cluster health calculation
         throw new UnsupportedOperationException("Cluster health not yet implemented");
     }
     
-    public String getIndexHealth(String indexName, String level) {
+    public String getIndexHealth(String clusterId, String indexName, String level) {
         log.info("Getting health for index '{}' with level: {}", indexName, level);
         // TODO: Implement index-specific health calculation
         throw new UnsupportedOperationException("Index health not yet implemented");
     }
     
-    public String getClusterStats() {
+    public String getClusterStats(String clusterId) {
         log.info("Getting cluster statistics");
         // TODO: Implement cluster statistics aggregation
         throw new UnsupportedOperationException("Cluster stats not yet implemented");
diff --git a/src/main/java/io/clustercontroller/indices/AliasManager.java b/src/main/java/io/clustercontroller/indices/AliasManager.java
index 6836f59..935c82c 100644
--- a/src/main/java/io/clustercontroller/indices/AliasManager.java
+++ b/src/main/java/io/clustercontroller/indices/AliasManager.java
@@ -4,38 +4,41 @@ import io.clustercontroller.store.MetadataStore;
 import lombok.extern.slf4j.Slf4j;
 
 /**
- * Manages alias operations.
+ * Manages index alias operations with multi-cluster support.
+ * Provides methods for creating, deleting, and retrieving aliases for indices.
+ * Aliases allow referring to one or more indices by a different name,
+ * simplifying index management and reindexing operations.
  */
 @Slf4j
 public class AliasManager {
-    
+
     private final MetadataStore metadataStore;
-    
+
     public AliasManager(MetadataStore metadataStore) {
         this.metadataStore = metadataStore;
     }
-    
-    public void createAlias(String indexName, String aliasName, String aliasConfig) {
-        log.info("Creating alias '{}' for index '{}' with config: {}", aliasName, indexName, aliasConfig);
-        // TODO: Implement alias creation logic
+
+    public boolean aliasExists(String clusterId, String aliasName) {
+        log.info("Checking if alias '{}' exists in cluster '{}'", aliasName, clusterId);
+        // TODO: Implement alias existence check - use clusterId
+        throw new UnsupportedOperationException("Alias existence check not yet implemented");
+    }
+
+    public void createAlias(String clusterId, String aliasName, String indexName, String aliasConfig) {
+        log.info("Creating alias '{}' for index '{}' in cluster '{}' with config: {}", aliasName, indexName, clusterId, aliasConfig);
+        // TODO: Implement alias creation logic - use clusterId
         throw new UnsupportedOperationException("Alias creation not yet implemented");
     }
-    
-    public void deleteAlias(String indexName, String aliasName) {
-        log.info("Deleting alias '{}' from index '{}'", aliasName, indexName);
-        // TODO: Implement alias deletion logic
+
+    public void deleteAlias(String clusterId, String aliasName, String indexName) {
+        log.info("Deleting alias '{}' from index '{}' in cluster '{}'", aliasName, indexName, clusterId);
+        // TODO: Implement alias deletion logic - use clusterId
         throw new UnsupportedOperationException("Alias deletion not yet implemented");
     }
-    
-    public String getAlias(String aliasName) {
-        log.info("Getting alias information for '{}'", aliasName);
-        // TODO: Implement get alias logic
+
+    public String getAlias(String clusterId, String aliasName) {
+        log.info("Getting alias information for '{}' from cluster '{}'", aliasName, clusterId);
+        // TODO: Implement get alias logic - use clusterId
         throw new UnsupportedOperationException("Get alias not yet implemented");
     }
-    
-    public boolean aliasExists(String aliasName) {
-        log.info("Checking if alias '{}' exists", aliasName);
-        // TODO: Implement alias existence check
-        throw new UnsupportedOperationException("Alias existence check not yet implemented");
-    }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/indices/IndexManager.java b/src/main/java/io/clustercontroller/indices/IndexManager.java
index 018cac0..d770d43 100644
--- a/src/main/java/io/clustercontroller/indices/IndexManager.java
+++ b/src/main/java/io/clustercontroller/indices/IndexManager.java
@@ -16,20 +16,20 @@ public class IndexManager {
         this.metadataStore = metadataStore;
     }
     
-    public void createIndex(String indexConfig) {
-        log.info("Creating index with config: {}", indexConfig);
+    public void createIndex(String clusterId, String indexName, String indexConfig) {
+        log.info("Creating index {} in cluster {} with config: {}", indexName, clusterId, indexConfig);
         // TODO: Implement index creation logic
     }
     
-    public void deleteIndex(String indexConfig) {
-        log.info("Deleting index with config: {}", indexConfig);
+    public void deleteIndex(String clusterId, String indexName) {
+        log.info("Deleting index {} from cluster {}", indexName, clusterId);
         // TODO: Implement index deletion logic
     }
     
     /**
      * Get index information.
      */
-    public String getIndex(String indexName) {
+    public String getIndex(String clusterId, String indexName) {
         log.info("Getting index information for: {}", indexName);
         // TODO: Implement get index logic
         throw new UnsupportedOperationException("Get index not yet implemented");
@@ -38,7 +38,7 @@ public class IndexManager {
     /**
      * Check if index exists.
      */
-    public boolean indexExists(String indexName) {
+    public boolean indexExists(String clusterId, String indexName) {
         log.info("Checking if index exists: {}", indexName);
         // TODO: Implement index existence check
         return false;
@@ -47,7 +47,7 @@ public class IndexManager {
     /**
      * Get index settings.
      */
-    public String getSettings(String indexName) {
+    public String getSettings(String clusterId, String indexName) {
         log.info("Getting settings for index: {}", indexName);
         // TODO: Implement get settings logic
         throw new UnsupportedOperationException("Get settings not yet implemented");
@@ -56,7 +56,7 @@ public class IndexManager {
     /**
      * Update index settings.
      */
-    public void updateSettings(String indexName, String settingsJson) {
+    public void updateSettings(String clusterId, String indexName, String settingsJson) {
         log.info("Updating settings for index '{}' with: {}", indexName, settingsJson);
         // TODO: Implement update settings logic
         throw new UnsupportedOperationException("Update settings not yet implemented");
@@ -65,7 +65,7 @@ public class IndexManager {
     /**
      * Get index mappings.
      */
-    public String getMapping(String indexName) {
+    public String getMapping(String clusterId, String indexName) {
         log.info("Getting mapping for index: {}", indexName);
         // TODO: Implement get mapping logic
         throw new UnsupportedOperationException("Get mapping not yet implemented");
@@ -74,7 +74,7 @@ public class IndexManager {
     /**
      * Update index mappings.
      */
-    public void updateMapping(String indexName, String mappingsJson) {
+    public void updateMapping(String clusterId, String indexName, String mappingsJson) {
         log.info("Updating mapping for index '{}' with: {}", indexName, mappingsJson);
         // TODO: Implement update mapping logic
         throw new UnsupportedOperationException("Update mapping not yet implemented");
diff --git a/src/main/java/io/clustercontroller/models/SearchUnit.java b/src/main/java/io/clustercontroller/models/SearchUnit.java
index e4b528f..39a43b2 100644
--- a/src/main/java/io/clustercontroller/models/SearchUnit.java
+++ b/src/main/java/io/clustercontroller/models/SearchUnit.java
@@ -1,7 +1,7 @@
 package io.clustercontroller.models;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
-import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.HealthState;import io.clustercontroller.enums.NodeRole;
 import lombok.Data;
 import lombok.NoArgsConstructor;
 
diff --git a/src/main/java/io/clustercontroller/models/TaskMetadata.java b/src/main/java/io/clustercontroller/models/TaskMetadata.java
index 068e2bf..0ed708e 100644
--- a/src/main/java/io/clustercontroller/models/TaskMetadata.java
+++ b/src/main/java/io/clustercontroller/models/TaskMetadata.java
@@ -49,3 +49,4 @@ public class TaskMetadata {
         this.priority = priority;
     }
 }
+
diff --git a/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java b/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
index 08dabbe..4b37b55 100644
--- a/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
+++ b/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
@@ -42,7 +42,6 @@ public class EtcdMetadataStore implements MetadataStore {
     
     private static EtcdMetadataStore instance;
     
-    private final String clusterName;
     private final String[] etcdEndpoints;
     private final Client etcdClient;
     private final KV kvClient;
@@ -56,8 +55,7 @@ public class EtcdMetadataStore implements MetadataStore {
     /**
      * Private constructor for singleton pattern
      */
-    private EtcdMetadataStore(String clusterName, String[] etcdEndpoints) throws Exception {
-        this.clusterName = clusterName;
+    private EtcdMetadataStore(String[] etcdEndpoints) throws Exception {
         this.etcdEndpoints = etcdEndpoints;
         this.nodeId = EnvironmentUtils.getRequiredEnv("NODE_NAME");
         
@@ -71,10 +69,10 @@ public class EtcdMetadataStore implements MetadataStore {
         this.kvClient = etcdClient.getKVClient();
         
         // Initialize path resolver
-        this.pathResolver = new EtcdPathResolver(clusterName);
+        this.pathResolver = EtcdPathResolver.getInstance();
         
         log.info("EtcdMetadataStore initialized for cluster: {} with endpoints: {} and nodeId: {}", 
-            clusterName, String.join(",", etcdEndpoints), nodeId);
+            String.join(",", etcdEndpoints), nodeId);
     }
     
     // =================================================================
@@ -84,8 +82,7 @@ public class EtcdMetadataStore implements MetadataStore {
     /**
      * Test constructor with injected dependencies
      */
-    private EtcdMetadataStore(String clusterName, String[] etcdEndpoints, String nodeId, Client etcdClient, KV kvClient) {
-        this.clusterName = clusterName;
+    private EtcdMetadataStore(String[] etcdEndpoints, String nodeId, Client etcdClient, KV kvClient) {
         this.etcdEndpoints = etcdEndpoints;
         this.nodeId = nodeId;
         this.etcdClient = etcdClient;
@@ -97,16 +94,16 @@ public class EtcdMetadataStore implements MetadataStore {
                 .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
         
         // Initialize path resolver
-        this.pathResolver = new EtcdPathResolver(clusterName);
+        this.pathResolver = EtcdPathResolver.getInstance();
         
-        log.info("EtcdMetadataStore initialized for testing with cluster: {} and nodeId: {}", clusterName, nodeId);
+        log.info("EtcdMetadataStore initialized for testing with cluster: {} and nodeId: {}", "test-cluster", nodeId);
     }
     /**
      * Get singleton instance
      */
-    public static synchronized EtcdMetadataStore getInstance(String clusterName, String[] etcdEndpoints) throws Exception {
+    public static synchronized EtcdMetadataStore getInstance(String[] etcdEndpoints) throws Exception {
         if (instance == null) {
-            instance = new EtcdMetadataStore(clusterName, etcdEndpoints);
+            instance = new EtcdMetadataStore(etcdEndpoints);
         }
         return instance;
     }
@@ -116,7 +113,7 @@ public class EtcdMetadataStore implements MetadataStore {
      */
     public static EtcdMetadataStore getInstance() {
         if (instance == null) {
-            throw new IllegalStateException("EtcdMetadataStore not initialized. Call getInstance(clusterName, etcdEndpoints) first.");
+            throw new IllegalStateException("EtcdMetadataStore not initialized. Call getInstance(etcdEndpoints) first.");
         }
         return instance;
     }
@@ -131,9 +128,9 @@ public class EtcdMetadataStore implements MetadataStore {
     /**
      * Create test instance with mocked dependencies (for testing only)
      */
-    public static synchronized EtcdMetadataStore createTestInstance(String clusterName, String[] etcdEndpoints, String nodeId, Client etcdClient, KV kvClient) {
+    public static synchronized EtcdMetadataStore createTestInstance(String[] etcdEndpoints, String nodeId, Client etcdClient, KV kvClient) {
         resetInstance();
-        instance = new EtcdMetadataStore(clusterName, etcdEndpoints, nodeId, etcdClient, kvClient);
+        instance = new EtcdMetadataStore(etcdEndpoints, nodeId, etcdClient, kvClient);
         return instance;
     }
 
@@ -142,12 +139,11 @@ public class EtcdMetadataStore implements MetadataStore {
     // CONTROLLER TASKS OPERATIONS
     // =================================================================
     
-    @Override
-    public List<TaskMetadata> getAllTasks() throws Exception {
+    public List<TaskMetadata> getAllTasks(String clusterId) throws Exception {
         log.debug("Getting all tasks from etcd");
         
         try {
-            String tasksPrefix = pathResolver.getControllerTasksPrefix();
+            String tasksPrefix = pathResolver.getControllerTasksPrefix(clusterId);
             List<TaskMetadata> tasks = getAllObjectsByPrefix(tasksPrefix, TaskMetadata.class);
             
             // Sort by priority (0 = highest priority)
@@ -162,12 +158,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public Optional<TaskMetadata> getTask(String taskName) throws Exception {
+    public Optional<TaskMetadata> getTask(String clusterId, String taskName) throws Exception {
         log.debug("Getting task {} from etcd", taskName);
         
         try {
-            String taskPath = pathResolver.getControllerTaskPath(taskName);
+            String taskPath = pathResolver.getControllerTaskPath(clusterId, taskName);
             Optional<TaskMetadata> result = getObjectByPath(taskPath, TaskMetadata.class);
             
             if (result.isPresent()) {
@@ -184,12 +179,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public String createTask(TaskMetadata task) throws Exception {
+    public String createTask(String clusterId, TaskMetadata task) throws Exception {
         log.info("Creating task {} in etcd", task.getName());
         
         try {
-            String taskPath = pathResolver.getControllerTaskPath(task.getName());
+            String taskPath = pathResolver.getControllerTaskPath(clusterId, task.getName());
             storeObjectAsJson(taskPath, task);
             
             log.info("Successfully created task {} in etcd", task.getName());
@@ -201,12 +195,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void updateTask(TaskMetadata task) throws Exception {
+    public void updateTask(String clusterId, TaskMetadata task) throws Exception {
         log.debug("Updating task {} in etcd", task.getName());
         
         try {
-            String taskPath = pathResolver.getControllerTaskPath(task.getName());
+            String taskPath = pathResolver.getControllerTaskPath(clusterId, task.getName());
             storeObjectAsJson(taskPath, task);
             
             log.debug("Successfully updated task {} in etcd", task.getName());
@@ -217,12 +210,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void deleteTask(String taskName) throws Exception {
+    public void deleteTask(String clusterId, String taskName) throws Exception {
         log.info("Deleting task {} from etcd", taskName);
         
         try {
-            String taskPath = pathResolver.getControllerTaskPath(taskName);
+            String taskPath = pathResolver.getControllerTaskPath(clusterId, taskName);
             executeEtcdDelete(taskPath);
             
             log.info("Successfully deleted task {} from etcd", taskName);
@@ -233,7 +225,6 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
     public void deleteOldTasks(long olderThanTimestamp) throws Exception {
         log.debug("Deleting old tasks from etcd older than {}", olderThanTimestamp);
         // TODO: Implement etcd cleanup for old tasks
@@ -243,12 +234,11 @@ public class EtcdMetadataStore implements MetadataStore {
     // SEARCH UNITS OPERATIONS
     // =================================================================
     
-    @Override
-    public List<SearchUnit> getAllSearchUnits() throws Exception {
+    public List<SearchUnit> getAllSearchUnits(String clusterId) throws Exception {
         log.debug("Getting all search units from etcd");
         
         try {
-            String unitsPrefix = pathResolver.getSearchUnitsPrefix();
+            String unitsPrefix = pathResolver.getSearchUnitsPrefix(clusterId);
             List<SearchUnit> searchUnits = getAllObjectsByPrefix(unitsPrefix, SearchUnit.class);
             
             log.debug("Retrieved {} search units from etcd", searchUnits.size());
@@ -260,12 +250,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public Optional<SearchUnit> getSearchUnit(String unitName) throws Exception {
+    public Optional<SearchUnit> getSearchUnit(String clusterId, String unitName) throws Exception {
         log.debug("Getting search unit {} from etcd", unitName);
         
         try {
-            String unitPath = pathResolver.getSearchUnitConfPath(unitName);
+            String unitPath = pathResolver.getSearchUnitConfPath(clusterId, unitName);
             Optional<SearchUnit> result = getObjectByPath(unitPath, SearchUnit.class);
             
             if (result.isPresent()) {
@@ -282,12 +271,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void upsertSearchUnit(String unitName, SearchUnit searchUnit) throws Exception {
+    public void upsertSearchUnit(String clusterId, String unitName, SearchUnit searchUnit) throws Exception {
         log.info("Upserting search unit {} in etcd", unitName);
         
         try {
-            String unitPath = pathResolver.getSearchUnitConfPath(unitName);
+            String unitPath = pathResolver.getSearchUnitConfPath(clusterId, unitName);
             storeObjectAsJson(unitPath, searchUnit);
             
             log.info("Successfully upserted search unit {} in etcd", unitName);
@@ -298,12 +286,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void updateSearchUnit(SearchUnit searchUnit) throws Exception {
+    public void updateSearchUnit(String clusterId, SearchUnit searchUnit) throws Exception {
         log.debug("Updating search unit {} in etcd", searchUnit.getName());
         
         try {
-            String unitPath = pathResolver.getSearchUnitConfPath(searchUnit.getName());
+            String unitPath = pathResolver.getSearchUnitConfPath(clusterId, searchUnit.getName());
             storeObjectAsJson(unitPath, searchUnit);
             
             log.debug("Successfully updated search unit {} in etcd", searchUnit.getName());
@@ -314,12 +301,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void deleteSearchUnit(String unitName) throws Exception {
+    public void deleteSearchUnit(String clusterId, String unitName) throws Exception {
         log.info("Deleting search unit {} from etcd", unitName);
         
         try {
-            String unitPath = pathResolver.getSearchUnitConfPath(unitName);
+            String unitPath = pathResolver.getSearchUnitConfPath(clusterId, unitName);
             executeEtcdDelete(unitPath);
             
             log.info("Successfully deleted search unit {} from etcd", unitName);
@@ -334,9 +320,8 @@ public class EtcdMetadataStore implements MetadataStore {
     // SEARCH UNIT STATE OPERATIONS (for discovery)
     // =================================================================
     
-    @Override
-    public Map<String, SearchUnitActualState> getAllSearchUnitActualStates() throws Exception {
-        String prefix = pathResolver.getSearchUnitsPrefix();
+    public Map<String, SearchUnitActualState> getAllSearchUnitActualStates(String clusterId) throws Exception {
+        String prefix = pathResolver.getSearchUnitsPrefix(clusterId);
         GetOption option = GetOption.newBuilder()
                 .withPrefix(ByteSequence.from(prefix, UTF_8))
                 .build();
@@ -369,9 +354,8 @@ public class EtcdMetadataStore implements MetadataStore {
         return actualStates;
     }
     
-    @Override
-    public Optional<SearchUnitGoalState> getSearchUnitGoalState(String unitName) throws Exception {
-        String key = pathResolver.getSearchUnitGoalStatePath(unitName);
+    public Optional<SearchUnitGoalState> getSearchUnitGoalState(String clusterId, String unitName) throws Exception {
+        String key = pathResolver.getSearchUnitGoalStatePath(clusterId, unitName);
         CompletableFuture<GetResponse> getFuture = kvClient.get(ByteSequence.from(key, UTF_8));
         GetResponse response = getFuture.get();
         
@@ -385,9 +369,8 @@ public class EtcdMetadataStore implements MetadataStore {
         return Optional.of(goalState);
     }
     
-    @Override
-    public Optional<SearchUnitActualState> getSearchUnitActualState(String unitName) throws Exception {
-        String key = pathResolver.getSearchUnitActualStatePath(unitName);
+    public Optional<SearchUnitActualState> getSearchUnitActualState(String clusterId, String unitName) throws Exception {
+        String key = pathResolver.getSearchUnitActualStatePath(clusterId, unitName);
         CompletableFuture<GetResponse> getFuture = kvClient.get(ByteSequence.from(key, UTF_8));
         GetResponse response = getFuture.get();
         
@@ -404,12 +387,11 @@ public class EtcdMetadataStore implements MetadataStore {
     // INDEX CONFIGURATIONS OPERATIONS
     // =================================================================
     
-    @Override
-    public List<String> getAllIndexConfigs() throws Exception {
+    public List<String> getAllIndexConfigs(String clusterId) throws Exception {
         log.debug("Getting all index configs from etcd");
         
         try {
-            String indicesPrefix = pathResolver.getIndicesPrefix();
+            String indicesPrefix = pathResolver.getIndicesPrefix(clusterId);
             GetResponse response = executeEtcdPrefixQuery(indicesPrefix);
             
             List<String> indexConfigs = new ArrayList<>();
@@ -427,12 +409,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public Optional<String> getIndexConfig(String indexName) throws Exception {
+    public Optional<String> getIndexConfig(String clusterId, String indexName) throws Exception {
         log.debug("Getting index config {} from etcd", indexName);
         
         try {
-            String indexPath = pathResolver.getIndexConfPath(indexName);
+            String indexPath = pathResolver.getIndexConfPath(clusterId, indexName);
             GetResponse response = executeEtcdGet(indexPath);
             
             if (response.getCount() == 0) {
@@ -451,12 +432,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public String createIndexConfig(String indexName, String indexConfig) throws Exception {
+    public String createIndexConfig(String clusterId, String indexName, String indexConfig) throws Exception {
         log.info("Creating index config {} in etcd", indexName);
         
         try {
-            String indexPath = pathResolver.getIndexConfPath(indexName);
+            String indexPath = pathResolver.getIndexConfPath(clusterId, indexName);
             executeEtcdPut(indexPath, indexConfig);
             
             log.info("Successfully created index config {} in etcd", indexName);
@@ -468,12 +448,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void updateIndexConfig(String indexName, String indexConfig) throws Exception {
+    public void updateIndexConfig(String clusterId, String indexName, String indexConfig) throws Exception {
         log.debug("Updating index config {} in etcd", indexName);
         
         try {
-            String indexPath = pathResolver.getIndexConfPath(indexName);
+            String indexPath = pathResolver.getIndexConfPath(clusterId, indexName);
             executeEtcdPut(indexPath, indexConfig);
             
             log.debug("Successfully updated index config {} in etcd", indexName);
@@ -484,12 +463,11 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public void deleteIndexConfig(String indexName) throws Exception {
+    public void deleteIndexConfig(String clusterId, String indexName) throws Exception {
         log.info("Deleting index config {} from etcd", indexName);
         
         try {
-            String indexPath = pathResolver.getIndexConfPath(indexName);
+            String indexPath = pathResolver.getIndexConfPath(clusterId, indexName);
             executeEtcdDelete(indexPath);
             
             log.info("Successfully deleted index config {} from etcd", indexName);
@@ -504,14 +482,12 @@ public class EtcdMetadataStore implements MetadataStore {
     // CLUSTER OPERATIONS
     // =================================================================
     
-    @Override
     public void initialize() throws Exception {
         log.info("Initialize called - already done in constructor");
         // Start leader election process
         startLeaderElection();
     }
     
-    @Override
     public void close() throws Exception {
         log.info("Closing etcd metadata store");
         
@@ -526,10 +502,6 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
-    @Override
-    public String getClusterName() {
-        return clusterName;
-    }
     
     /**
      * Get the path resolver for external use
@@ -633,8 +605,9 @@ public class EtcdMetadataStore implements MetadataStore {
     // CONTROLLER TASKS OPERATIONS
     // =================================================================
     public CompletableFuture<Boolean> startLeaderElection() {
+        // TODO: Implement distributed locking mechanism and leader election support for multiple OS clusters in future
         Election election = etcdClient.getElectionClient();
-        String electionKey = clusterName + ELECTION_KEY_SUFFIX;
+        String electionKey = io.clustercontroller.config.Constants.DEFAULT_CLUSTER_NAME + ELECTION_KEY_SUFFIX;
 
         CompletableFuture<Boolean> result = new CompletableFuture<>();
 
@@ -650,15 +623,12 @@ public class EtcdMetadataStore implements MetadataStore {
                 long leaseId = leaseGrant.getID();
 
                 etcdClient.getLeaseClient().keepAlive(leaseId, new StreamObserver<LeaseKeepAliveResponse>() {
-                    @Override
                     public void onNext(LeaseKeepAliveResponse res) {}
-                    @Override
                     public void onError(Throwable t) {
                         log.error("KeepAlive error: {}", t.getMessage());
                         isLeader.set(false);
                         result.completeExceptionally(t);
                     }
-                    @Override
                     public void onCompleted() {
                         isLeader.set(false);
                     }
diff --git a/src/main/java/io/clustercontroller/store/EtcdPathResolver.java b/src/main/java/io/clustercontroller/store/EtcdPathResolver.java
index 0d7b000..2e454d3 100644
--- a/src/main/java/io/clustercontroller/store/EtcdPathResolver.java
+++ b/src/main/java/io/clustercontroller/store/EtcdPathResolver.java
@@ -5,17 +5,24 @@ import java.nio.file.Paths;
 import static io.clustercontroller.config.Constants.*;
 
 /**
- * Centralized etcd path resolver for all metadata keys.
+ * Centralized etcd path resolver for all metadata keys with multi-cluster support.
  * Provides consistent path structure for tasks, search units, indices, and other cluster metadata.
+ * All methods accept dynamic cluster names to support multi-cluster operations.
+ * Stateless singleton - no cluster-specific state stored.
  */
 public class EtcdPathResolver {
     
     private static final String PATH_DELIMITER = "/";
     
-    private final String clusterName;
+    // Singleton instance - stateless
+    private static final EtcdPathResolver INSTANCE = new EtcdPathResolver();
     
-    public EtcdPathResolver(String clusterName) {
-        this.clusterName = clusterName;
+    private EtcdPathResolver() {
+        // Private constructor for singleton
+    }
+    
+    public static EtcdPathResolver getInstance() {
+        return INSTANCE;
     }
     
     // =================================================================
@@ -26,7 +33,7 @@ public class EtcdPathResolver {
      * Get prefix for all controller tasks
      * Pattern: /<cluster-name>/ctl-tasks
      */
-    public String getControllerTasksPrefix() {
+    public String getControllerTasksPrefix(String clusterName) {
         return Paths.get(PATH_DELIMITER, clusterName, PATH_CTL_TASKS).toString();
     }
     
@@ -34,8 +41,8 @@ public class EtcdPathResolver {
      * Get path for specific controller task
      * Pattern: /<cluster-name>/ctl-tasks/<task-name>
      */
-    public String getControllerTaskPath(String taskName) {
-        return Paths.get(getControllerTasksPrefix(), taskName).toString();
+    public String getControllerTaskPath(String clusterName, String taskName) {
+        return Paths.get(getControllerTasksPrefix(clusterName), taskName).toString();
     }
     
     // =================================================================
@@ -46,7 +53,7 @@ public class EtcdPathResolver {
      * Get prefix for all search units
      * Pattern: /<cluster-name>/search-units
      */
-    public String getSearchUnitsPrefix() {
+    public String getSearchUnitsPrefix(String clusterName) {
         return Paths.get(PATH_DELIMITER, clusterName, PATH_SEARCH_UNITS).toString();
     }
     
@@ -54,27 +61,26 @@ public class EtcdPathResolver {
      * Get search unit configuration path
      * Pattern: /<cluster-name>/search-units/<unit-name>/conf
      */
-    public String getSearchUnitConfPath(String unitName) {
-        return Paths.get(getSearchUnitsPrefix(), unitName, SUFFIX_CONF).toString();
+    public String getSearchUnitConfPath(String clusterName, String unitName) {
+        return Paths.get(getSearchUnitsPrefix(clusterName), unitName, SUFFIX_CONF).toString();
     }
     
     /**
      * Get search unit goal state path
      * Pattern: /<cluster-name>/search-units/<unit-name>/goal-state
      */
-    public String getSearchUnitGoalStatePath(String unitName) {
-        return Paths.get(getSearchUnitsPrefix(), unitName, SUFFIX_GOAL_STATE).toString();
+    public String getSearchUnitGoalStatePath(String clusterName, String unitName) {
+        return Paths.get(getSearchUnitsPrefix(clusterName), unitName, SUFFIX_GOAL_STATE).toString();
     }
     
     /**
      * Get search unit actual state path
      * Pattern: /<cluster-name>/search-units/<unit-name>/actual-state
      */
-    public String getSearchUnitActualStatePath(String unitName) {
-        return Paths.get(getSearchUnitsPrefix(), unitName, SUFFIX_ACTUAL_STATE).toString();
+    public String getSearchUnitActualStatePath(String clusterName, String unitName) {
+        return Paths.get(getSearchUnitsPrefix(clusterName), unitName, SUFFIX_ACTUAL_STATE).toString();
     }
     
-    
     // =================================================================
     // INDEX PATHS
     // =================================================================
@@ -83,7 +89,7 @@ public class EtcdPathResolver {
      * Get prefix for all indices
      * Pattern: /<cluster-name>/indices
      */
-    public String getIndicesPrefix() {
+    public String getIndicesPrefix(String clusterName) {
         return Paths.get(PATH_DELIMITER, clusterName, PATH_INDICES).toString();
     }
     
@@ -91,24 +97,24 @@ public class EtcdPathResolver {
      * Get index configuration path
      * Pattern: /<cluster-name>/indices/<index-name>/conf
      */
-    public String getIndexConfPath(String indexName) {
-        return Paths.get(getIndicesPrefix(), indexName, SUFFIX_CONF).toString();
+    public String getIndexConfPath(String clusterName, String indexName) {
+        return Paths.get(getIndicesPrefix(clusterName), indexName, SUFFIX_CONF).toString();
     }
     
     /**
      * Get index mappings path
      * Pattern: /<cluster-name>/indices/<index-name>/mappings
      */
-    public String getIndexMappingsPath(String indexName) {
-        return Paths.get(getIndicesPrefix(), indexName, SUFFIX_MAPPINGS).toString();
+    public String getIndexMappingsPath(String clusterName, String indexName) {
+        return Paths.get(getIndicesPrefix(clusterName), indexName, SUFFIX_MAPPINGS).toString();
     }
     
     /**
      * Get index settings path
      * Pattern: /<cluster-name>/indices/<index-name>/settings
      */
-    public String getIndexSettingsPath(String indexName) {
-        return Paths.get(getIndicesPrefix(), indexName, SUFFIX_SETTINGS).toString();
+    public String getIndexSettingsPath(String clusterName, String indexName) {
+        return Paths.get(getIndicesPrefix(clusterName), indexName, SUFFIX_SETTINGS).toString();
     }
     
     // =================================================================
@@ -119,16 +125,16 @@ public class EtcdPathResolver {
      * Get shard planned allocation path
      * Pattern: /<cluster-name>/indices/<index-name>/shard/<shard-id>/planned-allocation
      */
-    public String getShardPlannedAllocationPath(String indexName, String shardId) {
-        return Paths.get(getIndicesPrefix(), indexName, PATH_SHARD, shardId, SUFFIX_PLANNED_ALLOCATION).toString();
+    public String getShardPlannedAllocationPath(String clusterName, String indexName, String shardId) {
+        return Paths.get(getIndicesPrefix(clusterName), indexName, PATH_SHARD, shardId, SUFFIX_PLANNED_ALLOCATION).toString();
     }
     
     /**
      * Get shard actual allocation path
      * Pattern: /<cluster-name>/indices/<index-name>/shard/<shard-id>/actual-allocation
      */
-    public String getShardActualAllocationPath(String indexName, String shardId) {
-        return Paths.get(getIndicesPrefix(), indexName, PATH_SHARD, shardId, SUFFIX_ACTUAL_ALLOCATION).toString();
+    public String getShardActualAllocationPath(String clusterName, String indexName, String shardId) {
+        return Paths.get(getIndicesPrefix(clusterName), indexName, PATH_SHARD, shardId, SUFFIX_ACTUAL_ALLOCATION).toString();
     }
     
     // =================================================================
@@ -139,7 +145,7 @@ public class EtcdPathResolver {
      * Get prefix for all coordinators
      * Pattern: /<cluster-name>/coordinators
      */
-    public String getCoordinatorsPrefix() {
+    public String getCoordinatorsPrefix(String clusterName) {
         return Paths.get(PATH_DELIMITER, clusterName, PATH_COORDINATORS).toString();
     }
     
@@ -147,19 +153,18 @@ public class EtcdPathResolver {
      * Get shared coordinator goal state path (common for all coordinators)
      * Pattern: /<cluster-name>/coordinators/goal-state
      */
-    public String getCoordinatorGoalStatePath() {
-        return Paths.get(getCoordinatorsPrefix(), SUFFIX_GOAL_STATE).toString();
+    public String getCoordinatorGoalStatePath(String clusterName) {
+        return Paths.get(getCoordinatorsPrefix(clusterName), SUFFIX_GOAL_STATE).toString();
     }
     
     /**
      * Get coordinator actual state path (per-coordinator reporting)
      * Pattern: /<cluster-name>/coordinators/<coordinator-name>/actual-state
      */
-    public String getCoordinatorActualStatePath(String coordinatorName) {
-        return Paths.get(getCoordinatorsPrefix(), coordinatorName, SUFFIX_ACTUAL_STATE).toString();
+    public String getCoordinatorActualStatePath(String clusterName, String coordinatorName) {
+        return Paths.get(getCoordinatorsPrefix(clusterName), coordinatorName, SUFFIX_ACTUAL_STATE).toString();
     }
     
-    
     // =================================================================
     // LEADER ELECTION PATHS
     // =================================================================
@@ -168,7 +173,7 @@ public class EtcdPathResolver {
      * Get leader election path
      * Pattern: /<cluster-name>/leader-election
      */
-    public String getLeaderElectionPath() {
+    public String getLeaderElectionPath(String clusterName) {
         return Paths.get(PATH_DELIMITER, clusterName, PATH_LEADER_ELECTION).toString();
     }
     
@@ -180,14 +185,7 @@ public class EtcdPathResolver {
      * Get cluster root path
      * Pattern: /<cluster-name>
      */
-    public String getClusterRoot() {
+    public String getClusterRoot(String clusterName) {
         return Paths.get(PATH_DELIMITER, clusterName).toString();
     }
-    
-    /**
-     * Get cluster name
-     */
-    public String getClusterName() {
-        return clusterName;
-    }
 }
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/store/MetadataStore.java b/src/main/java/io/clustercontroller/store/MetadataStore.java
index df2e220..b8a72ef 100644
--- a/src/main/java/io/clustercontroller/store/MetadataStore.java
+++ b/src/main/java/io/clustercontroller/store/MetadataStore.java
@@ -21,27 +21,27 @@ public interface MetadataStore {
     /**
      * Get all controller tasks sorted by priority
      */
-    List<TaskMetadata> getAllTasks() throws Exception;
+    List<TaskMetadata> getAllTasks(String clusterId) throws Exception;
     
     /**
      * Get task by name
      */
-    Optional<TaskMetadata> getTask(String taskName) throws Exception;
+    Optional<TaskMetadata> getTask(String clusterId, String taskName) throws Exception;
     
     /**
      * Create new task
      */
-    String createTask(TaskMetadata task) throws Exception;
+    String createTask(String clusterId, TaskMetadata task) throws Exception;
     
     /**
      * Update existing task
      */
-    void updateTask(TaskMetadata task) throws Exception;
+    void updateTask(String clusterId, TaskMetadata task) throws Exception;
     
     /**
      * Delete task
      */
-    void deleteTask(String taskName) throws Exception;
+    void deleteTask(String clusterId, String taskName) throws Exception;
     
     /**
      * Delete old completed tasks (cleanup)
@@ -55,27 +55,27 @@ public interface MetadataStore {
     /**
      * Get all search units
      */
-    List<SearchUnit> getAllSearchUnits() throws Exception;
+    List<SearchUnit> getAllSearchUnits(String clusterId) throws Exception;
     
     /**
      * Get search unit by name
      */
-    Optional<SearchUnit> getSearchUnit(String unitName) throws Exception;
+    Optional<SearchUnit> getSearchUnit(String clusterId, String unitName) throws Exception;
     
     /**
      * Create or update search unit
      */
-    void upsertSearchUnit(String unitName, SearchUnit searchUnit) throws Exception;
+    void upsertSearchUnit(String clusterId, String unitName, SearchUnit searchUnit) throws Exception;
     
     /**
      * Update search unit
      */
-    void updateSearchUnit(SearchUnit searchUnit) throws Exception;
+    void updateSearchUnit(String clusterId, SearchUnit searchUnit) throws Exception;
     
     /**
      * Delete search unit
      */
-    void deleteSearchUnit(String unitName) throws Exception;
+    void deleteSearchUnit(String clusterId, String unitName) throws Exception;
     
     // =================================================================
     // SEARCH UNIT STATE OPERATIONS (for discovery)
@@ -84,17 +84,17 @@ public interface MetadataStore {
     /**
      * Get all search unit actual states (for discovery)
      */
-    Map<String, SearchUnitActualState> getAllSearchUnitActualStates() throws Exception;
+    Map<String, SearchUnitActualState> getAllSearchUnitActualStates(String clusterId) throws Exception;
     
     /**
      * Get search unit goal state
      */
-    Optional<SearchUnitGoalState> getSearchUnitGoalState(String unitName) throws Exception;
+    Optional<SearchUnitGoalState> getSearchUnitGoalState(String clusterId, String unitName) throws Exception;
     
     /**
      * Get search unit actual state
      */
-    Optional<SearchUnitActualState> getSearchUnitActualState(String unitName) throws Exception;
+    Optional<SearchUnitActualState> getSearchUnitActualState(String clusterId, String unitName) throws Exception;
     // =================================================================
     // INDEX CONFIGURATIONS OPERATIONS
     // =================================================================
@@ -102,27 +102,27 @@ public interface MetadataStore {
     /**
      * Get all index configurations
      */
-    List<String> getAllIndexConfigs() throws Exception;
+    List<String> getAllIndexConfigs(String clusterId) throws Exception;
     
     /**
      * Get index configuration by name
      */
-    Optional<String> getIndexConfig(String indexName) throws Exception;
+    Optional<String> getIndexConfig(String clusterId, String indexName) throws Exception;
     
     /**
      * Create new index configuration
      */
-    String createIndexConfig(String indexName, String indexConfig) throws Exception;
+    String createIndexConfig(String clusterId, String indexName, String indexConfig) throws Exception;
     
     /**
      * Update index configuration
      */
-    void updateIndexConfig(String indexName, String indexConfig) throws Exception;
+    void updateIndexConfig(String clusterId, String indexName, String indexConfig) throws Exception;
     
     /**
      * Delete index configuration
      */
-    void deleteIndexConfig(String indexName) throws Exception;
+    void deleteIndexConfig(String clusterId, String indexName) throws Exception;
     
     // =================================================================
     // CLUSTER OPERATIONS
@@ -141,5 +141,4 @@ public interface MetadataStore {
     /**
      * Get the cluster name this metadata store is connected to
      */
-    String getClusterName();
 }
diff --git a/src/main/java/io/clustercontroller/tasks/Task.java b/src/main/java/io/clustercontroller/tasks/Task.java
index 6b01dfb..b095a2c 100644
--- a/src/main/java/io/clustercontroller/tasks/Task.java
+++ b/src/main/java/io/clustercontroller/tasks/Task.java
@@ -31,3 +31,4 @@ public interface Task {
      */
     String getSchedule();
 }
+
diff --git a/src/main/java/io/clustercontroller/tasks/TaskContext.java b/src/main/java/io/clustercontroller/tasks/TaskContext.java
index c234fbf..b181485 100644
--- a/src/main/java/io/clustercontroller/tasks/TaskContext.java
+++ b/src/main/java/io/clustercontroller/tasks/TaskContext.java
@@ -19,3 +19,4 @@ public class TaskContext {
     private final ShardAllocator shardAllocator;
     private final ActualAllocationUpdater actualAllocationUpdater;
 }
+
diff --git a/src/main/java/io/clustercontroller/tasks/TaskFactory.java b/src/main/java/io/clustercontroller/tasks/TaskFactory.java
index 31b5cdd..7252da6 100644
--- a/src/main/java/io/clustercontroller/tasks/TaskFactory.java
+++ b/src/main/java/io/clustercontroller/tasks/TaskFactory.java
@@ -19,18 +19,6 @@ public class TaskFactory {
         String taskName = metadata.getName();
         
         return switch (taskName) {
-            case TASK_ACTION_CREATE_INDEX -> new CreateIndexTask(
-                metadata.getName(),
-                metadata.getPriority(),
-                metadata.getInput(),
-                metadata.getSchedule()
-            );
-            case TASK_ACTION_DELETE_INDEX -> new DeleteIndexTask(
-                metadata.getName(),
-                metadata.getPriority(),
-                metadata.getInput(),
-                metadata.getSchedule()
-            );
             case TASK_ACTION_DISCOVER_SEARCH_UNIT -> new DiscoverSearchUnitTask(
                 metadata.getName(),
                 metadata.getPriority(),
diff --git a/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java b/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java
index 4df7867..132c490 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java
@@ -34,3 +34,4 @@ public class ActualAllocationUpdaterTask implements Task {
         }
     }
 }
+
diff --git a/src/main/java/io/clustercontroller/tasks/impl/CreateIndexTask.java b/src/main/java/io/clustercontroller/tasks/impl/CreateIndexTask.java
deleted file mode 100644
index fb4df38..0000000
--- a/src/main/java/io/clustercontroller/tasks/impl/CreateIndexTask.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package io.clustercontroller.tasks.impl;
-
-import io.clustercontroller.tasks.Task;
-import io.clustercontroller.tasks.TaskContext;
-import lombok.AllArgsConstructor;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-
-import static io.clustercontroller.config.Constants.*;
-
-/**
- * Task implementation for creating indices.
- */
-@Slf4j
-@Getter
-@AllArgsConstructor
-public class CreateIndexTask implements Task {
-    
-    private final String name;
-    private final int priority;
-    private final String input;
-    private final String schedule;
-    
-    @Override
-    public String execute(TaskContext context) {
-        log.info("Executing create index task: {}", name);
-        
-        try {
-            context.getIndexManager().createIndex(input);
-            return TASK_STATUS_COMPLETED;
-        } catch (Exception e) {
-            log.error("Failed to execute create index task: {}", e.getMessage(), e);
-            return TASK_STATUS_FAILED;
-        }
-    }
-}
diff --git a/src/main/java/io/clustercontroller/tasks/impl/DeleteIndexTask.java b/src/main/java/io/clustercontroller/tasks/impl/DeleteIndexTask.java
deleted file mode 100644
index 6335e28..0000000
--- a/src/main/java/io/clustercontroller/tasks/impl/DeleteIndexTask.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package io.clustercontroller.tasks.impl;
-
-import io.clustercontroller.tasks.Task;
-import io.clustercontroller.tasks.TaskContext;
-import lombok.AllArgsConstructor;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-
-import static io.clustercontroller.config.Constants.*;
-
-/**
- * Task implementation for deleting indices.
- */
-@Slf4j
-@Getter
-@AllArgsConstructor
-public class DeleteIndexTask implements Task {
-    
-    private final String name;
-    private final int priority;
-    private final String input;
-    private final String schedule;
-    
-    @Override
-    public String execute(TaskContext context) {
-        log.info("Executing delete index task: {}", name);
-        
-        try {
-            context.getIndexManager().deleteIndex(input);
-            return TASK_STATUS_COMPLETED;
-        } catch (Exception e) {
-            log.error("Failed to execute delete index task: {}", e.getMessage(), e);
-            return TASK_STATUS_FAILED;
-        }
-    }
-}
diff --git a/src/main/java/io/clustercontroller/tasks/impl/DiscoverSearchUnitTask.java b/src/main/java/io/clustercontroller/tasks/impl/DiscoverSearchUnitTask.java
index 0df6de9..f5c1c6a 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/DiscoverSearchUnitTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/DiscoverSearchUnitTask.java
@@ -34,3 +34,4 @@ public class DiscoverSearchUnitTask implements Task {
         }
     }
 }
+
diff --git a/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java b/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java
index 28f91f6..c4ed834 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/PlanShardAllocationTask.java
@@ -27,6 +27,7 @@ public class PlanShardAllocationTask implements Task {
         
         try {
             // TODO: Call ShardAllocationPlanner.plan() method when implemented
+            log.info("Shard allocation planning - implementation pending");
             return TASK_STATUS_COMPLETED;
         } catch (Exception e) {
             log.error("Failed to execute plan shard allocation task: {}", e.getMessage(), e);
@@ -34,3 +35,4 @@ public class PlanShardAllocationTask implements Task {
         }
     }
 }
+
diff --git a/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java b/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java
index 2966e2d..9f2bb8b 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java
@@ -34,3 +34,4 @@ public class ShardAllocatorTask implements Task {
         }
     }
 }
+
diff --git a/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java b/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java
index f99543e..5f30307 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java
@@ -27,3 +27,4 @@ public class UnknownTask implements Task {
         return TASK_STATUS_FAILED;
     }
 }
+
diff --git a/src/main/java/io/clustercontroller/templates/TemplateManager.java b/src/main/java/io/clustercontroller/templates/TemplateManager.java
index 43513a7..48d3de8 100644
--- a/src/main/java/io/clustercontroller/templates/TemplateManager.java
+++ b/src/main/java/io/clustercontroller/templates/TemplateManager.java
@@ -4,44 +4,47 @@ import io.clustercontroller.store.MetadataStore;
 import lombok.extern.slf4j.Slf4j;
 
 /**
- * Manages index template operations.
+ * Manages index template operations with multi-cluster support.
+ * Provides methods for creating, deleting, and retrieving index templates.
+ * Index templates allow defining default settings, mappings, and aliases
+ * for new indices that match a specified pattern.
  */
 @Slf4j
 public class TemplateManager {
-    
+
     private final MetadataStore metadataStore;
-    
+
     public TemplateManager(MetadataStore metadataStore) {
         this.metadataStore = metadataStore;
     }
-    
-    public void putTemplate(String templateName, String templateConfig) {
-        log.info("Creating/updating template '{}' with config: {}", templateName, templateConfig);
-        // TODO: Implement template creation/update logic
+
+    public boolean templateExists(String clusterId, String templateName) {
+        log.info("Checking if template '{}' exists in cluster '{}'", templateName, clusterId);
+        // TODO: Implement template existence check - use clusterId
+        throw new UnsupportedOperationException("Template existence check not yet implemented");
+    }
+
+    public void putTemplate(String clusterId, String templateName, String templateConfig) {
+        log.info("Creating/updating template '{}' in cluster '{}' with config: {}", templateName, clusterId, templateConfig);
+        // TODO: Implement template creation/update logic - use clusterId
         throw new UnsupportedOperationException("Template creation not yet implemented");
     }
-    
-    public void deleteTemplate(String templateName) {
-        log.info("Deleting template '{}'", templateName);
-        // TODO: Implement template deletion logic
+
+    public void deleteTemplate(String clusterId, String templateName) {
+        log.info("Deleting template '{}' from cluster '{}'", templateName, clusterId);
+        // TODO: Implement template deletion logic - use clusterId
         throw new UnsupportedOperationException("Template deletion not yet implemented");
     }
-    
-    public String getTemplate(String templateName) {
-        log.info("Getting template '{}'", templateName);
-        // TODO: Implement get template logic
+
+    public String getTemplate(String clusterId, String templateName) {
+        log.info("Getting template '{}' from cluster '{}'", templateName, clusterId);
+        // TODO: Implement get template logic - use clusterId
         throw new UnsupportedOperationException("Get template not yet implemented");
     }
-    
-    public String getAllTemplates() {
-        log.info("Getting all templates");
-        // TODO: Implement get all templates logic
+
+    public String getAllTemplates(String clusterId) {
+        log.info("Getting all templates from cluster '{}'", clusterId);
+        // TODO: Implement get all templates logic - use clusterId
         throw new UnsupportedOperationException("Get all templates not yet implemented");
     }
-    
-    public boolean templateExists(String templateName) {
-        log.info("Checking if template '{}' exists", templateName);
-        // TODO: Implement template existence check
-        throw new UnsupportedOperationException("Template existence check not yet implemented");
-    }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/ClusterControllerApplicationTest.java b/src/test/java/io/clustercontroller/ClusterControllerApplicationTest.java
index 86653a6..f396fb4 100644
--- a/src/test/java/io/clustercontroller/ClusterControllerApplicationTest.java
+++ b/src/test/java/io/clustercontroller/ClusterControllerApplicationTest.java
@@ -52,8 +52,8 @@ class ClusterControllerApplicationTest {
         
         // Create test instance with mocked dependencies
         String testNodeId = "test-node-1";
-        etcdStore = EtcdMetadataStore.createTestInstance("test-cluster", 
-                new String[]{"http://localhost:2379"}, testNodeId, etcdClient, kvClient);
+        etcdStore = EtcdMetadataStore.createTestInstance(new String[]{"http://localhost:2379"}, 
+                testNodeId, etcdClient, kvClient);
     }
 
     @Test
@@ -205,8 +205,8 @@ class ClusterControllerApplicationTest {
         try {
             // If NODE_NAME happens to be set in test environment, this will succeed
             // If not set, this will throw IllegalStateException as expected
-            EtcdMetadataStore.createTestInstance("test-cluster-2", 
-                    new String[]{"http://localhost:2379"}, "test-node-2", etcdClient, kvClient);
+            EtcdMetadataStore.createTestInstance(new String[]{"http://localhost:2379"}, 
+                    "test-node-2", etcdClient, kvClient);
             
             // If we get here, NODE_NAME was set in the environment
             assertTrue(true, "NODE_NAME environment variable is set");
diff --git a/src/test/java/io/clustercontroller/TaskManagerTest.java b/src/test/java/io/clustercontroller/TaskManagerTest.java
index f31ad48..60f4036 100644
--- a/src/test/java/io/clustercontroller/TaskManagerTest.java
+++ b/src/test/java/io/clustercontroller/TaskManagerTest.java
@@ -8,97 +8,104 @@ import org.junit.jupiter.api.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.util.List;
+import java.time.OffsetDateTime;
+import java.util.Collections;
 import java.util.Optional;
 
-import static io.clustercontroller.config.Constants.*;
-import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.*;
 
-/**
- * Tests for TaskManager.
- */
 class TaskManagerTest {
-    
+
     @Mock
     private MetadataStore metadataStore;
-    
+
     @Mock
     private TaskContext taskContext;
-    
+
     private TaskManager taskManager;
-    
+    private final String testClusterId = "test-cluster";
+
     @BeforeEach
     void setUp() {
         MockitoAnnotations.openMocks(this);
-        
-        taskManager = new TaskManager(metadataStore, taskContext, 30L);
+        taskManager = new TaskManager(metadataStore, taskContext, testClusterId, 30L);
     }
-    
-    @Test
-    void testTaskManagerCreation() {
-        assertThat(taskManager).isNotNull();
-    }
-    
+
     @Test
-    void testCreateTask() throws Exception {
+    void testCreateTask_Success() throws Exception {
+        // Given
         String taskName = "test-task";
         String input = "test-input";
         int priority = 1;
-        
-        when(metadataStore.createTask(any(TaskMetadata.class))).thenReturn(taskName);
-        
-        TaskMetadata result = taskManager.createTask(taskName, input, priority);
-        
-        assertThat(result.getName()).isEqualTo(taskName);
-        assertThat(result.getInput()).isEqualTo(input);
-        assertThat(result.getPriority()).isEqualTo(priority);
-        assertThat(result.getStatus()).isEqualTo(TASK_STATUS_PENDING);
-        
-        verify(metadataStore).createTask(any(TaskMetadata.class));
+
+        when(metadataStore.createTask(anyString(), any(TaskMetadata.class))).thenReturn("task-id");
+
+        // When
+        TaskMetadata task = taskManager.createTask(taskName, input, priority);
+
+        // Then
+        assertThat(task).isNotNull();
+        assertThat(task.getName()).isEqualTo(taskName);
+        assertThat(task.getInput()).isEqualTo(input);
+        assertThat(task.getPriority()).isEqualTo(priority);
+
+        verify(metadataStore).createTask(eq(testClusterId), any(TaskMetadata.class));
     }
-    
+
     @Test
-    void testGetAllTasks() throws Exception {
-        List<TaskMetadata> mockTasks = List.of(
-            new TaskMetadata("task1", 1),
-            new TaskMetadata("task2", 2)
-        );
-        
-        when(metadataStore.getAllTasks()).thenReturn(mockTasks);
-        
-        List<TaskMetadata> result = taskManager.getAllTasks();
-        
-        assertThat(result).hasSize(2);
-        assertThat(result.get(0).getName()).isEqualTo("task1");
-        assertThat(result.get(1).getName()).isEqualTo("task2");
-        
-        verify(metadataStore).getAllTasks();
+    void testGetTasks_Success() throws Exception {
+        // Given
+        TaskMetadata task = new TaskMetadata();
+        task.setName("test-task");
+        task.setCreatedAt(OffsetDateTime.now());
+
+        when(metadataStore.getAllTasks(anyString())).thenReturn(Collections.singletonList(task));
+
+        // When
+        var tasks = taskManager.getAllTasks();
+
+        // Then
+        assertThat(tasks).hasSize(1);
+        assertThat(tasks.get(0).getName()).isEqualTo("test-task");
+
+        verify(metadataStore).getAllTasks(testClusterId);
     }
-    
+
     @Test
-    void testGetTask() throws Exception {
+    void testGetTaskByName_Found() throws Exception {
+        // Given
         String taskName = "test-task";
-        TaskMetadata mockTask = new TaskMetadata(taskName, 1);
-        
-        when(metadataStore.getTask(taskName)).thenReturn(Optional.of(mockTask));
-        
+        TaskMetadata task = new TaskMetadata();
+        task.setName(taskName);
+
+        when(metadataStore.getTask(anyString(), anyString())).thenReturn(Optional.of(task));
+
+        // When
         Optional<TaskMetadata> result = taskManager.getTask(taskName);
-        
+
+        // Then
         assertThat(result).isPresent();
         assertThat(result.get().getName()).isEqualTo(taskName);
-        
-        verify(metadataStore).getTask(taskName);
+
+        verify(metadataStore).getTask(testClusterId, taskName);
     }
-    
+
     @Test
-    void testDeleteTask() throws Exception {
-        String taskName = "test-task";
-        
-        doNothing().when(metadataStore).deleteTask(taskName);
-        
-        taskManager.deleteTask(taskName);
-        
-        verify(metadataStore).deleteTask(taskName);
+    void testGetTaskByName_NotFound() throws Exception {
+        // Given
+        String taskName = "missing-task";
+
+        when(metadataStore.getTask(anyString(), anyString())).thenReturn(Optional.empty());
+
+        // When
+        Optional<TaskMetadata> result = taskManager.getTask(taskName);
+
+        // Then
+        assertThat(result).isEmpty();
+
+        verify(metadataStore).getTask(testClusterId, taskName);
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java
index a9d2725..fc2d5a6 100644
--- a/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java
+++ b/src/test/java/io/clustercontroller/api/handlers/AliasHandlerTest.java
@@ -28,6 +28,8 @@ class AliasHandlerTest {
 
     @InjectMocks
     private AliasHandler aliasHandler;
+    
+    private final String testClusterId = "test-cluster";
 
     @BeforeEach
     void setUp() {
@@ -42,10 +44,10 @@ class AliasHandlerTest {
         AliasRequest request = AliasRequest.builder().build();
 
         when(objectMapper.writeValueAsString(any())).thenReturn("{}");
-        doNothing().when(aliasManager).createAlias(anyString(), anyString(), anyString());
+        doNothing().when(aliasManager).createAlias(anyString(), anyString(), anyString(), anyString());
 
         // When
-        ResponseEntity<Object> response = aliasHandler.createAlias(index, alias, request);
+        ResponseEntity<Object> response = aliasHandler.createAlias(testClusterId, index, alias, request);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -56,7 +58,7 @@ class AliasHandlerTest {
         assertThat(aliasResponse.getAlias()).isEqualTo(alias);
         assertThat(aliasResponse.getIndex()).isEqualTo(index);
 
-        verify(aliasManager).createAlias(alias, index, "{}");
+        verify(aliasManager).createAlias(testClusterId, alias, index, "{}");
     }
 
     @Test
@@ -68,10 +70,10 @@ class AliasHandlerTest {
 
         when(objectMapper.writeValueAsString(any())).thenReturn("{}");
         doThrow(new UnsupportedOperationException("Not implemented"))
-            .when(aliasManager).createAlias(anyString(), anyString(), anyString());
+            .when(aliasManager).createAlias(anyString(), anyString(), anyString(), anyString());
 
         // When
-        ResponseEntity<Object> response = aliasHandler.createAlias(index, alias, request);
+        ResponseEntity<Object> response = aliasHandler.createAlias(testClusterId, index, alias, request);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
@@ -82,39 +84,15 @@ class AliasHandlerTest {
         assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
 
-    @Test
-    void testCreateAlias_InternalError() throws Exception {
-        // Given
-        String index = "test-index";
-        String alias = "test-alias";
-        AliasRequest request = AliasRequest.builder().build();
-
-        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
-        doThrow(new RuntimeException("Database error"))
-            .when(aliasManager).createAlias(anyString(), anyString(), anyString());
-
-        // When
-        ResponseEntity<Object> response = aliasHandler.createAlias(index, alias, request);
-
-        // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
-        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-
-        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
-        assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
-        assertThat(errorResponse.getReason()).contains("Database error");
-        assertThat(errorResponse.getStatus()).isEqualTo(500);
-    }
-
     @Test
     void testDeleteAlias_Success() {
         // Given
         String index = "test-index";
         String alias = "test-alias";
-        doNothing().when(aliasManager).deleteAlias(anyString(), anyString());
+        doNothing().when(aliasManager).deleteAlias(anyString(), anyString(), anyString());
 
         // When
-        ResponseEntity<Object> response = aliasHandler.deleteAlias(index, alias);
+        ResponseEntity<Object> response = aliasHandler.deleteAlias(testClusterId, index, alias);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -125,38 +103,18 @@ class AliasHandlerTest {
         assertThat(aliasResponse.getAlias()).isEqualTo(alias);
         assertThat(aliasResponse.getIndex()).isEqualTo(index);
 
-        verify(aliasManager).deleteAlias(alias, index);
-    }
-
-    @Test
-    void testDeleteAlias_UnsupportedOperation() {
-        // Given
-        String index = "test-index";
-        String alias = "test-alias";
-        doThrow(new UnsupportedOperationException("Not implemented"))
-            .when(aliasManager).deleteAlias(anyString(), anyString());
-
-        // When
-        ResponseEntity<Object> response = aliasHandler.deleteAlias(index, alias);
-
-        // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
-        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-
-        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
-        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
-        assertThat(errorResponse.getStatus()).isEqualTo(501);
+        verify(aliasManager).deleteAlias(testClusterId, alias, index);
     }
 
     @Test
     void testGetAlias_NotImplemented() {
         // Given
         String alias = "test-alias";
-        when(aliasManager.getAlias(anyString()))
+        when(aliasManager.getAlias(anyString(), anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
 
         // When
-        ResponseEntity<Object> response = aliasHandler.getAlias(alias);
+        ResponseEntity<Object> response = aliasHandler.getAlias(testClusterId, alias);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
@@ -167,24 +125,4 @@ class AliasHandlerTest {
         assertThat(errorResponse.getReason()).contains("Get alias is not yet implemented");
         assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-
-    @Test
-    void testGetIndexAliases_NotImplemented() {
-        // Given
-        String index = "test-index";
-        when(aliasManager.getAlias(anyString()))
-            .thenThrow(new UnsupportedOperationException("Not implemented"));
-
-        // When
-        ResponseEntity<Object> response = aliasHandler.getIndexAliases(index);
-
-        // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
-        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-
-        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
-        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
-        assertThat(errorResponse.getReason()).contains("Get index aliases is not yet implemented");
-        assertThat(errorResponse.getStatus()).isEqualTo(501);
-    }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java
index d022ca6..2ac0609 100644
--- a/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java
+++ b/src/test/java/io/clustercontroller/api/handlers/HealthHandlerTest.java
@@ -5,124 +5,127 @@ import io.clustercontroller.health.ClusterHealthManager;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
 import org.mockito.Mock;
-import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.MockitoAnnotations;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.when;
 
-@ExtendWith(MockitoExtension.class)
 class HealthHandlerTest {
 
     @Mock
     private ClusterHealthManager healthManager;
-    
+
     @Mock
     private ObjectMapper objectMapper;
-    
+
+    @InjectMocks
     private HealthHandler healthHandler;
     
+    private final String testClusterId = "test-cluster";
+
     @BeforeEach
     void setUp() {
-        healthHandler = new HealthHandler(healthManager, objectMapper);
+        MockitoAnnotations.openMocks(this);
     }
-    
+
     @Test
     void testGetClusterHealth_NotImplemented() {
         // Given
-        when(healthManager.getClusterHealth("cluster"))
+        when(healthManager.getClusterHealth(anyString(), anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
-        
+
         // When
-        ResponseEntity<Object> response = healthHandler.getClusterHealth("cluster");
-        
+        ResponseEntity<Object> response = healthHandler.getClusterHealth(testClusterId, "cluster");
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-        
+
         ErrorResponse errorResponse = (ErrorResponse) response.getBody();
         assertThat(errorResponse.getError()).isEqualTo("not_implemented");
         assertThat(errorResponse.getReason()).contains("not yet implemented");
         assertThat(errorResponse.getStatus()).isEqualTo(501);
-        
-        verify(healthManager).getClusterHealth("cluster");
     }
-    
+
     @Test
     void testGetClusterHealth_WithCustomLevel() {
         // Given
-        when(healthManager.getClusterHealth("indices"))
+        when(healthManager.getClusterHealth(anyString(), anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
-        
+
         // When
-        ResponseEntity<Object> response = healthHandler.getClusterHealth("indices");
-        
+        ResponseEntity<Object> response = healthHandler.getClusterHealth(testClusterId, "indices");
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
-        verify(healthManager).getClusterHealth("indices");
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getReason()).contains("not yet implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-    
+
     @Test
     void testGetIndexHealth_NotImplemented() {
         // Given
         String indexName = "test-index";
-        
-        when(healthManager.getIndexHealth(indexName, "indices"))
+        when(healthManager.getIndexHealth(anyString(), anyString(), anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
-        
+
         // When
-        ResponseEntity<Object> response = healthHandler.getIndexHealth(indexName);
-        
+        ResponseEntity<Object> response = healthHandler.getIndexHealth(testClusterId, indexName);
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-        
+
         ErrorResponse errorResponse = (ErrorResponse) response.getBody();
         assertThat(errorResponse.getError()).isEqualTo("not_implemented");
         assertThat(errorResponse.getReason()).contains("not yet implemented");
-        
-        verify(healthManager).getIndexHealth(indexName, "indices");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-    
+
     @Test
     void testGetClusterStats_NotImplemented() {
         // Given
-        when(healthManager.getClusterStats())
+        when(healthManager.getClusterStats(anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
-        
+
         // When
-        ResponseEntity<Object> response = healthHandler.getClusterStats();
-        
+        ResponseEntity<Object> response = healthHandler.getClusterStats(testClusterId);
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-        
+
         ErrorResponse errorResponse = (ErrorResponse) response.getBody();
         assertThat(errorResponse.getError()).isEqualTo("not_implemented");
         assertThat(errorResponse.getReason()).contains("not yet implemented");
-        
-        verify(healthManager).getClusterStats();
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-    
+
     @Test
     void testGetClusterHealth_InternalError() {
         // Given
-        when(healthManager.getClusterHealth(anyString()))
+        when(healthManager.getClusterHealth(anyString(), anyString()))
             .thenThrow(new RuntimeException("Database connection failed"));
-        
+
         // When
-        ResponseEntity<Object> response = healthHandler.getClusterHealth("cluster");
-        
+        ResponseEntity<Object> response = healthHandler.getClusterHealth(testClusterId, "cluster");
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-        
+
         ErrorResponse errorResponse = (ErrorResponse) response.getBody();
         assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
         assertThat(errorResponse.getReason()).contains("Database connection failed");
+        assertThat(errorResponse.getStatus()).isEqualTo(500);
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
index e5a8945..01615ab 100644
--- a/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
+++ b/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
@@ -7,155 +7,253 @@ import io.clustercontroller.indices.IndexManager;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
 import org.mockito.Mock;
-import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.MockitoAnnotations;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
 
-import java.util.Map;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.*;
 
-@ExtendWith(MockitoExtension.class)
 class IndexHandlerTest {
 
     @Mock
     private IndexManager indexManager;
-    
+
     @Mock
     private ObjectMapper objectMapper;
-    
+
+    @InjectMocks
     private IndexHandler indexHandler;
-    
+
+    private final String testClusterId = "test-cluster";
+    private final String testIndexName = "test-index";
+
     @BeforeEach
     void setUp() {
-        indexHandler = new IndexHandler(indexManager, objectMapper);
+        MockitoAnnotations.openMocks(this);
     }
-    
+
     @Test
     void testCreateIndex_Success() throws Exception {
         // Given
-        String indexName = "test-index";
-        IndexRequest request = IndexRequest.builder()
-            .settings(Map.of("replicas", 1))
-            .build();
-        
-        when(objectMapper.writeValueAsString(any())).thenReturn("{\"settings\":{\"replicas\":1}}");
-        doNothing().when(indexManager).createIndex(anyString());
-        
+        IndexRequest request = IndexRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doNothing().when(indexManager).createIndex(anyString(), anyString(), anyString());
+
         // When
-        ResponseEntity<Object> response = indexHandler.createIndex(indexName, request);
-        
+        ResponseEntity<Object> response = indexHandler.createIndex(testClusterId, testIndexName, request);
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
         assertThat(response.getBody()).isInstanceOf(IndexResponse.class);
-        
+
         IndexResponse indexResponse = (IndexResponse) response.getBody();
-        assertThat(indexResponse.getAcknowledged()).isTrue();
-        assertThat(indexResponse.getShardsAcknowledged()).isTrue();
-        assertThat(indexResponse.getIndex()).isEqualTo(indexName);
-        
-        verify(indexManager).createIndex("{\"settings\":{\"replicas\":1}}");
-    }
-    
-    @Test
-    void testCreateIndex_WithNullRequest() throws Exception {
-        // Given
-        String indexName = "test-index";
-        
-        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
-        doNothing().when(indexManager).createIndex(anyString());
-        
-        // When
-        ResponseEntity<Object> response = indexHandler.createIndex(indexName, null);
-        
-        // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
-        verify(indexManager).createIndex("{}");
+        assertThat(indexResponse.isAcknowledged()).isTrue();
+        assertThat(indexResponse.isShardsAcknowledged()).isTrue();
+        assertThat(indexResponse.getIndex()).isEqualTo(testIndexName);
+
+        verify(indexManager).createIndex(testClusterId, testIndexName, "{}");
     }
-    
+
     @Test
     void testCreateIndex_UnsupportedOperation() throws Exception {
         // Given
-        String indexName = "test-index";
         IndexRequest request = IndexRequest.builder().build();
-        
+
         when(objectMapper.writeValueAsString(any())).thenReturn("{}");
         doThrow(new UnsupportedOperationException("Not implemented"))
-            .when(indexManager).createIndex(anyString());
-        
+            .when(indexManager).createIndex(anyString(), anyString(), anyString());
+
         // When
-        ResponseEntity<Object> response = indexHandler.createIndex(indexName, request);
-        
+        ResponseEntity<Object> response = indexHandler.createIndex(testClusterId, testIndexName, request);
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-        
+
         ErrorResponse errorResponse = (ErrorResponse) response.getBody();
         assertThat(errorResponse.getError()).isEqualTo("not_implemented");
         assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-    
+
     @Test
     void testCreateIndex_InternalError() throws Exception {
         // Given
-        String indexName = "test-index";
         IndexRequest request = IndexRequest.builder().build();
-        
+
         when(objectMapper.writeValueAsString(any())).thenReturn("{}");
         doThrow(new RuntimeException("Database error"))
-            .when(indexManager).createIndex(anyString());
-        
+            .when(indexManager).createIndex(anyString(), anyString(), anyString());
+
         // When
-        ResponseEntity<Object> response = indexHandler.createIndex(indexName, request);
-        
+        ResponseEntity<Object> response = indexHandler.createIndex(testClusterId, testIndexName, request);
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-        
+
         ErrorResponse errorResponse = (ErrorResponse) response.getBody();
         assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
+        assertThat(errorResponse.getReason()).contains("Database error");
         assertThat(errorResponse.getStatus()).isEqualTo(500);
     }
-    
+
+    @Test
+    void testDeleteIndex_Success() {
+        // Given
+        doNothing().when(indexManager).deleteIndex(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = indexHandler.deleteIndex(testClusterId, testIndexName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(IndexResponse.class);
+
+        IndexResponse indexResponse = (IndexResponse) response.getBody();
+        assertThat(indexResponse.isAcknowledged()).isTrue();
+        assertThat(indexResponse.isShardsAcknowledged()).isTrue();
+        assertThat(indexResponse.getIndex()).isEqualTo(testIndexName);
+
+        verify(indexManager).deleteIndex(testClusterId, testIndexName);
+    }
+
+    @Test
+    void testDeleteIndex_UnsupportedOperation() {
+        // Given
+        doThrow(new UnsupportedOperationException("Not implemented"))
+            .when(indexManager).deleteIndex(anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = indexHandler.deleteIndex(testClusterId, testIndexName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
     @Test
     void testGetIndex_NotImplemented() {
         // Given
-        String indexName = "test-index";
-        
-        when(indexManager.getIndex(indexName))
+        when(indexManager.getIndex(anyString(), anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
-        
+
         // When
-        ResponseEntity<Object> response = indexHandler.getIndex(indexName);
-        
+        ResponseEntity<Object> response = indexHandler.getIndex(testClusterId, testIndexName);
+
         // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
         assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-    
+
     @Test
-    void testDeleteIndex_Success() {
+    void testGetIndexSettings_NotImplemented() {
+        // Given
+        when(indexManager.getSettings(anyString(), anyString()))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+
+        // When
+        ResponseEntity<Object> response = indexHandler.getIndexSettings(testClusterId, testIndexName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testUpdateIndexSettings_Success() {
+        // Given
+        String settingsJson = "{\"refresh_interval\":\"30s\"}";
+        doNothing().when(indexManager).updateSettings(anyString(), anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response = indexHandler.updateIndexSettings(testClusterId, testIndexName, settingsJson);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
+        assertThat(response.getBody()).isInstanceOf(IndexResponse.class);
+
+        IndexResponse indexResponse = (IndexResponse) response.getBody();
+        assertThat(indexResponse.isAcknowledged()).isTrue();
+        assertThat(indexResponse.getIndex()).isEqualTo(testIndexName);
+
+        verify(indexManager).updateSettings(testClusterId, testIndexName, settingsJson);
+    }
+
+    @Test
+    void testGetIndexMapping_NotImplemented() {
+        // Given
+        when(indexManager.getMapping(anyString(), anyString()))
+            .thenThrow(new UnsupportedOperationException("Not implemented"));
+
+        // When
+        ResponseEntity<Object> response = indexHandler.getIndexMapping(testClusterId, testIndexName);
+
+        // Then
+        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
+        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
+
+        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
+        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
+        assertThat(errorResponse.getStatus()).isEqualTo(501);
+    }
+
+    @Test
+    void testUpdateIndexMapping_Success() {
         // Given
-        String indexName = "test-index";
-        
-        doNothing().when(indexManager).deleteIndex(indexName);
-        
+        String mappingJson = "{\"properties\":{\"title\":{\"type\":\"text\"}}}";
+        doNothing().when(indexManager).updateMapping(anyString(), anyString(), anyString());
+
         // When
-        ResponseEntity<Object> response = indexHandler.deleteIndex(indexName);
-        
+        ResponseEntity<Object> response = indexHandler.updateIndexMapping(testClusterId, testIndexName, mappingJson);
+
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
         assertThat(response.getBody()).isInstanceOf(IndexResponse.class);
-        
+
         IndexResponse indexResponse = (IndexResponse) response.getBody();
-        assertThat(indexResponse.getAcknowledged()).isTrue();
-        assertThat(indexResponse.getIndex()).isEqualTo(indexName);
-        
-        verify(indexManager).deleteIndex(indexName);
+        assertThat(indexResponse.isAcknowledged()).isTrue();
+        assertThat(indexResponse.getIndex()).isEqualTo(testIndexName);
+
+        verify(indexManager).updateMapping(testClusterId, testIndexName, mappingJson);
+    }
+
+    @Test
+    void testMultiClusterSupport() throws Exception {
+        // Test that different cluster IDs are handled properly
+        String cluster1 = "cluster1";
+        String cluster2 = "cluster2";
+        IndexRequest request = IndexRequest.builder().build();
+
+        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
+        doNothing().when(indexManager).createIndex(anyString(), anyString(), anyString());
+
+        // When
+        ResponseEntity<Object> response1 = indexHandler.createIndex(cluster1, testIndexName, request);
+        ResponseEntity<Object> response2 = indexHandler.createIndex(cluster2, testIndexName, request);
+
+        // Then
+        assertThat(response1.getStatusCode()).isEqualTo(HttpStatus.CREATED);
+        assertThat(response2.getStatusCode()).isEqualTo(HttpStatus.CREATED);
+
+        verify(indexManager).createIndex(cluster1, testIndexName, "{}");
+        verify(indexManager).createIndex(cluster2, testIndexName, "{}");
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java
index 1140ab5..ebe1737 100644
--- a/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java
+++ b/src/test/java/io/clustercontroller/api/handlers/TemplateHandlerTest.java
@@ -30,6 +30,8 @@ class TemplateHandlerTest {
 
     @InjectMocks
     private TemplateHandler templateHandler;
+    
+    private final String testClusterId = "test-cluster";
 
     @BeforeEach
     void setUp() {
@@ -46,10 +48,10 @@ class TemplateHandlerTest {
             .build();
 
         when(objectMapper.writeValueAsString(any())).thenReturn("{\"index_patterns\":[\"logs-*\"],\"priority\":100}");
-        doNothing().when(templateManager).putTemplate(anyString(), anyString());
+        doNothing().when(templateManager).putTemplate(anyString(), anyString(), anyString());
 
         // When
-        ResponseEntity<Object> response = templateHandler.createTemplate(templateName, request);
+        ResponseEntity<Object> response = templateHandler.createTemplate(testClusterId, templateName, request);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -59,7 +61,7 @@ class TemplateHandlerTest {
         assertThat(templateResponse.isAcknowledged()).isTrue();
         assertThat(templateResponse.getTemplate()).isEqualTo(templateName);
 
-        verify(templateManager).putTemplate(templateName, "{\"index_patterns\":[\"logs-*\"],\"priority\":100}");
+        verify(templateManager).putTemplate(testClusterId, templateName, "{\"index_patterns\":[\"logs-*\"],\"priority\":100}");
     }
 
     @Test
@@ -70,10 +72,10 @@ class TemplateHandlerTest {
 
         when(objectMapper.writeValueAsString(any())).thenReturn("{}");
         doThrow(new UnsupportedOperationException("Not implemented"))
-            .when(templateManager).putTemplate(anyString(), anyString());
+            .when(templateManager).putTemplate(anyString(), anyString(), anyString());
 
         // When
-        ResponseEntity<Object> response = templateHandler.createTemplate(templateName, request);
+        ResponseEntity<Object> response = templateHandler.createTemplate(testClusterId, templateName, request);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
@@ -84,38 +86,15 @@ class TemplateHandlerTest {
         assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
 
-    @Test
-    void testCreateTemplate_InternalError() throws Exception {
-        // Given
-        String templateName = "test-template";
-        TemplateRequest request = TemplateRequest.builder().build();
-
-        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
-        doThrow(new RuntimeException("Template validation failed"))
-            .when(templateManager).putTemplate(anyString(), anyString());
-
-        // When
-        ResponseEntity<Object> response = templateHandler.createTemplate(templateName, request);
-
-        // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
-        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-
-        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
-        assertThat(errorResponse.getError()).isEqualTo("internal_server_error");
-        assertThat(errorResponse.getReason()).contains("Template validation failed");
-        assertThat(errorResponse.getStatus()).isEqualTo(500);
-    }
-
     @Test
     void testGetTemplate_NotImplemented() {
         // Given
         String templateName = "test-template";
-        when(templateManager.getTemplate(anyString()))
+        when(templateManager.getTemplate(anyString(), anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
 
         // When
-        ResponseEntity<Object> response = templateHandler.getTemplate(templateName);
+        ResponseEntity<Object> response = templateHandler.getTemplate(testClusterId, templateName);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
@@ -131,10 +110,10 @@ class TemplateHandlerTest {
     void testDeleteTemplate_Success() {
         // Given
         String templateName = "test-template";
-        doNothing().when(templateManager).deleteTemplate(anyString());
+        doNothing().when(templateManager).deleteTemplate(anyString(), anyString());
 
         // When
-        ResponseEntity<Object> response = templateHandler.deleteTemplate(templateName);
+        ResponseEntity<Object> response = templateHandler.deleteTemplate(testClusterId, templateName);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -144,36 +123,17 @@ class TemplateHandlerTest {
         assertThat(templateResponse.isAcknowledged()).isTrue();
         assertThat(templateResponse.getTemplate()).isEqualTo(templateName);
 
-        verify(templateManager).deleteTemplate(templateName);
-    }
-
-    @Test
-    void testDeleteTemplate_UnsupportedOperation() {
-        // Given
-        String templateName = "test-template";
-        doThrow(new UnsupportedOperationException("Not implemented"))
-            .when(templateManager).deleteTemplate(anyString());
-
-        // When
-        ResponseEntity<Object> response = templateHandler.deleteTemplate(templateName);
-
-        // Then
-        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
-        assertThat(response.getBody()).isInstanceOf(ErrorResponse.class);
-
-        ErrorResponse errorResponse = (ErrorResponse) response.getBody();
-        assertThat(errorResponse.getError()).isEqualTo("not_implemented");
-        assertThat(errorResponse.getStatus()).isEqualTo(501);
+        verify(templateManager).deleteTemplate(testClusterId, templateName);
     }
 
     @Test
     void testGetAllTemplates_NotImplemented() {
         // Given
-        when(templateManager.getTemplate(anyString()))
+        when(templateManager.getAllTemplates(anyString()))
             .thenThrow(new UnsupportedOperationException("Not implemented"));
 
         // When
-        ResponseEntity<Object> response = templateHandler.getAllTemplates();
+        ResponseEntity<Object> response = templateHandler.getAllTemplates(testClusterId);
 
         // Then
         assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_IMPLEMENTED);
@@ -184,4 +144,4 @@ class TemplateHandlerTest {
         assertThat(errorResponse.getReason()).contains("Get all templates is not yet implemented");
         assertThat(errorResponse.getStatus()).isEqualTo(501);
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java b/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java
index b477ca5..e946608 100644
--- a/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java
+++ b/src/test/java/io/clustercontroller/api/models/responses/IndexResponseTest.java
@@ -23,8 +23,8 @@ class IndexResponseTest {
         IndexResponse response = IndexResponse.createSuccess("test-index");
         
         // Then
-        assertThat(response.getAcknowledged()).isTrue();
-        assertThat(response.getShardsAcknowledged()).isTrue();
+        assertThat(response.isAcknowledged()).isTrue();
+        assertThat(response.isShardsAcknowledged()).isTrue();
         assertThat(response.getIndex()).isEqualTo("test-index");
         assertThat(response.getSettings()).isNull();
         assertThat(response.getMappings()).isNull();
@@ -36,8 +36,8 @@ class IndexResponseTest {
         IndexResponse response = IndexResponse.deleteSuccess("test-index");
         
         // Then
-        assertThat(response.getAcknowledged()).isTrue();
-        assertThat(response.getShardsAcknowledged()).isNull(); // Not set for delete
+        assertThat(response.isAcknowledged()).isTrue();
+        assertThat(response.isShardsAcknowledged()).isFalse(); // Not set for delete, defaults to false
         assertThat(response.getIndex()).isEqualTo("test-index");
     }
     
@@ -78,8 +78,8 @@ class IndexResponseTest {
         IndexResponse response = objectMapper.readValue(json, IndexResponse.class);
         
         // Then
-        assertThat(response.getAcknowledged()).isTrue();
-        assertThat(response.getShardsAcknowledged()).isFalse();
+        assertThat(response.isAcknowledged()).isTrue();
+        assertThat(response.isShardsAcknowledged()).isFalse();
         assertThat(response.getIndex()).isEqualTo("test-index");
         assertThat(response.getSettings()).containsEntry("number_of_shards", 2);
         assertThat(response.getMappings()).isNull();
@@ -101,8 +101,8 @@ class IndexResponseTest {
             .build();
         
         // Then
-        assertThat(response.getAcknowledged()).isTrue();
-        assertThat(response.getShardsAcknowledged()).isFalse();
+        assertThat(response.isAcknowledged()).isTrue();
+        assertThat(response.isShardsAcknowledged()).isFalse();
         assertThat(response.getIndex()).isEqualTo("custom-index");
         assertThat(response.getSettings()).isEqualTo(settings);
         assertThat(response.getMappings()).isEqualTo(mappings);
diff --git a/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java b/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
index d4eb7d7..5c28ef4 100644
--- a/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
+++ b/src/test/java/io/clustercontroller/discovery/DiscoveryTest.java
@@ -1,7 +1,7 @@
 package io.clustercontroller.discovery;
 
-import io.clustercontroller.config.Constants;
 import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.models.SearchUnitActualState;
 import io.clustercontroller.store.MetadataStore;
@@ -30,7 +30,7 @@ class DiscoveryTest {
     
     @BeforeEach
     void setUp() {
-        discovery = new Discovery(metadataStore);
+        discovery = new Discovery(metadataStore, "test-cluster");
     }
     
     // =================================================================
@@ -43,18 +43,18 @@ class DiscoveryTest {
         Map<String, SearchUnitActualState> actualStates = createMockActualStates();
         List<SearchUnit> existingUnits = new ArrayList<>();
         
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(actualStates);
-        when(metadataStore.getAllSearchUnits()).thenReturn(existingUnits);
-        when(metadataStore.getSearchUnit(anyString())).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(actualStates);
+        when(metadataStore.getAllSearchUnits(anyString())).thenReturn(existingUnits);
+        when(metadataStore.getSearchUnit(anyString(), anyString())).thenReturn(Optional.empty());
         
         // When
         discovery.discoverSearchUnits();
         
         // Then
-        verify(metadataStore).getAllSearchUnitActualStates();
-        verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
-        verify(metadataStore, times(3)).getSearchUnit(anyString()); // 3 units
-        verify(metadataStore, times(3)).upsertSearchUnit(anyString(), any(SearchUnit.class));
+        verify(metadataStore).getAllSearchUnitActualStates(anyString());
+        verify(metadataStore, times(2)).getAllSearchUnits(anyString()); // Called in processAllSearchUnits and cleanupStaleSearchUnits
+        verify(metadataStore, times(3)).getSearchUnit(anyString(), anyString()); // 3 units
+        verify(metadataStore, times(3)).upsertSearchUnit(anyString(), anyString(), any(SearchUnit.class));
     }
     
     @Test
@@ -64,92 +64,33 @@ class DiscoveryTest {
         SearchUnit existingUnit = createMockSearchUnit("coordinator-node-1", "coordinator");
         List<SearchUnit> existingUnits = Arrays.asList(existingUnit);
         
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(actualStates);
-        when(metadataStore.getAllSearchUnits()).thenReturn(existingUnits);
-        when(metadataStore.getSearchUnit("coordinator-node-1")).thenReturn(Optional.of(existingUnit));
-        when(metadataStore.getSearchUnit("primary-node-1")).thenReturn(Optional.empty());
-        when(metadataStore.getSearchUnit("replica-node-1")).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(actualStates);
+        when(metadataStore.getAllSearchUnits(anyString())).thenReturn(existingUnits);
+        when(metadataStore.getSearchUnit(anyString(), eq("coordinator-node-1"))).thenReturn(Optional.of(existingUnit));
+        when(metadataStore.getSearchUnit(anyString(), eq("primary-node-1"))).thenReturn(Optional.empty());
+        when(metadataStore.getSearchUnit(anyString(), eq("replica-node-1"))).thenReturn(Optional.empty());
         
         // When
         discovery.discoverSearchUnits();
         
         // Then
         // Verify discovery from etcd: 1 update + 2 creates
-        verify(metadataStore, times(2)).upsertSearchUnit(anyString(), any(SearchUnit.class)); // new units
+        verify(metadataStore, times(2)).upsertSearchUnit(anyString(), anyString(), any(SearchUnit.class)); // new units
         // Verify total updates: 1 from etcd discovery + 1 from processAllSearchUnits = 2 total
-        verify(metadataStore, times(2)).updateSearchUnit(any(SearchUnit.class));
+        verify(metadataStore, times(2)).updateSearchUnit(anyString(), any(SearchUnit.class));
     }
     
     @Test
     void testDiscoverSearchUnits_HandlesMetadataStoreError() throws Exception {
         // Given
-        when(metadataStore.getAllSearchUnitActualStates()).thenThrow(new RuntimeException("Etcd connection failed"));
-        when(metadataStore.getAllSearchUnits()).thenReturn(new ArrayList<>());
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenThrow(new RuntimeException("Etcd connection failed"));
+        when(metadataStore.getAllSearchUnits(anyString())).thenReturn(new ArrayList<>());
         
         // When & Then - should not throw exception
         assertThatCode(() -> discovery.discoverSearchUnits()).doesNotThrowAnyException();
         
-        verify(metadataStore).getAllSearchUnitActualStates();
-        verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
-    }
-    
-    @Test
-    void testDiscoverSearchUnits_CleanupStaleSearchUnits() throws Exception {
-        // Given - Set up scenario with one fresh unit and one stale unit
-        long currentTime = System.currentTimeMillis();
-        long staleTimeoutMs = Constants.STALE_SEARCH_UNIT_TIMEOUT_MINUTES * 60 * 1000;
-        long staleTimestamp = currentTime - staleTimeoutMs - 60000; // 1 minute older than threshold
-        long freshTimestamp = currentTime - 60000; // 1 minute old (fresh)
-        
-        // Mock actual states - both units discovered from Etcd
-        Map<String, SearchUnitActualState> actualStates = new HashMap<>();
-        SearchUnitActualState freshState = createHealthyActualState("fresh-node", "10.0.1.100", 9200);
-        freshState.setRole("primary");
-        freshState.setShardId("shard-1");
-        freshState.setClusterName("test-cluster");
-        freshState.setTimestamp(freshTimestamp);
-        actualStates.put("fresh-node", freshState);
-        
-        SearchUnitActualState staleState = createHealthyActualState("stale-node", "10.0.1.101", 9200);
-        staleState.setRole("replica");
-        staleState.setShardId("shard-2");
-        staleState.setClusterName("test-cluster");
-        staleState.setTimestamp(staleTimestamp);
-        actualStates.put("stale-node", staleState);
-        
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(actualStates);
-        
-        // Mock existing search units - both units exist in metadata store initially
-        SearchUnit freshUnit = createMockSearchUnit("fresh-node", "primary");
-        SearchUnit staleUnit = createMockSearchUnit("stale-node", "replica");
-        List<SearchUnit> initialUnits = Arrays.asList(freshUnit, staleUnit);
-        List<SearchUnit> unitsAfterCleanup = Arrays.asList(freshUnit); // Only fresh unit remains
-        when(metadataStore.getAllSearchUnits())
-                .thenReturn(initialUnits)  // First call for cleanup
-                .thenReturn(unitsAfterCleanup); // Second call for processing
-        
-        // Mock actual state lookups for cleanup
-        when(metadataStore.getSearchUnitActualState("fresh-node"))
-                .thenReturn(Optional.of(freshState));
-        when(metadataStore.getSearchUnitActualState("stale-node"))
-                .thenReturn(Optional.of(staleState));
-        
-        // Mock unit lookups for discovery phase
-        when(metadataStore.getSearchUnit("fresh-node")).thenReturn(Optional.of(freshUnit));
-        when(metadataStore.getSearchUnit("stale-node")).thenReturn(Optional.of(staleUnit));
-        
-        // When
-        discovery.discoverSearchUnits();
-        
-        // Then - Verify the stale unit was deleted but fresh unit was not
-        verify(metadataStore).deleteSearchUnit("stale-node"); // Stale unit should be deleted
-        verify(metadataStore, never()).deleteSearchUnit("fresh-node"); // Fresh unit should NOT be deleted
-        
-        // Verify units were updated: 2 during discovery phase + 1 during processing phase (fresh unit only)
-        verify(metadataStore, times(3)).updateSearchUnit(any(SearchUnit.class));
-        
-        // Verify the cleanup and processing phases both called getAllSearchUnits
-        verify(metadataStore, times(2)).getAllSearchUnits(); // Called by cleanup + processing
+        verify(metadataStore).getAllSearchUnitActualStates(anyString());
+        verify(metadataStore, times(2)).getAllSearchUnits(anyString()); // Called in processAllSearchUnits and cleanupStaleSearchUnits
     }
     
     // =================================================================
@@ -160,7 +101,7 @@ class DiscoveryTest {
     void testFetchSearchUnitsFromEtcd_Success() throws Exception {
         // Given
         Map<String, SearchUnitActualState> actualStates = createMockActualStates();
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(actualStates);
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(actualStates);
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
@@ -210,20 +151,20 @@ class DiscoveryTest {
     @Test
     void testFetchSearchUnitsFromEtcd_EmptyResult() throws Exception {
         // Given
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(new HashMap<>());
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(new HashMap<>());
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
         
         // Then
         assertThat(result).isEmpty();
-        verify(metadataStore).getAllSearchUnitActualStates();
+        verify(metadataStore).getAllSearchUnitActualStates(anyString());
     }
     
     @Test
     void testFetchSearchUnitsFromEtcd_HandlesException() throws Exception {
         // Given
-        when(metadataStore.getAllSearchUnitActualStates()).thenThrow(new RuntimeException("Connection error"));
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenThrow(new RuntimeException("Connection error"));
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
@@ -241,7 +182,7 @@ class DiscoveryTest {
         state.setShardId(null); // null shard id
         actualStates.put("test-node", state);
         
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(actualStates);
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(actualStates);
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
@@ -266,7 +207,7 @@ class DiscoveryTest {
         actualState.setRole("coordinator");
         actualState.setShardId("coordinator");
         actualState.setClusterName("test-cluster");
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(Map.of("coordinator-node-1", actualState));
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(Map.of("coordinator-node-1", actualState));
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
@@ -291,7 +232,7 @@ class DiscoveryTest {
         actualState.setRole("primary");
         actualState.setShardId("shard-1");
         actualState.setClusterName("test-cluster");
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(Map.of("primary-node-1", actualState));
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(Map.of("primary-node-1", actualState));
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
@@ -314,7 +255,7 @@ class DiscoveryTest {
         actualState.setRole("replica");
         actualState.setShardId("shard-2");
         actualState.setClusterName("test-cluster");
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(Map.of("replica-node-1", actualState));
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(Map.of("replica-node-1", actualState));
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
@@ -337,7 +278,7 @@ class DiscoveryTest {
         actualState.setRole("primary");
         actualState.setShardId("shard-1");
         actualState.setClusterName("test-cluster");
-        when(metadataStore.getAllSearchUnitActualStates()).thenReturn(Map.of("unhealthy-node-1", actualState));
+        when(metadataStore.getAllSearchUnitActualStates(anyString())).thenReturn(Map.of("unhealthy-node-1", actualState));
         
         // When
         List<SearchUnit> result = discovery.fetchSearchUnitsFromEtcd();
diff --git a/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java b/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java
index 409d84d..7f4f3d9 100644
--- a/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java
+++ b/src/test/java/io/clustercontroller/health/ClusterHealthManagerTest.java
@@ -4,77 +4,63 @@ import io.clustercontroller.discovery.Discovery;
 import io.clustercontroller.store.MetadataStore;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
 import org.mockito.Mock;
-import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.MockitoAnnotations;
 
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
-@ExtendWith(MockitoExtension.class)
 class ClusterHealthManagerTest {
 
     @Mock
     private Discovery discovery;
-    
+
     @Mock
     private MetadataStore metadataStore;
+
+    @InjectMocks
+    private ClusterHealthManager clusterHealthManager;
     
-    private ClusterHealthManager healthManager;
-    
+    private final String testClusterId = "test-cluster";
+
     @BeforeEach
     void setUp() {
-        healthManager = new ClusterHealthManager(discovery, metadataStore);
+        MockitoAnnotations.openMocks(this);
     }
-    
+
     @Test
-    void testGetClusterHealth_ThrowsUnsupportedOperation() {
-        // When & Then
-        assertThatThrownBy(() -> healthManager.getClusterHealth("cluster"))
+    void testGetClusterHealth_NotImplemented() {
+        assertThatThrownBy(() -> clusterHealthManager.getClusterHealth(testClusterId, "cluster"))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Cluster health not yet implemented");
     }
-    
+
     @Test
-    void testGetClusterHealth_WithDifferentLevels() {
-        // Test different health levels
-        assertThatThrownBy(() -> healthManager.getClusterHealth("cluster"))
-            .isInstanceOf(UnsupportedOperationException.class);
-            
-        assertThatThrownBy(() -> healthManager.getClusterHealth("indices"))
-            .isInstanceOf(UnsupportedOperationException.class);
-            
-        assertThatThrownBy(() -> healthManager.getClusterHealth("shards"))
-            .isInstanceOf(UnsupportedOperationException.class);
+    void testGetClusterHealth_WithIndicesLevel_NotImplemented() {
+        assertThatThrownBy(() -> clusterHealthManager.getClusterHealth(testClusterId, "indices"))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Cluster health not yet implemented");
     }
-    
+
+    @Test
+    void testGetClusterHealth_WithShardsLevel_NotImplemented() {
+        assertThatThrownBy(() -> clusterHealthManager.getClusterHealth(testClusterId, "shards"))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Cluster health not yet implemented");
+    }
+
     @Test
-    void testGetIndexHealth_ThrowsUnsupportedOperation() {
-        // Given
+    void testGetIndexHealth_NotImplemented() {
         String indexName = "test-index";
-        String level = "indices";
-        
-        // When & Then
-        assertThatThrownBy(() -> healthManager.getIndexHealth(indexName, level))
+        assertThatThrownBy(() -> clusterHealthManager.getIndexHealth(testClusterId, indexName, "indices"))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Index health not yet implemented");
     }
-    
+
     @Test
-    void testGetClusterStats_ThrowsUnsupportedOperation() {
-        // When & Then
-        assertThatThrownBy(() -> healthManager.getClusterStats())
+    void testGetClusterStats_NotImplemented() {
+        assertThatThrownBy(() -> clusterHealthManager.getClusterStats(testClusterId))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Cluster stats not yet implemented");
     }
-    
-    @Test
-    void testConstructor_InitializesCorrectly() {
-        // When
-        ClusterHealthManager manager = new ClusterHealthManager(discovery, metadataStore);
-        
-        // Then
-        assertThat(manager).isNotNull();
-        // Verify dependencies are stored (via successful construction)
-    }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/indices/AliasManagerTest.java b/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
index 67449fc..f17a724 100644
--- a/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
+++ b/src/test/java/io/clustercontroller/indices/AliasManagerTest.java
@@ -17,6 +17,7 @@ class AliasManagerTest {
     private MetadataStore metadataStore;
     
     private AliasManager aliasManager;
+    private final String testClusterId = "test-cluster";
     
     @BeforeEach
     void setUp() {
@@ -26,12 +27,12 @@ class AliasManagerTest {
     @Test
     void testCreateAlias_ThrowsUnsupportedOperation() {
         // Given
-        String indexName = "test-index";
         String aliasName = "test-alias";
+        String indexName = "test-index";
         String aliasConfig = "{\"filter\":{\"term\":{\"status\":\"published\"}}}";
         
         // When & Then
-        assertThatThrownBy(() -> aliasManager.createAlias(indexName, aliasName, aliasConfig))
+        assertThatThrownBy(() -> aliasManager.createAlias(testClusterId, aliasName, indexName, aliasConfig))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Alias creation not yet implemented");
     }
@@ -39,11 +40,11 @@ class AliasManagerTest {
     @Test
     void testDeleteAlias_ThrowsUnsupportedOperation() {
         // Given
-        String indexName = "test-index";
         String aliasName = "test-alias";
+        String indexName = "test-index";
         
         // When & Then
-        assertThatThrownBy(() -> aliasManager.deleteAlias(indexName, aliasName))
+        assertThatThrownBy(() -> aliasManager.deleteAlias(testClusterId, aliasName, indexName))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Alias deletion not yet implemented");
     }
@@ -54,7 +55,7 @@ class AliasManagerTest {
         String aliasName = "test-alias";
         
         // When & Then
-        assertThatThrownBy(() -> aliasManager.getAlias(aliasName))
+        assertThatThrownBy(() -> aliasManager.getAlias(testClusterId, aliasName))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Get alias not yet implemented");
     }
@@ -65,7 +66,7 @@ class AliasManagerTest {
         String aliasName = "test-alias";
         
         // When & Then
-        assertThatThrownBy(() -> aliasManager.aliasExists(aliasName))
+        assertThatThrownBy(() -> aliasManager.aliasExists(testClusterId, aliasName))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Alias existence check not yet implemented");
     }
@@ -77,6 +78,5 @@ class AliasManagerTest {
         
         // Then
         assertThat(manager).isNotNull();
-        // Verify dependencies are stored (via successful construction)
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/models/SearchUnitTest.java b/src/test/java/io/clustercontroller/models/SearchUnitTest.java
index 6ad82b8..17d27a3 100644
--- a/src/test/java/io/clustercontroller/models/SearchUnitTest.java
+++ b/src/test/java/io/clustercontroller/models/SearchUnitTest.java
@@ -1,5 +1,7 @@
 package io.clustercontroller.models;
 
+import io.clustercontroller.enums.HealthState;
+import io.clustercontroller.enums.NodeRole;
 import org.junit.jupiter.api.Test;
 import static org.assertj.core.api.Assertions.*;
 
@@ -37,14 +39,20 @@ class SearchUnitTest {
         SearchUnit unit = new SearchUnit();
         
         unit.setId("unit-123");
+        unit.setRole("replica");
         unit.setClusterName("test-cluster");
         unit.setZone("zone-1");
         unit.setShardId("shard-0");
+        unit.setStateAdmin("NORMAL");
+        unit.setStatePulled(HealthState.YELLOW);
         
         assertThat(unit.getId()).isEqualTo("unit-123");
+        assertThat(unit.getRole()).isEqualTo("replica");
         assertThat(unit.getClusterName()).isEqualTo("test-cluster");
         assertThat(unit.getZone()).isEqualTo("zone-1");
         assertThat(unit.getShardId()).isEqualTo("shard-0");
+        assertThat(unit.getStateAdmin()).isEqualTo("NORMAL");
+        assertThat(unit.getStatePulled()).isEqualTo(HealthState.YELLOW);
     }
     
     @Test
diff --git a/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java b/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java
index bf3fd0f..fcc42fc 100644
--- a/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java
+++ b/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java
@@ -26,7 +26,7 @@ import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 /**
- * Unit tests for EtcdMetadataStore using mocked etcd dependencies.
+ * Tests for EtcdMetadataStore.
  */
 public class EtcdMetadataStoreTest {
 
@@ -72,7 +72,7 @@ public class EtcdMetadataStoreTest {
     }
 
     private EtcdMetadataStore newStore() throws Exception {
-        return EtcdMetadataStore.createTestInstance(CLUSTER, ENDPOINTS, "test-node", mockEtcdClient, mockKv);
+        return EtcdMetadataStore.createTestInstance(ENDPOINTS, "test-node", mockEtcdClient, mockKv);
     }
 
     private GetResponse mockGetResponse(List<KeyValue> kvs) {
@@ -104,9 +104,10 @@ public class EtcdMetadataStoreTest {
     @Test
     public void testSingletonGetInstance() throws Exception {
         EtcdMetadataStore s1 = newStore();
-        EtcdMetadataStore s2 = EtcdMetadataStore.getInstance(CLUSTER, ENDPOINTS);
-        assertThat(s1).isSameAs(s2);
-        assertThat(s1.getClusterName()).isEqualTo(CLUSTER);
+        // Don't call createTestInstance again as it resets the singleton
+        // Instead, verify that the singleton is properly set
+        assertThat(s1).isNotNull();
+        assertThat(EtcdMetadataStore.getInstance()).isSameAs(s1);
     }
 
     @Test
@@ -134,7 +135,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class), any(GetOption.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        List<TaskMetadata> tasks = store.getAllTasks();
+        List<TaskMetadata> tasks = store.getAllTasks(CLUSTER);
 
         assertThat(tasks).hasSize(2);
         assertThat(tasks.get(0).getName()).isEqualTo("task-top");
@@ -152,7 +153,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        Optional<TaskMetadata> got = store.getTask("index-task");
+        Optional<TaskMetadata> got = store.getTask(CLUSTER, "index-task");
         assertThat(got).isPresent();
         assertThat(got.get().getName()).isEqualTo("index-task");
         assertThat(got.get().getPriority()).isEqualTo(3);
@@ -166,7 +167,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        Optional<TaskMetadata> got = store.getTask("missing");
+        Optional<TaskMetadata> got = store.getTask(CLUSTER, "missing");
         assertThat(got).isEmpty();
     }
 
@@ -185,7 +186,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(mockPutResponse()));
 
-        String name = store.createTask(task);
+        String name = store.createTask(CLUSTER, task);
         assertThat(name).isEqualTo("cleanup-task");
         verify(mockKv, times(1)).put(any(ByteSequence.class), any(ByteSequence.class));
     }
@@ -204,7 +205,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(mockPutResponse()));
 
-        store.updateTask(task);
+        store.updateTask(CLUSTER, task);
         verify(mockKv, times(1)).put(any(ByteSequence.class), any(ByteSequence.class));
     }
 
@@ -217,7 +218,7 @@ public class EtcdMetadataStoreTest {
                 .thenReturn(CompletableFuture.completedFuture(mock(DeleteResponse.class)));
 
         // Call delete method
-        store.deleteTask("old-task");
+        store.deleteTask(CLUSTER, "old-task");
         
         // Verify etcd delete was called with correct parameters
         verify(mockKv, times(1)).delete(any(ByteSequence.class));
@@ -232,7 +233,7 @@ public class EtcdMetadataStoreTest {
                 .thenReturn(CompletableFuture.failedFuture(new RuntimeException("etcd connection failed")));
 
         // Verify exception is propagated
-        assertThatThrownBy(() -> store.deleteTask("failing-task"))
+        assertThatThrownBy(() -> store.deleteTask(CLUSTER, "failing-task"))
                 .isInstanceOf(Exception.class)
                 .hasMessageContaining("Failed to delete task from etcd");
     }
@@ -252,7 +253,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class), any(GetOption.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        List<SearchUnit> units = store.getAllSearchUnits();
+        List<SearchUnit> units = store.getAllSearchUnits(CLUSTER);
         assertThat(units).hasSize(2);
         assertThat(units.get(0).getName()).isIn("node1", "node2");
     }
@@ -266,7 +267,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        Optional<SearchUnit> got = store.getSearchUnit("node3");
+        Optional<SearchUnit> got = store.getSearchUnit(CLUSTER, "node3");
         assertThat(got).isPresent();
         assertThat(got.get().getName()).isEqualTo("node3");
     }
@@ -279,7 +280,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        Optional<SearchUnit> got = store.getSearchUnit("missing");
+        Optional<SearchUnit> got = store.getSearchUnit(CLUSTER, "missing");
         assertThat(got).isEmpty();
     }
 
@@ -296,7 +297,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(mockPutResponse()));
 
-        store.upsertSearchUnit("node4", unit);
+        store.upsertSearchUnit(CLUSTER, "node4", unit);
         verify(mockKv).put(any(ByteSequence.class), any(ByteSequence.class));
     }
 
@@ -314,7 +315,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(mockPutResponse()));
 
-        store.updateSearchUnit(unit);
+        store.updateSearchUnit(CLUSTER, unit);
         verify(mockKv).put(any(ByteSequence.class), any(ByteSequence.class));
     }
 
@@ -327,7 +328,7 @@ public class EtcdMetadataStoreTest {
                 .thenReturn(CompletableFuture.completedFuture(mock(DeleteResponse.class)));
 
         // Call delete method
-        store.deleteSearchUnit("node6");
+        store.deleteSearchUnit(CLUSTER, "node6");
         
         // Verify etcd delete was called with correct parameters
         verify(mockKv).delete(any(ByteSequence.class));
@@ -342,7 +343,7 @@ public class EtcdMetadataStoreTest {
                 .thenReturn(CompletableFuture.failedFuture(new RuntimeException("etcd timeout")));
 
         // Verify exception is propagated
-        assertThatThrownBy(() -> store.deleteSearchUnit("node7"))
+        assertThatThrownBy(() -> store.deleteSearchUnit(CLUSTER, "node7"))
                 .isInstanceOf(Exception.class)
                 .hasMessageContaining("Failed to delete search unit from etcd");
     }
@@ -360,7 +361,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class), any(GetOption.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        List<String> configs = store.getAllIndexConfigs();
+        List<String> configs = store.getAllIndexConfigs(CLUSTER);
         assertThat(configs).hasSize(2);
         assertThat(configs.get(0)).contains("settings");
     }
@@ -374,7 +375,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        Optional<String> got = store.getIndexConfig("user-index");
+        Optional<String> got = store.getIndexConfig(CLUSTER, "user-index");
         assertThat(got).isPresent();
         assertThat(got.get()).contains("analysis");
     }
@@ -387,7 +388,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.get(any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(resp));
 
-        Optional<String> got = store.getIndexConfig("missing");
+        Optional<String> got = store.getIndexConfig(CLUSTER, "missing");
         assertThat(got).isEmpty();
     }
 
@@ -398,7 +399,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(mockPutResponse()));
 
-        String name = store.createIndexConfig("test-index", "{\"x\":1}");
+        String name = store.createIndexConfig(CLUSTER, "test-index", "{\"x\":1}");
         assertThat(name).isEqualTo("test-index");
         verify(mockKv).put(any(ByteSequence.class), any(ByteSequence.class));
     }
@@ -410,7 +411,7 @@ public class EtcdMetadataStoreTest {
         when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
                 .thenReturn(CompletableFuture.completedFuture(mockPutResponse()));
 
-        store.updateIndexConfig("user-index", "{\"y\":2}");
+        store.updateIndexConfig(CLUSTER, "user-index", "{\"y\":2}");
         verify(mockKv).put(any(ByteSequence.class), any(ByteSequence.class));
     }
 
@@ -423,7 +424,7 @@ public class EtcdMetadataStoreTest {
                 .thenReturn(CompletableFuture.completedFuture(mock(DeleteResponse.class)));
 
         // Call delete method
-        store.deleteIndexConfig("old-index");
+        store.deleteIndexConfig(CLUSTER, "old-index");
         
         // Verify etcd delete was called with correct parameters
         verify(mockKv).delete(any(ByteSequence.class));
@@ -438,7 +439,7 @@ public class EtcdMetadataStoreTest {
                 .thenReturn(CompletableFuture.failedFuture(new RuntimeException("etcd network error")));
 
         // Verify exception is propagated
-        assertThatThrownBy(() -> store.deleteIndexConfig("test-index"))
+        assertThatThrownBy(() -> store.deleteIndexConfig(CLUSTER, "test-index"))
                 .isInstanceOf(Exception.class)
                 .hasMessageContaining("Failed to delete index config from etcd");
     }
@@ -459,4 +460,4 @@ public class EtcdMetadataStoreTest {
         f.setAccessible(true);
         f.set(target, value);
     }
-}
\ No newline at end of file
+}
diff --git a/src/test/java/io/clustercontroller/store/EtcdPathResolverTest.java b/src/test/java/io/clustercontroller/store/EtcdPathResolverTest.java
index 71553f9..275f5f8 100644
--- a/src/test/java/io/clustercontroller/store/EtcdPathResolverTest.java
+++ b/src/test/java/io/clustercontroller/store/EtcdPathResolverTest.java
@@ -3,173 +3,134 @@ package io.clustercontroller.store;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.api.Assertions.assertThat;
 
-/**
- * Tests for EtcdPathResolver.
- */
 class EtcdPathResolverTest {
-    
+
     private EtcdPathResolver pathResolver;
     private final String testClusterName = "test-cluster";
-    
+
     @BeforeEach
     void setUp() {
-        pathResolver = new EtcdPathResolver(testClusterName);
+        pathResolver = EtcdPathResolver.getInstance();
     }
-    
+
     @Test
-    void testGetClusterName() {
-        assertThat(pathResolver.getClusterName()).isEqualTo(testClusterName);
+    void testSingletonPattern() {
+        EtcdPathResolver instance1 = EtcdPathResolver.getInstance();
+        EtcdPathResolver instance2 = EtcdPathResolver.getInstance();
+        assertThat(instance1).isSameAs(instance2);
     }
-    
+
     @Test
     void testGetClusterRoot() {
-        String result = pathResolver.getClusterRoot();
-        assertThat(result).isEqualTo("/test-cluster");
+        String path = pathResolver.getClusterRoot(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster");
     }
-    
-    // =================================================================
-    // CONTROLLER TASKS PATHS TESTS
-    // =================================================================
-    
+
     @Test
     void testGetControllerTasksPrefix() {
-        String result = pathResolver.getControllerTasksPrefix();
-        assertThat(result).isEqualTo("/test-cluster/ctl-tasks");
+        String path = pathResolver.getControllerTasksPrefix(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster/ctl-tasks");
     }
-    
+
     @Test
     void testGetControllerTaskPath() {
-        String result = pathResolver.getControllerTaskPath("create-index-task");
-        assertThat(result).isEqualTo("/test-cluster/ctl-tasks/create-index-task");
+        String path = pathResolver.getControllerTaskPath(testClusterName, "task1");
+        assertThat(path).isEqualTo("/test-cluster/ctl-tasks/task1");
     }
-    
-    // =================================================================
-    // SEARCH UNIT PATHS TESTS
-    // =================================================================
-    
+
     @Test
     void testGetSearchUnitsPrefix() {
-        String result = pathResolver.getSearchUnitsPrefix();
-        assertThat(result).isEqualTo("/test-cluster/search-units");
+        String path = pathResolver.getSearchUnitsPrefix(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster/search-units");
     }
-    
+
     @Test
     void testGetSearchUnitConfPath() {
-        String result = pathResolver.getSearchUnitConfPath("unit-1");
-        assertThat(result).isEqualTo("/test-cluster/search-units/unit-1/conf");
+        String path = pathResolver.getSearchUnitConfPath(testClusterName, "unit1");
+        assertThat(path).isEqualTo("/test-cluster/search-units/unit1/conf");
     }
-    
+
     @Test
     void testGetSearchUnitGoalStatePath() {
-        String result = pathResolver.getSearchUnitGoalStatePath("unit-1");
-        assertThat(result).isEqualTo("/test-cluster/search-units/unit-1/goal-state");
+        String path = pathResolver.getSearchUnitGoalStatePath(testClusterName, "unit1");
+        assertThat(path).isEqualTo("/test-cluster/search-units/unit1/goal-state");
     }
-    
+
     @Test
     void testGetSearchUnitActualStatePath() {
-        String result = pathResolver.getSearchUnitActualStatePath("unit-1");
-        assertThat(result).isEqualTo("/test-cluster/search-units/unit-1/actual-state");
+        String path = pathResolver.getSearchUnitActualStatePath(testClusterName, "unit1");
+        assertThat(path).isEqualTo("/test-cluster/search-units/unit1/actual-state");
     }
-    
-    
-    // =================================================================
-    // INDEX PATHS TESTS
-    // =================================================================
-    
+
     @Test
     void testGetIndicesPrefix() {
-        String result = pathResolver.getIndicesPrefix();
-        assertThat(result).isEqualTo("/test-cluster/indices");
+        String path = pathResolver.getIndicesPrefix(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster/indices");
     }
-    
+
     @Test
     void testGetIndexConfPath() {
-        String result = pathResolver.getIndexConfPath("user-index");
-        assertThat(result).isEqualTo("/test-cluster/indices/user-index/conf");
+        String path = pathResolver.getIndexConfPath(testClusterName, "index1");
+        assertThat(path).isEqualTo("/test-cluster/indices/index1/conf");
     }
-    
+
     @Test
     void testGetIndexMappingsPath() {
-        String result = pathResolver.getIndexMappingsPath("user-index");
-        assertThat(result).isEqualTo("/test-cluster/indices/user-index/mappings");
+        String path = pathResolver.getIndexMappingsPath(testClusterName, "index1");
+        assertThat(path).isEqualTo("/test-cluster/indices/index1/mappings");
     }
-    
+
     @Test
     void testGetIndexSettingsPath() {
-        String result = pathResolver.getIndexSettingsPath("user-index");
-        assertThat(result).isEqualTo("/test-cluster/indices/user-index/settings");
+        String path = pathResolver.getIndexSettingsPath(testClusterName, "index1");
+        assertThat(path).isEqualTo("/test-cluster/indices/index1/settings");
     }
-    
-    // =================================================================
-    // SHARD ALLOCATION PATHS TESTS
-    // =================================================================
-    
+
     @Test
     void testGetShardPlannedAllocationPath() {
-        String result = pathResolver.getShardPlannedAllocationPath("user-index", "0");
-        assertThat(result).isEqualTo("/test-cluster/indices/user-index/shard/0/planned-allocation");
+        String path = pathResolver.getShardPlannedAllocationPath(testClusterName, "index1", "shard1");
+        assertThat(path).isEqualTo("/test-cluster/indices/index1/shard/shard1/planned-allocation");
     }
-    
+
     @Test
     void testGetShardActualAllocationPath() {
-        String result = pathResolver.getShardActualAllocationPath("user-index", "0");
-        assertThat(result).isEqualTo("/test-cluster/indices/user-index/shard/0/actual-allocation");
+        String path = pathResolver.getShardActualAllocationPath(testClusterName, "index1", "shard1");
+        assertThat(path).isEqualTo("/test-cluster/indices/index1/shard/shard1/actual-allocation");
     }
-    
-    // =================================================================
-    // COORDINATOR PATHS TESTS
-    // =================================================================
-    
+
     @Test
     void testGetCoordinatorsPrefix() {
-        String result = pathResolver.getCoordinatorsPrefix();
-        assertThat(result).isEqualTo("/test-cluster/coordinators");
+        String path = pathResolver.getCoordinatorsPrefix(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster/coordinators");
     }
-    
+
     @Test
     void testGetCoordinatorGoalStatePath() {
-        String result = pathResolver.getCoordinatorGoalStatePath();
-        assertThat(result).isEqualTo("/test-cluster/coordinators/goal-state");
+        String path = pathResolver.getCoordinatorGoalStatePath(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster/coordinators/goal-state");
     }
-    
+
     @Test
     void testGetCoordinatorActualStatePath() {
-        String result = pathResolver.getCoordinatorActualStatePath("coord-1");
-        assertThat(result).isEqualTo("/test-cluster/coordinators/coord-1/actual-state");
+        String path = pathResolver.getCoordinatorActualStatePath(testClusterName, "coord1");
+        assertThat(path).isEqualTo("/test-cluster/coordinators/coord1/actual-state");
     }
-    
-    // =================================================================
-    // LEADER ELECTION PATHS TESTS
-    // =================================================================
-    
+
     @Test
     void testGetLeaderElectionPath() {
-        String result = pathResolver.getLeaderElectionPath();
-        assertThat(result).isEqualTo("/test-cluster/leader-election");
-    }
-    
-    // =================================================================
-    // EDGE CASES TESTS
-    // =================================================================
-    
-    @Test
-    void testPathsWithSpecialCharacters() {
-        String result = pathResolver.getControllerTaskPath("task-with-dashes_and_underscores");
-        assertThat(result).isEqualTo("/test-cluster/ctl-tasks/task-with-dashes_and_underscores");
+        String path = pathResolver.getLeaderElectionPath(testClusterName);
+        assertThat(path).isEqualTo("/test-cluster/leader-election");
     }
-    
-    @Test
-    void testPathsWithNumbers() {
-        String result = pathResolver.getSearchUnitConfPath("unit-123");
-        assertThat(result).isEqualTo("/test-cluster/search-units/unit-123/conf");
-    }
-    
+
     @Test
-    void testClusterNameWithSpecialCharacters() {
-        EtcdPathResolver specialResolver = new EtcdPathResolver("cluster-with-dashes");
-        String result = specialResolver.getControllerTasksPrefix();
-        assertThat(result).isEqualTo("/cluster-with-dashes/ctl-tasks");
+    void testMultipleClusterNames() {
+        String cluster1Path = pathResolver.getIndexConfPath("cluster1", "index1");
+        String cluster2Path = pathResolver.getIndexConfPath("cluster2", "index1");
+        
+        assertThat(cluster1Path).isEqualTo("/cluster1/indices/index1/conf");
+        assertThat(cluster2Path).isEqualTo("/cluster2/indices/index1/conf");
+        assertThat(cluster1Path).isNotEqualTo(cluster2Path);
     }
 }
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/store/LeaderElectionTest.java b/src/test/java/io/clustercontroller/store/LeaderElectionTest.java
index 3c6e833..bd2689a 100644
--- a/src/test/java/io/clustercontroller/store/LeaderElectionTest.java
+++ b/src/test/java/io/clustercontroller/store/LeaderElectionTest.java
@@ -58,7 +58,7 @@ class LeaderElectionTest {
         
         // Create test instance with mocked dependencies
         String testNodeId = "test-node-1";
-        etcdStore = EtcdMetadataStore.createTestInstance(clusterName, etcdEndpoints, testNodeId, etcdClient, kvClient);
+        etcdStore = EtcdMetadataStore.createTestInstance(etcdEndpoints, testNodeId, etcdClient, kvClient);
     }
 
     @Test
@@ -259,8 +259,8 @@ class LeaderElectionTest {
         try {
             // Reset and try to create a new instance - this will call getNodeId()
             EtcdMetadataStore.resetInstance();
-            EtcdMetadataStore.createTestInstance("test-cluster-missing-name", 
-                    new String[]{"http://localhost:2379"}, "test-node-missing", etcdClient, kvClient);
+            EtcdMetadataStore.createTestInstance(new String[]{"http://localhost:2379"}, 
+                    "test-node-missing", etcdClient, kvClient);
             
             // If we get here, NODE_NAME was set in the environment
             // This is fine - the behavior is documented
@@ -295,9 +295,9 @@ class LeaderElectionTest {
         Boolean isLeader = electionResult.get(5, TimeUnit.SECONDS);
         assertTrue(isLeader);
         
-        // Verify that the election key is formed correctly
+        // Verify that the election key is formed correctly (using default cluster name)
         verify(electionClient).campaign(
-                argThat(key -> key.toString().contains(clusterName + "-election")),
+                argThat(key -> key.toString().contains("default-cluster-election")),
                 eq(12345L),
                 any(ByteSequence.class)
         );
diff --git a/src/test/java/io/clustercontroller/tasks/TaskFactoryTest.java b/src/test/java/io/clustercontroller/tasks/TaskFactoryTest.java
index b15432a..45933c6 100644
--- a/src/test/java/io/clustercontroller/tasks/TaskFactoryTest.java
+++ b/src/test/java/io/clustercontroller/tasks/TaskFactoryTest.java
@@ -12,29 +12,6 @@ import static org.assertj.core.api.Assertions.*;
  */
 class TaskFactoryTest {
     
-    @Test
-    void testCreateIndexTask() {
-        TaskMetadata metadata = new TaskMetadata(TASK_ACTION_CREATE_INDEX, 1);
-        metadata.setInput("index-config");
-        
-        Task task = TaskFactory.createTask(metadata);
-        
-        assertThat(task).isInstanceOf(CreateIndexTask.class);
-        assertThat(task.getName()).isEqualTo(TASK_ACTION_CREATE_INDEX);
-        assertThat(task.getPriority()).isEqualTo(1);
-        assertThat(task.getInput()).isEqualTo("index-config");
-    }
-    
-    @Test
-    void testDeleteIndexTask() {
-        TaskMetadata metadata = new TaskMetadata(TASK_ACTION_DELETE_INDEX, 2);
-        
-        Task task = TaskFactory.createTask(metadata);
-        
-        assertThat(task).isInstanceOf(DeleteIndexTask.class);
-        assertThat(task.getName()).isEqualTo(TASK_ACTION_DELETE_INDEX);
-    }
-    
     @Test
     void testDiscoverSearchUnitTask() {
         TaskMetadata metadata = new TaskMetadata(TASK_ACTION_DISCOVER_SEARCH_UNIT, 3);
@@ -85,3 +62,4 @@ class TaskFactoryTest {
         assertThat(task.getName()).isEqualTo("unknown-task-type");
     }
 }
+
diff --git a/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java
index d2c18cc..1350fe8 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java
@@ -69,3 +69,4 @@ class ActualAllocationUpdaterTaskTest {
         verify(actualAllocationUpdater).updateActualAllocations();
     }
 }
+
diff --git a/src/test/java/io/clustercontroller/tasks/impl/CreateIndexTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/CreateIndexTaskTest.java
deleted file mode 100644
index 19f68b5..0000000
--- a/src/test/java/io/clustercontroller/tasks/impl/CreateIndexTaskTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package io.clustercontroller.tasks.impl;
-
-import io.clustercontroller.indices.IndexManager;
-import io.clustercontroller.tasks.TaskContext;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import static io.clustercontroller.config.Constants.*;
-import static org.assertj.core.api.Assertions.*;
-import static org.mockito.Mockito.*;
-
-/**
- * Tests for CreateIndexTask.
- */
-class CreateIndexTaskTest {
-    
-    @Mock
-    private TaskContext taskContext;
-    
-    @Mock
-    private IndexManager indexManager;
-    
-    @BeforeEach
-    void setUp() {
-        MockitoAnnotations.openMocks(this);
-        when(taskContext.getIndexManager()).thenReturn(indexManager);
-    }
-    
-    @Test
-    void testCreateIndexTaskExecution() {
-        String taskName = "create-index-task";
-        String input = "index-config";
-        CreateIndexTask task = new CreateIndexTask(taskName, 1, input, TASK_SCHEDULE_ONCE);
-        
-        String result = task.execute(taskContext);
-        
-        assertThat(result).isEqualTo(TASK_STATUS_COMPLETED);
-        verify(indexManager).createIndex(input);
-    }
-    
-    @Test
-    void testCreateIndexTaskProperties() {
-        String taskName = "create-index-task";
-        String input = "index-config";
-        int priority = 5;
-        String schedule = TASK_SCHEDULE_REPEAT;
-        
-        CreateIndexTask task = new CreateIndexTask(taskName, priority, input, schedule);
-        
-        assertThat(task.getName()).isEqualTo(taskName);
-        assertThat(task.getPriority()).isEqualTo(priority);
-        assertThat(task.getInput()).isEqualTo(input);
-        assertThat(task.getSchedule()).isEqualTo(schedule);
-    }
-    
-    @Test
-    void testCreateIndexTaskExecutionFailure() {
-        String taskName = "create-index-task";
-        String input = "invalid-config";
-        CreateIndexTask task = new CreateIndexTask(taskName, 1, input, TASK_SCHEDULE_ONCE);
-        
-        doThrow(new RuntimeException("Index creation failed")).when(indexManager).createIndex(input);
-        
-        String result = task.execute(taskContext);
-        
-        assertThat(result).isEqualTo(TASK_STATUS_FAILED);
-        verify(indexManager).createIndex(input);
-    }
-}
diff --git a/src/test/java/io/clustercontroller/tasks/impl/DeleteIndexTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/DeleteIndexTaskTest.java
deleted file mode 100644
index c6bd40e..0000000
--- a/src/test/java/io/clustercontroller/tasks/impl/DeleteIndexTaskTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package io.clustercontroller.tasks.impl;
-
-import io.clustercontroller.indices.IndexManager;
-import io.clustercontroller.tasks.TaskContext;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import static io.clustercontroller.config.Constants.*;
-import static org.assertj.core.api.Assertions.*;
-import static org.mockito.Mockito.*;
-
-/**
- * Tests for DeleteIndexTask.
- */
-class DeleteIndexTaskTest {
-    
-    @Mock
-    private TaskContext taskContext;
-    
-    @Mock
-    private IndexManager indexManager;
-    
-    @BeforeEach
-    void setUp() {
-        MockitoAnnotations.openMocks(this);
-        when(taskContext.getIndexManager()).thenReturn(indexManager);
-    }
-    
-    @Test
-    void testDeleteIndexTaskExecution() {
-        String taskName = "delete-index-task";
-        String input = "index-config";
-        DeleteIndexTask task = new DeleteIndexTask(taskName, 1, input, TASK_SCHEDULE_ONCE);
-        
-        String result = task.execute(taskContext);
-        
-        assertThat(result).isEqualTo(TASK_STATUS_COMPLETED);
-        verify(indexManager).deleteIndex(input);
-    }
-    
-    @Test
-    void testDeleteIndexTaskProperties() {
-        String taskName = "delete-index-task";
-        String input = "index-config";
-        int priority = 3;
-        String schedule = TASK_SCHEDULE_ONCE;
-        
-        DeleteIndexTask task = new DeleteIndexTask(taskName, priority, input, schedule);
-        
-        assertThat(task.getName()).isEqualTo(taskName);
-        assertThat(task.getPriority()).isEqualTo(priority);
-        assertThat(task.getInput()).isEqualTo(input);
-        assertThat(task.getSchedule()).isEqualTo(schedule);
-    }
-    
-    @Test
-    void testDeleteIndexTaskExecutionFailure() {
-        String taskName = "delete-index-task";
-        String input = "invalid-config";
-        DeleteIndexTask task = new DeleteIndexTask(taskName, 1, input, TASK_SCHEDULE_ONCE);
-        
-        doThrow(new RuntimeException("Index deletion failed")).when(indexManager).deleteIndex(input);
-        
-        String result = task.execute(taskContext);
-        
-        assertThat(result).isEqualTo(TASK_STATUS_FAILED);
-        verify(indexManager).deleteIndex(input);
-    }
-}
diff --git a/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java
index dd0e538..e89372b 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java
@@ -69,3 +69,4 @@ class ShardAllocatorTaskTest {
         verify(shardAllocator).allocateShards();
     }
 }
+
diff --git a/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java
index 1a468c3..bedcbd6 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java
@@ -49,3 +49,4 @@ class UnknownTaskTest {
         assertThat(task.getSchedule()).isEqualTo(schedule);
     }
 }
+
diff --git a/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java b/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java
index b5b6f04..d79dd05 100644
--- a/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java
+++ b/src/test/java/io/clustercontroller/templates/TemplateManagerTest.java
@@ -7,7 +7,6 @@ import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 class TemplateManagerTest {
@@ -17,6 +16,8 @@ class TemplateManagerTest {
 
     @InjectMocks
     private TemplateManager templateManager;
+    
+    private final String testClusterId = "test-cluster";
 
     @BeforeEach
     void setUp() {
@@ -26,7 +27,7 @@ class TemplateManagerTest {
     @Test
     void testTemplateExists_NotImplemented() {
         String templateName = "test-template";
-        assertThatThrownBy(() -> templateManager.templateExists(templateName))
+        assertThatThrownBy(() -> templateManager.templateExists(testClusterId, templateName))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Template existence check not yet implemented");
     }
@@ -36,7 +37,7 @@ class TemplateManagerTest {
         String templateName = "test-template";
         String templateConfig = "{\"index_patterns\":[\"logs-*\"]}";
 
-        assertThatThrownBy(() -> templateManager.putTemplate(templateName, templateConfig))
+        assertThatThrownBy(() -> templateManager.putTemplate(testClusterId, templateName, templateConfig))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Template creation not yet implemented");
     }
@@ -45,7 +46,7 @@ class TemplateManagerTest {
     void testDeleteTemplate_NotImplemented() {
         String templateName = "test-template";
 
-        assertThatThrownBy(() -> templateManager.deleteTemplate(templateName))
+        assertThatThrownBy(() -> templateManager.deleteTemplate(testClusterId, templateName))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Template deletion not yet implemented");
     }
@@ -53,8 +54,15 @@ class TemplateManagerTest {
     @Test
     void testGetTemplate_NotImplemented() {
         String templateName = "test-template";
-        assertThatThrownBy(() -> templateManager.getTemplate(templateName))
+        assertThatThrownBy(() -> templateManager.getTemplate(testClusterId, templateName))
             .isInstanceOf(UnsupportedOperationException.class)
             .hasMessageContaining("Get template not yet implemented");
     }
-}
+
+    @Test
+    void testGetAllTemplates_NotImplemented() {
+        assertThatThrownBy(() -> templateManager.getAllTemplates(testClusterId))
+            .isInstanceOf(UnsupportedOperationException.class)
+            .hasMessageContaining("Get all templates not yet implemented");
+    }
+}
\ No newline at end of file
-- 
2.50.1


From 88171b396b152b1508475271afc266feb7b70535 Mon Sep 17 00:00:00 2001
From: tjnaik <tjnaik@uber.com>
Date: Tue, 23 Sep 2025 09:36:38 -0700
Subject: [PATCH 08/12] revert: remove cosmetic blank lines from task files

- Reverted ActualAllocationUpdaterTask, ShardAllocatorTask, UnknownTask
- Reverted their corresponding test files
- These files had no functional changes, only extra blank lines
---
 .../tasks/impl/ActualAllocationUpdaterTask.java                  | 1 -
 .../java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java | 1 -
 src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java   | 1 -
 .../tasks/impl/ActualAllocationUpdaterTaskTest.java              | 1 -
 .../io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java  | 1 -
 .../java/io/clustercontroller/tasks/impl/UnknownTaskTest.java    | 1 -
 6 files changed, 6 deletions(-)

diff --git a/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java b/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java
index 132c490..4df7867 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTask.java
@@ -34,4 +34,3 @@ public class ActualAllocationUpdaterTask implements Task {
         }
     }
 }
-
diff --git a/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java b/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java
index 9f2bb8b..2966e2d 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/ShardAllocatorTask.java
@@ -34,4 +34,3 @@ public class ShardAllocatorTask implements Task {
         }
     }
 }
-
diff --git a/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java b/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java
index 5f30307..f99543e 100644
--- a/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java
+++ b/src/main/java/io/clustercontroller/tasks/impl/UnknownTask.java
@@ -27,4 +27,3 @@ public class UnknownTask implements Task {
         return TASK_STATUS_FAILED;
     }
 }
-
diff --git a/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java
index 1350fe8..d2c18cc 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/ActualAllocationUpdaterTaskTest.java
@@ -69,4 +69,3 @@ class ActualAllocationUpdaterTaskTest {
         verify(actualAllocationUpdater).updateActualAllocations();
     }
 }
-
diff --git a/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java
index e89372b..dd0e538 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/ShardAllocatorTaskTest.java
@@ -69,4 +69,3 @@ class ShardAllocatorTaskTest {
         verify(shardAllocator).allocateShards();
     }
 }
-
diff --git a/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java b/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java
index bedcbd6..1a468c3 100644
--- a/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java
+++ b/src/test/java/io/clustercontroller/tasks/impl/UnknownTaskTest.java
@@ -49,4 +49,3 @@ class UnknownTaskTest {
         assertThat(task.getSchedule()).isEqualTo(schedule);
     }
 }
-
-- 
2.50.1


From 5cce5146ff6df8800025a25b77fe621abd2ae19d Mon Sep 17 00:00:00 2001
From: Darby Clement <darbyclement@gmail.com>
Date: Wed, 17 Sep 2025 11:51:05 -0700
Subject: [PATCH 09/12] Index - createIndex basic flow

---
 .../indices/IndexManager.java                 | 100 +++++++-
 .../io/clustercontroller/models/Index.java    |  56 +++++
 .../clustercontroller/models/ShardData.java   |  43 ++++
 .../store/EtcdMetadataStore.java              |  39 ++-
 .../store/MetadataStore.java                  |  12 +
 .../indices/IndexManagerTest.java             | 227 ++++++++++++++++++
 .../store/EtcdMetadataStoreTest.java          |  87 +++++++
 7 files changed, 558 insertions(+), 6 deletions(-)
 create mode 100644 src/main/java/io/clustercontroller/models/Index.java
 create mode 100644 src/main/java/io/clustercontroller/models/ShardData.java
 create mode 100644 src/test/java/io/clustercontroller/indices/IndexManagerTest.java

diff --git a/src/main/java/io/clustercontroller/indices/IndexManager.java b/src/main/java/io/clustercontroller/indices/IndexManager.java
index d770d43..91ae889 100644
--- a/src/main/java/io/clustercontroller/indices/IndexManager.java
+++ b/src/main/java/io/clustercontroller/indices/IndexManager.java
@@ -1,8 +1,19 @@
 package io.clustercontroller.indices;
 
+import com.fasterxml.jackson.annotation.JsonProperty;
+import io.clustercontroller.models.Index;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import io.clustercontroller.models.ShardData;
+import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.store.MetadataStore;
+import lombok.Data;
+import lombok.NoArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
 
+import java.time.OffsetDateTime;
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Manages index lifecycle operations.
  * Internal component used by TaskManager.
@@ -11,14 +22,75 @@ import lombok.extern.slf4j.Slf4j;
 public class IndexManager {
     
     private final MetadataStore metadataStore;
+    private final ObjectMapper objectMapper;
     
     public IndexManager(MetadataStore metadataStore) {
         this.metadataStore = metadataStore;
+        this.objectMapper = new ObjectMapper();
     }
     
-    public void createIndex(String clusterId, String indexName, String indexConfig) {
+    public void createIndex(String clusterId, String indexName, String indexConfig) throws Exception {
         log.info("Creating index {} in cluster {} with config: {}", indexName, clusterId, indexConfig);
-        // TODO: Implement index creation logic
+        
+        // Parse the JSON input to extract index configuration (settings and mappings only)
+        CreateIndexRequest request = parseCreateIndexRequest(indexConfig);
+        
+        log.info("CreateIndex - Parsed index name: {}", indexName);
+        
+        // Validate the parsed input
+        if (indexName == null || indexName.isEmpty()) {
+            throw new Exception("Index name cannot be null or empty");
+        }
+        
+        // Check if index already exists
+        if (metadataStore.getIndexConfig(clusterId, indexName).isPresent()) {
+            log.info("CreateIndex - Index '{}' already exists, skipping creation", indexName);
+            return;
+        }
+        
+        // Get all available search units for allocation planning
+        List<SearchUnit> availableUnits = metadataStore.getAllSearchUnits(clusterId);
+        
+        if (availableUnits.isEmpty()) {
+            throw new Exception("No search units available for index allocation");
+        }
+        
+        // TODO: Determine number of shards from settings, adding default 1 shard for now
+        int numberOfShards = 1;
+        
+        // TODO: Calculate maximum replicas per shard based on available search units
+        List<Integer> shardReplicaCount = new ArrayList<>();
+        shardReplicaCount.add(1);
+        
+        log.info("CreateIndex - Using {} shards with replica count: {}", numberOfShards, shardReplicaCount);
+        
+        // TODO: Create allocation plan
+        List<ShardData> allocationPlan = new ArrayList<>();
+        
+        // Create the new Index configuration
+        Index newIndex = new Index();
+        newIndex.setIndexName(indexName);
+        newIndex.setShardReplicaCount(shardReplicaCount);
+        newIndex.setAllocationPlan(allocationPlan);
+        newIndex.setActive(request.isActive());
+        
+        // Store the index configuration
+        String indexConfigJson = objectMapper.writeValueAsString(newIndex);
+        String documentId = metadataStore.createIndexConfig(clusterId, indexName, indexConfigJson);
+        log.info("CreateIndex - Successfully created index configuration for '{}' with document ID: {}, active: {}", 
+            newIndex.getIndexName(), documentId, newIndex.isActive());
+        
+        // Store mappings if provided
+        if (request.getMappings() != null && !request.getMappings().trim().isEmpty()) {
+            metadataStore.setIndexMappings(clusterId, indexName, request.getMappings());
+            log.info("CreateIndex - Set mappings for index '{}'", indexName);
+        }
+        
+        // Store settings if provided
+        if (request.getSettings() != null && !request.getSettings().trim().isEmpty()) {
+            metadataStore.setIndexSettings(clusterId, indexName, request.getSettings());
+            log.info("CreateIndex - Set settings for index '{}'", indexName);
+        }
     }
     
     public void deleteIndex(String clusterId, String indexName) {
@@ -80,8 +152,28 @@ public class IndexManager {
         throw new UnsupportedOperationException("Update mapping not yet implemented");
     }
     
-    public void planShardAllocation() {
+    public void planShardAllocation() throws Exception {
         log.info("Planning shard allocation");
         // TODO: Implement shard allocation planning logic
     }
-}
+
+    private CreateIndexRequest parseCreateIndexRequest(String input) throws Exception {
+        return objectMapper.readValue(input, CreateIndexRequest.class);
+    }
+
+    /**
+     * Data class to hold parsed create index request
+     */
+    @Data
+    @NoArgsConstructor
+    private static class CreateIndexRequest {
+        @JsonProperty("active")
+        private boolean active = false; // Default to false
+        
+        @JsonProperty("mappings")
+        private String mappings; // Optional mappings JSON
+        
+        @JsonProperty("settings")
+        private String settings; // Optional settings JSON
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/models/Index.java b/src/main/java/io/clustercontroller/models/Index.java
new file mode 100644
index 0000000..97aeb2f
--- /dev/null
+++ b/src/main/java/io/clustercontroller/models/Index.java
@@ -0,0 +1,56 @@
+package io.clustercontroller.models;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import io.clustercontroller.models.ShardData;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Index represents index configuration stored in etcd at:
+ * <cluster-name>/indices/<index-name>/conf
+ */
+@Data
+@NoArgsConstructor
+public class Index {
+    @JsonProperty("id")
+    private String id;
+    
+    @JsonProperty("index_name")
+    private String indexName;
+    
+    @JsonProperty("shard_replica_count")
+    private List<Integer> shardReplicaCount = new ArrayList<>();
+    
+    @JsonProperty("settings")
+    private Map<String, Object> settings;
+    
+    @JsonProperty("mappings")
+    private Map<String, Object> mappings;
+    
+    @JsonProperty("allocation_plan")
+    private List<ShardData> allocationPlan = new ArrayList<>();
+    
+    @JsonProperty("active")
+    private boolean active = false; // Default to false for rolling deployment support
+    
+    @JsonProperty("created_at")
+    private String createdAt = java.time.OffsetDateTime.now().toString(); // ISO timestamp for proper ordering
+    
+    public Index(String indexName, List<Integer> shardReplicaCount) {
+        this.indexName = indexName;
+        this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>();
+        this.allocationPlan = new ArrayList<>();
+    }
+    
+    // Custom setters to maintain null safety
+    public void setShardReplicaCount(List<Integer> shardReplicaCount) { 
+        this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>(); 
+    }
+    
+    public void setAllocationPlan(List<ShardData> allocationPlan) { 
+        this.allocationPlan = allocationPlan != null ? allocationPlan : new ArrayList<>(); 
+    }
+} 
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/models/ShardData.java b/src/main/java/io/clustercontroller/models/ShardData.java
new file mode 100644
index 0000000..27f54cc
--- /dev/null
+++ b/src/main/java/io/clustercontroller/models/ShardData.java
@@ -0,0 +1,43 @@
+package io.clustercontroller.models;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * ShardData represents shard allocation data
+ */
+@Data
+@NoArgsConstructor
+public class ShardData {
+    @JsonProperty("shard_index_name")
+    private String shardIndexName;
+    
+    @JsonProperty("shard_id")
+    private String shardId;
+    
+    @JsonProperty("ingest_units")
+    private List<String> ingestUnits = new ArrayList<>();
+    
+    @JsonProperty("search_units")
+    private List<String> searchUnits = new ArrayList<>();
+    
+    @JsonProperty("status")
+    private String status;
+    
+    public ShardData(String shardIndexName, String shardId) {
+        this.shardIndexName = shardIndexName;
+        this.shardId = shardId;
+    }
+    
+    // Custom setters to maintain null safety
+    public void setIngestUnits(List<String> ingestUnits) { 
+        this.ingestUnits = ingestUnits != null ? ingestUnits : new ArrayList<>(); 
+    }
+    
+    public void setSearchUnits(List<String> searchUnits) { 
+        this.searchUnits = searchUnits != null ? searchUnits : new ArrayList<>(); 
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java b/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
index 4b37b55..e02f427 100644
--- a/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
+++ b/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
@@ -1,5 +1,8 @@
 package io.clustercontroller.store;
 
+import io.clustercontroller.models.Index;
+import io.clustercontroller.config.Constants;
+
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.SerializationFeature;
@@ -421,10 +424,10 @@ public class EtcdMetadataStore implements MetadataStore {
                 return Optional.empty();
             }
             
-            String indexConfig = response.getKvs().get(0).getValue().toString(StandardCharsets.UTF_8);
+            String indexConfigJson = response.getKvs().get(0).getValue().toString(StandardCharsets.UTF_8);
             
             log.debug("Retrieved index config {} from etcd", indexName);
-            return Optional.of(indexConfig);
+            return Optional.of(indexConfigJson);
             
         } catch (Exception e) {
             log.error("Failed to get index config {} from etcd: {}", indexName, e.getMessage(), e);
@@ -478,6 +481,38 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
+    @Override
+    public void setIndexMappings(String clusterId, String indexName, String mappings) throws Exception {
+        log.debug("Setting index mappings for {} in etcd", indexName);
+        
+        try {
+            String mappingsPath = pathResolver.getIndexMappingsPath(clusterId, indexName);
+            executeEtcdPut(mappingsPath, mappings);
+            
+            log.debug("Successfully set index mappings for {} in etcd", indexName);
+            
+        } catch (Exception e) {
+            log.error("Failed to set index mappings for {} in etcd: {}", indexName, e.getMessage(), e);
+            throw new Exception("Failed to set index mappings in etcd", e);
+        }
+    }
+    
+    @Override
+    public void setIndexSettings(String clusterId, String indexName, String settings) throws Exception {
+        log.debug("Setting index settings for {} in etcd", indexName);
+        
+        try {
+            String settingsPath = pathResolver.getIndexSettingsPath(clusterId, indexName);
+            executeEtcdPut(settingsPath, settings);
+            
+            log.debug("Successfully set index settings for {} in etcd", indexName);
+            
+        } catch (Exception e) {
+            log.error("Failed to set index settings for {} in etcd: {}", indexName, e.getMessage(), e);
+            throw new Exception("Failed to set index settings in etcd", e);
+        }
+    }
+    
     // =================================================================
     // CLUSTER OPERATIONS
     // =================================================================
diff --git a/src/main/java/io/clustercontroller/store/MetadataStore.java b/src/main/java/io/clustercontroller/store/MetadataStore.java
index b8a72ef..744d331 100644
--- a/src/main/java/io/clustercontroller/store/MetadataStore.java
+++ b/src/main/java/io/clustercontroller/store/MetadataStore.java
@@ -1,5 +1,7 @@
 package io.clustercontroller.store;
 
+import io.clustercontroller.models.Index;
+
 import io.clustercontroller.models.TaskMetadata;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.models.SearchUnitActualState;
@@ -124,6 +126,16 @@ public interface MetadataStore {
      */
     void deleteIndexConfig(String clusterId, String indexName) throws Exception;
     
+    /**
+     * Set index mappings
+     */
+    void setIndexMappings(String clusterId, String indexName, String mappings) throws Exception;
+    
+    /**
+     * Set index settings
+     */
+    void setIndexSettings(String clusterId, String indexName, String settings) throws Exception;
+    
     // =================================================================
     // CLUSTER OPERATIONS
     // =================================================================
diff --git a/src/test/java/io/clustercontroller/indices/IndexManagerTest.java b/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
new file mode 100644
index 0000000..14ba931
--- /dev/null
+++ b/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
@@ -0,0 +1,227 @@
+package io.clustercontroller.indices;
+
+import io.clustercontroller.models.Index;
+import io.clustercontroller.models.SearchUnit;
+import io.clustercontroller.store.MetadataStore;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.*;
+
+@ExtendWith(MockitoExtension.class)
+class IndexManagerTest {
+
+    @Mock
+    private MetadataStore metadataStore;
+
+    private IndexManager indexManager;
+
+    @BeforeEach
+    void setUp() {
+        indexManager = new IndexManager(metadataStore);
+    }
+
+    @Test
+    void testCreateIndex_Success() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
+        String createIndexRequestJson = """
+            {
+                "active": false,
+                "mappings": "{\\"properties\\": {\\"field1\\": {\\"type\\": \\"text\\"}}}",
+                "settings": "{\\"number_of_shards\\": 1}"
+            }
+            """;
+
+        // Mock dependencies
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-123");
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then
+        ArgumentCaptor<String> indexConfigCaptor = ArgumentCaptor.forClass(String.class);
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), indexConfigCaptor.capture());
+
+        String capturedIndexConfig = indexConfigCaptor.getValue();
+        assertThat(capturedIndexConfig).isNotNull();
+        assertThat(capturedIndexConfig).contains(indexName);
+        assertThat(capturedIndexConfig).contains("false"); // active flag
+
+        verify(metadataStore).getAllSearchUnits(clusterId);
+        
+        // Verify that setIndexMappings and setIndexSettings are called with correct values
+        verify(metadataStore).setIndexMappings(clusterId, indexName, "{\"properties\": {\"field1\": {\"type\": \"text\"}}}");
+        verify(metadataStore).setIndexSettings(clusterId, indexName, "{\"number_of_shards\": 1}");
+    }
+
+    @Test
+    void testCreateIndex_WithActiveFlag() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "active-index";
+        String createIndexRequestJson = """
+            {
+                "active": true
+            }
+            """;
+        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
+
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-456");
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then
+        ArgumentCaptor<String> indexConfigCaptor = ArgumentCaptor.forClass(String.class);
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), indexConfigCaptor.capture());
+
+        String capturedIndexConfig = indexConfigCaptor.getValue();
+        assertThat(capturedIndexConfig).isNotNull();
+        assertThat(capturedIndexConfig).contains(indexName);
+        assertThat(capturedIndexConfig).contains("true"); // active flag
+    }
+
+    @Test
+    void testCreateIndex_NoAvailableSearchUnits() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        String createIndexRequestJson = """
+            {
+                "active": false
+            }
+            """;
+
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(new ArrayList<>());
+
+        // When & Then
+        assertThatThrownBy(() -> indexManager.createIndex(clusterId, indexName, createIndexRequestJson))
+                .isInstanceOf(Exception.class)
+                .hasMessage("No search units available for index allocation");
+    }
+
+    @Test
+    void testCreateIndex_InvalidJson() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        String invalidJson = "invalid json";
+
+        // When & Then
+        assertThatThrownBy(() -> indexManager.createIndex(clusterId, indexName, invalidJson))
+                .isInstanceOf(Exception.class);
+    }
+
+    @Test
+    void testCreateIndex_IndexAlreadyExists() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "existing-index";
+        String createIndexRequestJson = """
+            {
+                "active": false
+            }
+            """;
+
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.of("existing-config"));
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then
+        verify(metadataStore, never()).createIndexConfig(any(), any(), any());
+        verify(metadataStore, never()).getAllSearchUnits(any());
+    }
+
+    @Test
+    void testDeleteIndex() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+
+        // When
+        indexManager.deleteIndex(clusterId, indexName);
+
+        // Then
+        // Verify the method was called (implementation is TODO)
+        verify(metadataStore, never()).deleteIndexConfig(any(), any());
+    }
+
+    @Test
+    void testCreateIndex_DefaultValues() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        String createIndexRequestJson = "{}"; // Empty JSON should use defaults
+        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
+
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-789");
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then
+        ArgumentCaptor<String> indexConfigCaptor = ArgumentCaptor.forClass(String.class);
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), indexConfigCaptor.capture());
+
+        String capturedIndexConfig = indexConfigCaptor.getValue();
+        assertThat(capturedIndexConfig).isNotNull();
+        assertThat(capturedIndexConfig).contains(indexName);
+        assertThat(capturedIndexConfig).contains("false"); // default active flag
+    }
+
+    @Test
+    void testCreateIndex_WithoutMappingsAndSettings() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        String createIndexRequestJson = """
+            {
+                "active": false
+            }
+            """;
+        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
+
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-999");
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), any(String.class));
+        verify(metadataStore, never()).setIndexMappings(any(), any(), any());
+        verify(metadataStore, never()).setIndexSettings(any(), any(), any());
+    }
+
+    private List<SearchUnit> createMockSearchUnits() {
+        List<SearchUnit> searchUnits = new ArrayList<>();
+        SearchUnit unit = new SearchUnit();
+        unit.setName("test-unit-1");
+        searchUnits.add(unit);
+        return searchUnits;
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java b/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java
index fcc42fc..d31162a 100644
--- a/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java
+++ b/src/test/java/io/clustercontroller/store/EtcdMetadataStoreTest.java
@@ -1,6 +1,7 @@
 package io.clustercontroller.store;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
+import io.clustercontroller.models.Index;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.models.TaskMetadata;
 import io.etcd.jetcd.*;
@@ -10,6 +11,7 @@ import io.etcd.jetcd.KeyValue;
 import io.etcd.jetcd.kv.PutResponse;
 import io.etcd.jetcd.options.GetOption;
 import org.junit.jupiter.api.*;
+import org.mockito.ArgumentCaptor;
 import org.mockito.MockedStatic;
 import org.mockito.Mockito;
 
@@ -21,6 +23,7 @@ import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.*;
 import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
@@ -444,6 +447,90 @@ public class EtcdMetadataStoreTest {
                 .hasMessageContaining("Failed to delete index config from etcd");
     }
 
+    @Test
+    public void testSetIndexMappings() throws Exception {
+        EtcdMetadataStore store = newStore();
+        String indexName = "test-index";
+        String mappings = "{\"properties\": {\"field1\": {\"type\": \"text\"}}}";
+
+        // Mock successful put response
+        PutResponse mockPutResponse = mock(PutResponse.class);
+        when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
+                .thenReturn(CompletableFuture.completedFuture(mockPutResponse));
+
+        // Execute
+        store.setIndexMappings("test-cluster", indexName, mappings);
+
+        // Verify the put call was made with correct key and value
+        ArgumentCaptor<ByteSequence> keyCaptor = ArgumentCaptor.forClass(ByteSequence.class);
+        ArgumentCaptor<ByteSequence> valueCaptor = ArgumentCaptor.forClass(ByteSequence.class);
+        verify(mockKv).put(keyCaptor.capture(), valueCaptor.capture());
+
+        String capturedKey = keyCaptor.getValue().toString(UTF_8);
+        String capturedValue = valueCaptor.getValue().toString(UTF_8);
+
+        assertThat(capturedKey).contains("test-cluster/indices/test-index/mappings");
+        assertThat(capturedValue).isEqualTo(mappings);
+    }
+
+    @Test
+    public void testSetIndexMappingsWithException() throws Exception {
+        EtcdMetadataStore store = newStore();
+        String indexName = "test-index";
+        String mappings = "{\"properties\": {\"field1\": {\"type\": \"text\"}}}";
+
+        // Mock etcd failure
+        when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
+                .thenReturn(CompletableFuture.failedFuture(new RuntimeException("etcd connection failed")));
+
+        // Verify exception is propagated
+        assertThatThrownBy(() -> store.setIndexMappings("test-cluster", indexName, mappings))
+                .isInstanceOf(Exception.class)
+                .hasMessageContaining("Failed to set index mappings in etcd");
+    }
+
+    @Test
+    public void testSetIndexSettings() throws Exception {
+        EtcdMetadataStore store = newStore();
+        String indexName = "test-index";
+        String settings = "{\"number_of_shards\": 1, \"number_of_replicas\": 2}";
+
+        // Mock successful put response
+        PutResponse mockPutResponse = mock(PutResponse.class);
+        when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
+                .thenReturn(CompletableFuture.completedFuture(mockPutResponse));
+
+        // Execute
+        store.setIndexSettings("test-cluster", indexName, settings);
+
+        // Verify the put call was made with correct key and value
+        ArgumentCaptor<ByteSequence> keyCaptor = ArgumentCaptor.forClass(ByteSequence.class);
+        ArgumentCaptor<ByteSequence> valueCaptor = ArgumentCaptor.forClass(ByteSequence.class);
+        verify(mockKv).put(keyCaptor.capture(), valueCaptor.capture());
+
+        String capturedKey = keyCaptor.getValue().toString(UTF_8);
+        String capturedValue = valueCaptor.getValue().toString(UTF_8);
+
+        assertThat(capturedKey).contains("test-cluster/indices/test-index/settings");
+        assertThat(capturedValue).isEqualTo(settings);
+    }
+
+    @Test
+    public void testSetIndexSettingsWithException() throws Exception {
+        EtcdMetadataStore store = newStore();
+        String indexName = "test-index";
+        String settings = "{\"number_of_shards\": 1}";
+
+        // Mock etcd failure
+        when(mockKv.put(any(ByteSequence.class), any(ByteSequence.class)))
+                .thenReturn(CompletableFuture.failedFuture(new RuntimeException("etcd timeout")));
+
+        // Verify exception is propagated
+        assertThatThrownBy(() -> store.setIndexSettings("test-cluster", indexName, settings))
+                .isInstanceOf(Exception.class)
+                .hasMessageContaining("Failed to set index settings in etcd");
+    }
+
     // ------------------------- lifecycle -------------------------
 
     @Test
-- 
2.50.1


From decfc5b7cf3dfe74de60d9e6aeb1ce9da20e2db8 Mon Sep 17 00:00:00 2001
From: Darby Clement <darbyclement@gmail.com>
Date: Wed, 17 Sep 2025 14:57:48 -0700
Subject: [PATCH 10/12] remove unneeded active param

Signed-off-by: Darby Clement <darbyclement@gmail.com>
---
 .../indices/IndexManager.java                 |  8 ++---
 .../io/clustercontroller/models/Index.java    |  3 --
 .../indices/IndexManagerTest.java             | 34 -------------------
 3 files changed, 2 insertions(+), 43 deletions(-)

diff --git a/src/main/java/io/clustercontroller/indices/IndexManager.java b/src/main/java/io/clustercontroller/indices/IndexManager.java
index 91ae889..f308900 100644
--- a/src/main/java/io/clustercontroller/indices/IndexManager.java
+++ b/src/main/java/io/clustercontroller/indices/IndexManager.java
@@ -72,13 +72,12 @@ public class IndexManager {
         newIndex.setIndexName(indexName);
         newIndex.setShardReplicaCount(shardReplicaCount);
         newIndex.setAllocationPlan(allocationPlan);
-        newIndex.setActive(request.isActive());
         
         // Store the index configuration
         String indexConfigJson = objectMapper.writeValueAsString(newIndex);
         String documentId = metadataStore.createIndexConfig(clusterId, indexName, indexConfigJson);
-        log.info("CreateIndex - Successfully created index configuration for '{}' with document ID: {}, active: {}", 
-            newIndex.getIndexName(), documentId, newIndex.isActive());
+        log.info("CreateIndex - Successfully created index configuration for '{}' with document ID: {}", 
+            newIndex.getIndexName(), documentId);
         
         // Store mappings if provided
         if (request.getMappings() != null && !request.getMappings().trim().isEmpty()) {
@@ -167,9 +166,6 @@ public class IndexManager {
     @Data
     @NoArgsConstructor
     private static class CreateIndexRequest {
-        @JsonProperty("active")
-        private boolean active = false; // Default to false
-        
         @JsonProperty("mappings")
         private String mappings; // Optional mappings JSON
         
diff --git a/src/main/java/io/clustercontroller/models/Index.java b/src/main/java/io/clustercontroller/models/Index.java
index 97aeb2f..9a76197 100644
--- a/src/main/java/io/clustercontroller/models/Index.java
+++ b/src/main/java/io/clustercontroller/models/Index.java
@@ -33,9 +33,6 @@ public class Index {
     @JsonProperty("allocation_plan")
     private List<ShardData> allocationPlan = new ArrayList<>();
     
-    @JsonProperty("active")
-    private boolean active = false; // Default to false for rolling deployment support
-    
     @JsonProperty("created_at")
     private String createdAt = java.time.OffsetDateTime.now().toString(); // ISO timestamp for proper ordering
     
diff --git a/src/test/java/io/clustercontroller/indices/IndexManagerTest.java b/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
index 14ba931..2e8d208 100644
--- a/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
+++ b/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
@@ -41,7 +41,6 @@ class IndexManagerTest {
         List<SearchUnit> availableSearchUnits = createMockSearchUnits();
         String createIndexRequestJson = """
             {
-                "active": false,
                 "mappings": "{\\"properties\\": {\\"field1\\": {\\"type\\": \\"text\\"}}}",
                 "settings": "{\\"number_of_shards\\": 1}"
             }
@@ -62,7 +61,6 @@ class IndexManagerTest {
         String capturedIndexConfig = indexConfigCaptor.getValue();
         assertThat(capturedIndexConfig).isNotNull();
         assertThat(capturedIndexConfig).contains(indexName);
-        assertThat(capturedIndexConfig).contains("false"); // active flag
 
         verify(metadataStore).getAllSearchUnits(clusterId);
         
@@ -71,34 +69,6 @@ class IndexManagerTest {
         verify(metadataStore).setIndexSettings(clusterId, indexName, "{\"number_of_shards\": 1}");
     }
 
-    @Test
-    void testCreateIndex_WithActiveFlag() throws Exception {
-        // Given
-        String clusterId = "test-cluster";
-        String indexName = "active-index";
-        String createIndexRequestJson = """
-            {
-                "active": true
-            }
-            """;
-        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
-
-        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
-        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
-        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-456");
-
-        // When
-        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
-
-        // Then
-        ArgumentCaptor<String> indexConfigCaptor = ArgumentCaptor.forClass(String.class);
-        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), indexConfigCaptor.capture());
-
-        String capturedIndexConfig = indexConfigCaptor.getValue();
-        assertThat(capturedIndexConfig).isNotNull();
-        assertThat(capturedIndexConfig).contains(indexName);
-        assertThat(capturedIndexConfig).contains("true"); // active flag
-    }
 
     @Test
     void testCreateIndex_NoAvailableSearchUnits() throws Exception {
@@ -107,7 +77,6 @@ class IndexManagerTest {
         String indexName = "test-index";
         String createIndexRequestJson = """
             {
-                "active": false
             }
             """;
 
@@ -139,7 +108,6 @@ class IndexManagerTest {
         String indexName = "existing-index";
         String createIndexRequestJson = """
             {
-                "active": false
             }
             """;
 
@@ -189,7 +157,6 @@ class IndexManagerTest {
         String capturedIndexConfig = indexConfigCaptor.getValue();
         assertThat(capturedIndexConfig).isNotNull();
         assertThat(capturedIndexConfig).contains(indexName);
-        assertThat(capturedIndexConfig).contains("false"); // default active flag
     }
 
     @Test
@@ -199,7 +166,6 @@ class IndexManagerTest {
         String indexName = "test-index";
         String createIndexRequestJson = """
             {
-                "active": false
             }
             """;
         List<SearchUnit> availableSearchUnits = createMockSearchUnits();
-- 
2.50.1


From 48d53d06330b834040ee8506440e004fde82ac53 Mon Sep 17 00:00:00 2001
From: Darby Clement <darbyclement@gmail.com>
Date: Wed, 24 Sep 2025 11:24:03 -0700
Subject: [PATCH 11/12] Addressing comments

---
 .../ClusterControllerApplication.java         |  2 +-
 .../indices/IndexManager.java                 | 62 ++++++++++-------
 .../io/clustercontroller/models/Index.java    | 14 ----
 .../clustercontroller/models/ShardData.java   | 43 ------------
 .../indices/IndexManagerTest.java             | 69 ++++++++++++++-----
 5 files changed, 91 insertions(+), 99 deletions(-)
 delete mode 100644 src/main/java/io/clustercontroller/models/ShardData.java

diff --git a/src/main/java/io/clustercontroller/ClusterControllerApplication.java b/src/main/java/io/clustercontroller/ClusterControllerApplication.java
index 2160c73..3d1951a 100644
--- a/src/main/java/io/clustercontroller/ClusterControllerApplication.java
+++ b/src/main/java/io/clustercontroller/ClusterControllerApplication.java
@@ -68,7 +68,7 @@ public class ClusterControllerApplication {
     public MetadataStore metadataStore(ClusterControllerConfig config) {
         log.info("Initializing cluster-agnostic MetadataStore connection to etcd");
         try {
-            EtcdMetadataStore store = EtcdMetadataStore.getInstance();
+            EtcdMetadataStore store = EtcdMetadataStore.getInstance(config.getEtcdEndpoints());
             store.initialize();
             log.info("MetadataStore initialized successfully");
             return store;
diff --git a/src/main/java/io/clustercontroller/indices/IndexManager.java b/src/main/java/io/clustercontroller/indices/IndexManager.java
index f308900..581ff42 100644
--- a/src/main/java/io/clustercontroller/indices/IndexManager.java
+++ b/src/main/java/io/clustercontroller/indices/IndexManager.java
@@ -3,16 +3,15 @@ package io.clustercontroller.indices;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.clustercontroller.models.Index;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import io.clustercontroller.models.ShardData;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.store.MetadataStore;
 import lombok.Data;
 import lombok.NoArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
 
-import java.time.OffsetDateTime;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Manages index lifecycle operations.
@@ -48,15 +47,8 @@ public class IndexManager {
             return;
         }
         
-        // Get all available search units for allocation planning
-        List<SearchUnit> availableUnits = metadataStore.getAllSearchUnits(clusterId);
-        
-        if (availableUnits.isEmpty()) {
-            throw new Exception("No search units available for index allocation");
-        }
-        
-        // TODO: Determine number of shards from settings, adding default 1 shard for now
-        int numberOfShards = 1;
+        // Extract number of shards from settings, defaulting to 1 if not specified
+        int numberOfShards = extractNumberOfShards(request.getSettings());
         
         // TODO: Calculate maximum replicas per shard based on available search units
         List<Integer> shardReplicaCount = new ArrayList<>();
@@ -64,14 +56,10 @@ public class IndexManager {
         
         log.info("CreateIndex - Using {} shards with replica count: {}", numberOfShards, shardReplicaCount);
         
-        // TODO: Create allocation plan
-        List<ShardData> allocationPlan = new ArrayList<>();
-        
         // Create the new Index configuration
         Index newIndex = new Index();
         newIndex.setIndexName(indexName);
         newIndex.setShardReplicaCount(shardReplicaCount);
-        newIndex.setAllocationPlan(allocationPlan);
         
         // Store the index configuration
         String indexConfigJson = objectMapper.writeValueAsString(newIndex);
@@ -80,14 +68,16 @@ public class IndexManager {
             newIndex.getIndexName(), documentId);
         
         // Store mappings if provided
-        if (request.getMappings() != null && !request.getMappings().trim().isEmpty()) {
-            metadataStore.setIndexMappings(clusterId, indexName, request.getMappings());
+        if (request.getMappings() != null && !request.getMappings().isEmpty()) {
+            String mappingsJson = objectMapper.writeValueAsString(request.getMappings());
+            metadataStore.setIndexMappings(clusterId, indexName, mappingsJson);
             log.info("CreateIndex - Set mappings for index '{}'", indexName);
         }
         
         // Store settings if provided
-        if (request.getSettings() != null && !request.getSettings().trim().isEmpty()) {
-            metadataStore.setIndexSettings(clusterId, indexName, request.getSettings());
+        if (request.getSettings() != null && !request.getSettings().isEmpty()) {
+            String settingsJson = objectMapper.writeValueAsString(request.getSettings());
+            metadataStore.setIndexSettings(clusterId, indexName, settingsJson);
             log.info("CreateIndex - Set settings for index '{}'", indexName);
         }
     }
@@ -151,15 +141,37 @@ public class IndexManager {
         throw new UnsupportedOperationException("Update mapping not yet implemented");
     }
     
-    public void planShardAllocation() throws Exception {
-        log.info("Planning shard allocation");
-        // TODO: Implement shard allocation planning logic
-    }
 
     private CreateIndexRequest parseCreateIndexRequest(String input) throws Exception {
         return objectMapper.readValue(input, CreateIndexRequest.class);
     }
 
+    /**
+     * Extract the number of shards from the settings map.
+     * Returns 1 as default if not specified or if parsing fails.
+     */
+    private int extractNumberOfShards(Map<String, Object> settings) {
+        if (settings == null || settings.isEmpty()) {
+            log.debug("No settings provided, using default number of shards: 1");
+            return 1;
+        }
+        
+        try {
+            Object shardsObj = settings.get("number_of_shards");
+            if (shardsObj != null) {
+                int shards = ((Number) shardsObj).intValue();
+                log.debug("Extracted number_of_shards from settings: {}", shards);
+                return shards;
+            } else {
+                log.debug("number_of_shards not found in settings, using default: 1");
+                return 1;
+            }
+        } catch (Exception e) {
+            log.warn("Failed to extract number_of_shards from settings, using default: 1. Error: {}", e.getMessage());
+            return 1;
+        }
+    }
+
     /**
      * Data class to hold parsed create index request
      */
@@ -167,9 +179,9 @@ public class IndexManager {
     @NoArgsConstructor
     private static class CreateIndexRequest {
         @JsonProperty("mappings")
-        private String mappings; // Optional mappings JSON
+        private Map<String, Object> mappings; // Optional mappings JSON
         
         @JsonProperty("settings")
-        private String settings; // Optional settings JSON
+        private Map<String, Object> settings; // Optional settings JSON
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/models/Index.java b/src/main/java/io/clustercontroller/models/Index.java
index 9a76197..db2bd23 100644
--- a/src/main/java/io/clustercontroller/models/Index.java
+++ b/src/main/java/io/clustercontroller/models/Index.java
@@ -1,7 +1,6 @@
 package io.clustercontroller.models;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
-import io.clustercontroller.models.ShardData;
 import lombok.Data;
 import lombok.NoArgsConstructor;
 import java.util.ArrayList;
@@ -24,14 +23,6 @@ public class Index {
     @JsonProperty("shard_replica_count")
     private List<Integer> shardReplicaCount = new ArrayList<>();
     
-    @JsonProperty("settings")
-    private Map<String, Object> settings;
-    
-    @JsonProperty("mappings")
-    private Map<String, Object> mappings;
-    
-    @JsonProperty("allocation_plan")
-    private List<ShardData> allocationPlan = new ArrayList<>();
     
     @JsonProperty("created_at")
     private String createdAt = java.time.OffsetDateTime.now().toString(); // ISO timestamp for proper ordering
@@ -39,15 +30,10 @@ public class Index {
     public Index(String indexName, List<Integer> shardReplicaCount) {
         this.indexName = indexName;
         this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>();
-        this.allocationPlan = new ArrayList<>();
     }
     
     // Custom setters to maintain null safety
     public void setShardReplicaCount(List<Integer> shardReplicaCount) { 
         this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>(); 
     }
-    
-    public void setAllocationPlan(List<ShardData> allocationPlan) { 
-        this.allocationPlan = allocationPlan != null ? allocationPlan : new ArrayList<>(); 
-    }
 } 
\ No newline at end of file
diff --git a/src/main/java/io/clustercontroller/models/ShardData.java b/src/main/java/io/clustercontroller/models/ShardData.java
deleted file mode 100644
index 27f54cc..0000000
--- a/src/main/java/io/clustercontroller/models/ShardData.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package io.clustercontroller.models;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-import lombok.Data;
-import lombok.NoArgsConstructor;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * ShardData represents shard allocation data
- */
-@Data
-@NoArgsConstructor
-public class ShardData {
-    @JsonProperty("shard_index_name")
-    private String shardIndexName;
-    
-    @JsonProperty("shard_id")
-    private String shardId;
-    
-    @JsonProperty("ingest_units")
-    private List<String> ingestUnits = new ArrayList<>();
-    
-    @JsonProperty("search_units")
-    private List<String> searchUnits = new ArrayList<>();
-    
-    @JsonProperty("status")
-    private String status;
-    
-    public ShardData(String shardIndexName, String shardId) {
-        this.shardIndexName = shardIndexName;
-        this.shardId = shardId;
-    }
-    
-    // Custom setters to maintain null safety
-    public void setIngestUnits(List<String> ingestUnits) { 
-        this.ingestUnits = ingestUnits != null ? ingestUnits : new ArrayList<>(); 
-    }
-    
-    public void setSearchUnits(List<String> searchUnits) { 
-        this.searchUnits = searchUnits != null ? searchUnits : new ArrayList<>(); 
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/io/clustercontroller/indices/IndexManagerTest.java b/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
index 2e8d208..eb76f8b 100644
--- a/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
+++ b/src/test/java/io/clustercontroller/indices/IndexManagerTest.java
@@ -1,6 +1,5 @@
 package io.clustercontroller.indices;
 
-import io.clustercontroller.models.Index;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.store.MetadataStore;
 import org.junit.jupiter.api.BeforeEach;
@@ -41,14 +40,13 @@ class IndexManagerTest {
         List<SearchUnit> availableSearchUnits = createMockSearchUnits();
         String createIndexRequestJson = """
             {
-                "mappings": "{\\"properties\\": {\\"field1\\": {\\"type\\": \\"text\\"}}}",
-                "settings": "{\\"number_of_shards\\": 1}"
+                "mappings": {"properties": {"field1": {"type": "text"}}},
+                "settings": {"number_of_shards": 1}
             }
             """;
 
         // Mock dependencies
         when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
-        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
         when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-123");
 
         // When
@@ -62,11 +60,11 @@ class IndexManagerTest {
         assertThat(capturedIndexConfig).isNotNull();
         assertThat(capturedIndexConfig).contains(indexName);
 
-        verify(metadataStore).getAllSearchUnits(clusterId);
+        // getAllSearchUnits is no longer called since the check was removed
         
         // Verify that setIndexMappings and setIndexSettings are called with correct values
-        verify(metadataStore).setIndexMappings(clusterId, indexName, "{\"properties\": {\"field1\": {\"type\": \"text\"}}}");
-        verify(metadataStore).setIndexSettings(clusterId, indexName, "{\"number_of_shards\": 1}");
+        verify(metadataStore).setIndexMappings(clusterId, indexName, "{\"properties\":{\"field1\":{\"type\":\"text\"}}}");
+        verify(metadataStore).setIndexSettings(clusterId, indexName, "{\"number_of_shards\":1}");
     }
 
 
@@ -81,12 +79,13 @@ class IndexManagerTest {
             """;
 
         when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
-        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(new ArrayList<>());
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-123");
 
-        // When & Then
-        assertThatThrownBy(() -> indexManager.createIndex(clusterId, indexName, createIndexRequestJson))
-                .isInstanceOf(Exception.class)
-                .hasMessage("No search units available for index allocation");
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then - should succeed even without search units (search units check was removed)
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), any(String.class));
     }
 
     @Test
@@ -141,10 +140,8 @@ class IndexManagerTest {
         String clusterId = "test-cluster";
         String indexName = "test-index";
         String createIndexRequestJson = "{}"; // Empty JSON should use defaults
-        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
 
         when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
-        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
         when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-789");
 
         // When
@@ -168,10 +165,8 @@ class IndexManagerTest {
             {
             }
             """;
-        List<SearchUnit> availableSearchUnits = createMockSearchUnits();
 
         when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
-        when(metadataStore.getAllSearchUnits(clusterId)).thenReturn(availableSearchUnits);
         when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-999");
 
         // When
@@ -183,6 +178,48 @@ class IndexManagerTest {
         verify(metadataStore, never()).setIndexSettings(any(), any(), any());
     }
 
+    @Test
+    void testCreateIndex_WithCustomNumberOfShards() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        String createIndexRequestJson = """
+            {
+                "settings": {"number_of_shards": 3, "number_of_replicas": 1}
+            }
+            """;
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-456");
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), any(String.class));
+        verify(metadataStore).setIndexSettings(clusterId, indexName, "{\"number_of_shards\":3,\"number_of_replicas\":1}");
+    }
+
+    @Test
+    void testCreateIndex_WithInvalidSettingsJson() throws Exception {
+        // Given
+        String clusterId = "test-cluster";
+        String indexName = "test-index";
+        String createIndexRequestJson = """
+            {
+                "settings": {"invalid_field": "invalid_value"}
+            }
+            """;
+        when(metadataStore.getIndexConfig(clusterId, indexName)).thenReturn(Optional.empty());
+        when(metadataStore.createIndexConfig(eq(clusterId), eq(indexName), any(String.class))).thenReturn("doc-id-789");
+
+        // When
+        indexManager.createIndex(clusterId, indexName, createIndexRequestJson);
+
+        // Then - should still work with default shard count (1) even with invalid settings
+        verify(metadataStore).createIndexConfig(eq(clusterId), eq(indexName), any(String.class));
+        verify(metadataStore).setIndexSettings(clusterId, indexName, "{\"invalid_field\":\"invalid_value\"}");
+    }
+
     private List<SearchUnit> createMockSearchUnits() {
         List<SearchUnit> searchUnits = new ArrayList<>();
         SearchUnit unit = new SearchUnit();
-- 
2.50.1


From d8872bab384e41174e8e63875295518b5fe7dea9 Mon Sep 17 00:00:00 2001
From: Darby Clement <darbyclement@gmail.com>
Date: Wed, 24 Sep 2025 15:05:15 -0700
Subject: [PATCH 12/12] Implement deleteIndex with simplified shard allocation
 cleanup

- Add deleteIndex method to IndexManager with complete cleanup
- Add numShards field to Index model for efficient shard count access
- Implement deleteAllPlannedAllocationsFromIndex using direct shard deletion (0 to numShards-1)
- Add deleteIndexSettings and deleteIndexMappings to MetadataStore interface
- Implement corresponding methods in EtcdMetadataStore
- Add ShardAllocation model for planned allocation tracking
- Update IndexHandlerTest to handle Exception from deleteIndex
- Remove getAllPlannedAllocations method (no longer needed with simplified approach)
- Store numShards in Index during creation for efficient deletion
---
 .../indices/IndexManager.java                 | 159 +++++++++++++++++-
 .../io/clustercontroller/models/Index.java    |   8 +
 .../models/ShardAllocation.java               |  24 +++
 .../store/EtcdMetadataStore.java              |  71 ++++++++
 .../store/MetadataStore.java                  |  25 ++-
 .../api/handlers/IndexHandlerTest.java        |   4 +-
 6 files changed, 284 insertions(+), 7 deletions(-)
 create mode 100644 src/main/java/io/clustercontroller/models/ShardAllocation.java

diff --git a/src/main/java/io/clustercontroller/indices/IndexManager.java b/src/main/java/io/clustercontroller/indices/IndexManager.java
index 581ff42..c5c00d8 100644
--- a/src/main/java/io/clustercontroller/indices/IndexManager.java
+++ b/src/main/java/io/clustercontroller/indices/IndexManager.java
@@ -2,8 +2,10 @@ package io.clustercontroller.indices;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.clustercontroller.models.Index;
-import com.fasterxml.jackson.databind.ObjectMapper;
+import io.clustercontroller.models.ShardAllocation;
 import io.clustercontroller.models.SearchUnit;
+import io.clustercontroller.models.SearchUnitGoalState;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import io.clustercontroller.store.MetadataStore;
 import lombok.Data;
 import lombok.NoArgsConstructor;
@@ -12,6 +14,7 @@ import lombok.extern.slf4j.Slf4j;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 
 /**
  * Manages index lifecycle operations.
@@ -60,6 +63,7 @@ public class IndexManager {
         Index newIndex = new Index();
         newIndex.setIndexName(indexName);
         newIndex.setShardReplicaCount(shardReplicaCount);
+        newIndex.setNumShards(numberOfShards);
         
         // Store the index configuration
         String indexConfigJson = objectMapper.writeValueAsString(newIndex);
@@ -82,9 +86,59 @@ public class IndexManager {
         }
     }
     
-    public void deleteIndex(String clusterId, String indexName) {
-        log.info("Deleting index {} from cluster {}", indexName, clusterId);
-        // TODO: Implement index deletion logic
+    public void deleteIndex(String clusterId, String indexName) throws Exception {
+        log.info("DeleteIndex - Starting deletion of index '{}' from cluster '{}'", indexName, clusterId);
+
+        // Validate input parameters
+        if (indexName == null || indexName.trim().isEmpty()) {
+            throw new Exception("Index name cannot be null or empty");
+        }
+        if (clusterId == null || clusterId.trim().isEmpty()) {
+            throw new Exception("Cluster ID cannot be null or empty");
+        }
+
+        // Check if index exists
+        if (!metadataStore.getIndexConfig(clusterId, indexName).isPresent()) {
+            log.warn("DeleteIndex - Index '{}' not found in cluster '{}', nothing to delete", indexName, clusterId);
+            return;
+        }
+
+        try {
+            // Step 1: Remove all planned allocations for this index
+            deleteAllPlannedAllocationsFromIndex(clusterId, indexName);
+
+            // Step 2: Delete the index configuration from etcd
+            metadataStore.deleteIndexConfig(clusterId, indexName);
+            log.info("DeleteIndex - Successfully deleted index configuration for '{}' from cluster '{}'", 
+                indexName, clusterId);
+
+            // Step 3: Delete index settings and mappings
+            try {
+                metadataStore.deleteIndexSettings(clusterId, indexName);
+                log.info("DeleteIndex - Successfully deleted index settings for '{}' from cluster '{}'", 
+                    indexName, clusterId);
+            } catch (Exception e) {
+                log.warn("DeleteIndex - Failed to delete settings for '{}': {}", indexName, e.getMessage());
+            }
+
+            try {
+                metadataStore.deleteIndexMappings(clusterId, indexName);
+                log.info("DeleteIndex - Successfully deleted index mappings for '{}' from cluster '{}'", 
+                    indexName, clusterId);
+            } catch (Exception e) {
+                log.warn("DeleteIndex - Failed to delete mappings for '{}': {}", indexName, e.getMessage());
+            }
+
+            // Step 4: Clean up goal states for this deleted index
+            cleanupGoalStatesForDeletedIndex(clusterId, indexName);
+
+        } catch (Exception e) {
+            log.error("DeleteIndex - Failed to delete index '{}' from cluster '{}': {}", 
+                indexName, clusterId, e.getMessage(), e);
+            throw new Exception("Failed to delete index '" + indexName + "' from cluster '" + clusterId + "'", e);
+        }
+
+        log.info("DeleteIndex - Index '{}' deletion completed successfully from cluster '{}'", indexName, clusterId);
     }
     
     /**
@@ -146,6 +200,103 @@ public class IndexManager {
         return objectMapper.readValue(input, CreateIndexRequest.class);
     }
 
+    /**
+     * Delete all planned allocations from an index
+     */
+    private void deleteAllPlannedAllocationsFromIndex(String clusterId, String indexName) throws Exception {
+        log.info("DeleteIndex - Cleaning up ALL planned allocations from index '{}'", indexName);
+
+        try {
+            // Get the index configuration to determine number of shards
+            Optional<String> indexConfigOpt = metadataStore.getIndexConfig(clusterId, indexName);
+            if (!indexConfigOpt.isPresent()) {
+                log.warn("DeleteIndex - Index '{}' not found, skipping planned allocation cleanup", indexName);
+                return;
+            }
+
+            // Parse the index configuration to get number of shards
+            Index index = objectMapper.readValue(indexConfigOpt.get(), Index.class);
+            int numShards = index.getNumShards() != null ? index.getNumShards() : 1;
+
+            log.info("DeleteIndex - Deleting planned allocations for {} shards from index '{}'", numShards, indexName);
+
+            // Delete planned allocations for shards 0 to numShards-1
+            for (int shardId = 0; shardId < numShards; shardId++) {
+                try {
+                    metadataStore.deletePlannedAllocation(clusterId, indexName, String.valueOf(shardId));
+                } catch (Exception e) {
+                    log.warn("DeleteIndex - Failed to delete planned allocation {}/{}: {}", 
+                        indexName, shardId, e.getMessage());
+                }
+            }
+
+            log.info("DeleteIndex - Cleaned up planned allocations for {} shards from index '{}'", 
+                numShards, indexName);
+
+        } catch (Exception e) {
+            log.error("DeleteIndex - Failed to cleanup planned allocations from index '{}': {}", 
+                indexName, e.getMessage());
+            throw e;
+        }
+    }
+
+    /**
+     * Cleans up goal states (local shards) for an index from all search units
+     */
+    private void cleanupGoalStatesForDeletedIndex(String clusterId, String deletedIndexName) throws Exception {
+        log.info("DeleteIndex - Starting immediate goal state cleanup for deleted index '{}'", deletedIndexName);
+
+        try {
+            // Get all search units to check their goal states
+            List<SearchUnit> allSearchUnits = metadataStore.getAllSearchUnits(clusterId);
+
+            for (SearchUnit searchUnit : allSearchUnits) {
+                String unitName = searchUnit.getName();
+
+                try {
+                    // Get current goal state for this unit
+                    Optional<SearchUnitGoalState> goalStateOpt = metadataStore.getSearchUnitGoalState(clusterId, unitName);
+
+                    if (!goalStateOpt.isPresent()) {
+                        log.debug("DeleteIndex - No goal state found for unit '{}'", unitName);
+                        continue;
+                    }
+
+                    SearchUnitGoalState goalState = goalStateOpt.get();
+
+                    // Check if this unit has the deleted index in its goal state
+                    if (!goalState.getLocalShards().containsKey(deletedIndexName)) {
+                        log.debug("DeleteIndex - Unit '{}' does not have deleted index '{}' in goal state", 
+                            unitName, deletedIndexName);
+                        continue;
+                    }
+
+                    // Remove the deleted index from goal state
+                    Map<String, Map<String, String>> localShards = goalState.getLocalShards();
+                    localShards.remove(deletedIndexName);
+
+                    // Save updated goal state
+                    metadataStore.updateSearchUnitGoalState(clusterId, unitName, goalState);
+
+                    log.info("DeleteIndex - Removed deleted index '{}' from goal state of unit '{}'", 
+                        deletedIndexName, unitName);
+
+                } catch (Exception e) {
+                    log.error("DeleteIndex - Failed to cleanup goal state for unit '{}': {}", 
+                        unitName, e.getMessage(), e);
+                }
+            }
+
+        } catch (Exception e) {
+            log.error("DeleteIndex - Failed to get search units for goal state cleanup: {}", 
+                e.getMessage(), e);
+            throw e;
+        }
+
+        log.info("DeleteIndex - Completed immediate goal state cleanup for deleted index '{}'", 
+            deletedIndexName);
+    }
+
     /**
      * Extract the number of shards from the settings map.
      * Returns 1 as default if not specified or if parsing fails.
diff --git a/src/main/java/io/clustercontroller/models/Index.java b/src/main/java/io/clustercontroller/models/Index.java
index db2bd23..9a0ddf3 100644
--- a/src/main/java/io/clustercontroller/models/Index.java
+++ b/src/main/java/io/clustercontroller/models/Index.java
@@ -23,6 +23,8 @@ public class Index {
     @JsonProperty("shard_replica_count")
     private List<Integer> shardReplicaCount = new ArrayList<>();
     
+    @JsonProperty("num_shards")
+    private Integer numShards = 1; // default to 1 shard
     
     @JsonProperty("created_at")
     private String createdAt = java.time.OffsetDateTime.now().toString(); // ISO timestamp for proper ordering
@@ -32,6 +34,12 @@ public class Index {
         this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>();
     }
     
+    public Index(String indexName, List<Integer> shardReplicaCount, Integer numShards) {
+        this.indexName = indexName;
+        this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>();
+        this.numShards = numShards != null ? numShards : 1;
+    }
+    
     // Custom setters to maintain null safety
     public void setShardReplicaCount(List<Integer> shardReplicaCount) { 
         this.shardReplicaCount = shardReplicaCount != null ? shardReplicaCount : new ArrayList<>(); 
diff --git a/src/main/java/io/clustercontroller/models/ShardAllocation.java b/src/main/java/io/clustercontroller/models/ShardAllocation.java
new file mode 100644
index 0000000..fc70635
--- /dev/null
+++ b/src/main/java/io/clustercontroller/models/ShardAllocation.java
@@ -0,0 +1,24 @@
+package io.clustercontroller.models;
+
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.List;
+
+/**
+ * Simple model for planned shard allocation.
+ */
+@Data
+@NoArgsConstructor
+public class ShardAllocation {
+    
+    private String shardId;
+    private String indexName;
+    private List<String> searchUnitNames;
+    
+    public ShardAllocation(String shardId, String indexName, List<String> searchUnitNames) {
+        this.shardId = shardId;
+        this.indexName = indexName;
+        this.searchUnitNames = searchUnitNames;
+    }
+}
diff --git a/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java b/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
index e02f427..96cbe41 100644
--- a/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
+++ b/src/main/java/io/clustercontroller/store/EtcdMetadataStore.java
@@ -23,6 +23,7 @@ import io.grpc.stub.StreamObserver;
 import lombok.extern.slf4j.Slf4j;
 
 import java.nio.charset.StandardCharsets;
+import java.nio.file.Paths;
 import java.time.OffsetDateTime;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
@@ -513,6 +514,76 @@ public class EtcdMetadataStore implements MetadataStore {
         }
     }
     
+    @Override
+    public void deleteIndexSettings(String clusterId, String indexName) throws Exception {
+        log.debug("Deleting index settings for {} from etcd", indexName);
+        
+        try {
+            String settingsPath = pathResolver.getIndexSettingsPath(clusterId, indexName);
+            executeEtcdDelete(settingsPath);
+            
+            log.debug("Successfully deleted index settings for {} from etcd", indexName);
+            
+        } catch (Exception e) {
+            log.error("Failed to delete index settings for {} from etcd: {}", indexName, e.getMessage(), e);
+            throw new Exception("Failed to delete index settings from etcd", e);
+        }
+    }
+    
+    @Override
+    public void deleteIndexMappings(String clusterId, String indexName) throws Exception {
+        log.debug("Deleting index mappings for {} from etcd", indexName);
+        
+        try {
+            String mappingsPath = pathResolver.getIndexMappingsPath(clusterId, indexName);
+            executeEtcdDelete(mappingsPath);
+            
+            log.debug("Successfully deleted index mappings for {} from etcd", indexName);
+            
+        } catch (Exception e) {
+            log.error("Failed to delete index mappings for {} from etcd: {}", indexName, e.getMessage(), e);
+            throw new Exception("Failed to delete index mappings from etcd", e);
+        }
+    }
+    
+    // =================================================================
+    // SHARD ALLOCATION OPERATIONS
+    // =================================================================
+    
+    @Override
+    public void deletePlannedAllocation(String clusterId, String indexName, String shardId) throws Exception {
+        log.debug("Deleting planned allocation for index {} shard {} from etcd", indexName, shardId);
+
+        try {
+            String allocationPath = pathResolver.getShardPlannedAllocationPath(clusterId, indexName, shardId);
+            executeEtcdDelete(allocationPath);
+
+            log.debug("Successfully deleted planned allocation for index {} shard {} from etcd", indexName, shardId);
+
+        } catch (Exception e) {
+            log.error("Failed to delete planned allocation for index {} shard {} from etcd: {}", 
+                indexName, shardId, e.getMessage(), e);
+            throw new Exception("Failed to delete planned allocation from etcd", e);
+        }
+    }
+    
+    @Override
+    public void updateSearchUnitGoalState(String clusterId, String unitName, SearchUnitGoalState goalState) throws Exception {
+        log.debug("Updating search unit goal state for unit {} in etcd", unitName);
+
+        try {
+            String goalStatePath = pathResolver.getSearchUnitGoalStatePath(clusterId, unitName);
+            String goalStateJson = objectMapper.writeValueAsString(goalState);
+            executeEtcdPut(goalStatePath, goalStateJson);
+
+            log.debug("Successfully updated search unit goal state for unit {} in etcd", unitName);
+
+        } catch (Exception e) {
+            log.error("Failed to update search unit goal state for unit {} in etcd: {}", unitName, e.getMessage(), e);
+            throw new Exception("Failed to update search unit goal state in etcd", e);
+        }
+    }
+    
     // =================================================================
     // CLUSTER OPERATIONS
     // =================================================================
diff --git a/src/main/java/io/clustercontroller/store/MetadataStore.java b/src/main/java/io/clustercontroller/store/MetadataStore.java
index 744d331..7e6280a 100644
--- a/src/main/java/io/clustercontroller/store/MetadataStore.java
+++ b/src/main/java/io/clustercontroller/store/MetadataStore.java
@@ -1,7 +1,6 @@
 package io.clustercontroller.store;
 
 import io.clustercontroller.models.Index;
-
 import io.clustercontroller.models.TaskMetadata;
 import io.clustercontroller.models.SearchUnit;
 import io.clustercontroller.models.SearchUnitActualState;
@@ -97,6 +96,11 @@ public interface MetadataStore {
      * Get search unit actual state
      */
     Optional<SearchUnitActualState> getSearchUnitActualState(String clusterId, String unitName) throws Exception;
+    
+    /**
+     * Update search unit goal state
+     */
+    void updateSearchUnitGoalState(String clusterId, String unitName, SearchUnitGoalState goalState) throws Exception;
     // =================================================================
     // INDEX CONFIGURATIONS OPERATIONS
     // =================================================================
@@ -136,6 +140,25 @@ public interface MetadataStore {
      */
     void setIndexSettings(String clusterId, String indexName, String settings) throws Exception;
     
+    /**
+     * Delete index settings
+     */
+    void deleteIndexSettings(String clusterId, String indexName) throws Exception;
+    
+    /**
+     * Delete index mappings
+     */
+    void deleteIndexMappings(String clusterId, String indexName) throws Exception;
+    
+    // =================================================================
+    // SHARD ALLOCATION OPERATIONS
+    // =================================================================
+    
+    /**
+     * Delete a planned allocation for a specific shard
+     */
+    void deletePlannedAllocation(String clusterId, String indexName, String shardId) throws Exception;
+    
     // =================================================================
     // CLUSTER OPERATIONS
     // =================================================================
diff --git a/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java b/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
index 01615ab..5aaef44 100644
--- a/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
+++ b/src/test/java/io/clustercontroller/api/handlers/IndexHandlerTest.java
@@ -104,7 +104,7 @@ class IndexHandlerTest {
     }
 
     @Test
-    void testDeleteIndex_Success() {
+    void testDeleteIndex_Success() throws Exception {
         // Given
         doNothing().when(indexManager).deleteIndex(anyString(), anyString());
 
@@ -124,7 +124,7 @@ class IndexHandlerTest {
     }
 
     @Test
-    void testDeleteIndex_UnsupportedOperation() {
+    void testDeleteIndex_UnsupportedOperation() throws Exception {
         // Given
         doThrow(new UnsupportedOperationException("Not implemented"))
             .when(indexManager).deleteIndex(anyString(), anyString());
-- 
2.50.1

